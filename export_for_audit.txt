=== .streamlit/config.toml ===
[theme]
# ThÃ¨me sombre avec les couleurs du Relais
base = "dark"
primaryColor = "#A9CF3B"              # Vert du Relais
backgroundColor = "#0F1318"           # Fond trÃ¨s sombre
secondaryBackgroundColor = "#1A1F26"  # Fond secondaire
textColor = "#F2F3F5"                 # Texte clair
font = "sans serif"

[client]
# Configuration minimale de la toolbar
toolbarMode = "minimal"
showErrorDetails = false

[runner]
# Optimisations de performance
magicEnabled = true

[server]
# Configuration serveur
headless = true
runOnSave = true
maxUploadSize = 10
enableCORS = true
enableXsrfProtection = true

[browser]
# Collecte des stats d'usage (dÃ©sactivÃ© pour confidentialitÃ©)
gatherUsageStats = false


=== .streamlit/secrets.toml ===
[secrets]
TECH_PIN = "1234"


=== guignomap/__init__.py ===


=== guignomap/app.py ===
"""GuignoMap â€” fichier rÃ©parÃ© (UTF-8).
Ce bloc contenait du texte libre/Â©/accents, il est dÃ©sormais dans une docstring.
"""

from pathlib import Path
import time
from datetime import datetime
import pandas as pd
import streamlit as st

# --- Helpers pandas/NumPy: force un SCALAIRE natif ---
from typing import Any
def to_scalar(x: Any) -> Any:
    try:
        import pandas as pd
        if isinstance(x, pd.Series):
            if len(x) == 0: return 0
            x = x.iloc[0]
    except Exception:
        pass
    try:
        import numpy as np
        if isinstance(x, np.ndarray):
            if x.size == 0: return 0
            try: return x.item()
            except Exception: return x.reshape(-1)[0]
    except Exception:
        pass
    try:
        return x.item()  # numpy scalar
    except Exception:
        return x

def gt_zero(x: Any) -> bool:
    v = to_scalar(x)
    try:
        return float(v) > 0.0
    except Exception:
        # bool sur tout objet Python (Series dÃ©jÃ  aplatie)
        return bool(v)
# -----------------------------------------------------

import folium
from streamlit_folium import st_folium
import PIL.Image

# Augmenter la limite d'images PIL pour Ã©viter DecompressionBombError
PIL.Image.MAX_IMAGE_PIXELS = 500000000

# Import des modules locaux
from guignomap import db
from guignomap.validators import validate_and_clean_input
from guignomap.osm import build_geometry_cache, load_geometry_cache, build_addresses_cache, load_addresses_cache, CACHE_FILE

# Configuration des chemins
DB_PATH = Path(__file__).parent / "guigno_map.db"

# --- Utilitaire de compatibilitÃ© pandas Styler ---
from typing import Callable, Any

def style_map_compat(df: pd.DataFrame, fn: Callable[[Any], str], subset: Any = None):
    """Applique un style cellule-Ã -cellule en utilisant Styler.map si disponible,
    sinon fallback dynamique vers applymap sans exposer l'attribut (OK pour Pylance).
    
    Args:
        df: DataFrame Ã  styliser
        fn: Fonction qui prend une valeur cellule et retourne une string CSS
        subset: Colonnes Ã  cibler (ex: ['status'] ou None pour toutes)
    """
    styler = df.style
    if hasattr(styler, "map"):
        # Pandas 2.4+ : utilise la nouvelle API map()
        return styler.map(fn, subset=subset)
    # Pandas < 2.4 : fallback vers applymap (sans rÃ©fÃ©rence statique)
    return getattr(styler, "applymap")(fn, subset=subset)

# --- Mapping des statuts pour l'affichage ---
STATUS_TO_LABEL = {"a_faire": " faire", "en_cours": "En cours", "terminee": "TerminÃ©e"}
LABEL_TO_STATUS = {v: k for k, v in STATUS_TO_LABEL.items()}

ASSETS = Path(__file__).parent / "assets"

# Configuration Streamlit
st.set_page_config(
    page_title="Guigno-Map | Relais de Mascouche",
    page_icon="",
    layout="wide",
    initial_sidebar_state="expanded"
)

# Initialisation session
if "auth" not in st.session_state:
    st.session_state.auth = None

# ============================================
# COMPOSANTS UI
# ============================================

def inject_css():
    """Charge le CSS depuis le fichier externe"""
    css_file = ASSETS / "styles.css"
    if css_file.exists():
        css = css_file.read_text(encoding="utf-8")
        st.markdown(f"<style>{css}</style>", unsafe_allow_html=True)

def render_header():
    """Header moderne avec logo GuignolÃ©e et design festif"""
    
    # Container principal avec fond festif
    st.markdown("""
    <div style="
        background: linear-gradient(135deg, #c41e3a 0%, #165b33 100%);
        border-radius: 20px;
        padding: 2rem;
        margin-bottom: 2rem;
        position: relative;
        overflow: hidden;
        box-shadow: 0 10px 30px rgba(0,0,0,0.3);
    ">
        <!-- Flocons de neige animÃ©s en CSS -->
        <div style="position: absolute; width: 100%; height: 100%; opacity: 0.1;">
            <span style="position: absolute; top: 10%; left: 10%; font-size: 2rem;">ï¸</span>
            <span style="position: absolute; top: 20%; left: 80%; font-size: 1.5rem;">ï¸</span>
            <span style="position: absolute; top: 60%; left: 30%; font-size: 1.8rem;">ï¸</span>
        </div>
    """, unsafe_allow_html=True)
    
    col1, col2, col3 = st.columns([2, 5, 2])
    
    with col1:
        # Logo GuignolÃ©e
        if (ASSETS / "guignolee.png").exists():
            st.image(str(ASSETS / "guignolee.png"), width=150)
    
    with col2:
        st.markdown("""
        <div style="text-align: center;">
            <h1 style="
                color: white;
                font-family: 'Manrope', sans-serif;
                font-size: 2.5rem;
                margin: 0;
                text-shadow: 3px 3px 6px rgba(0,0,0,0.5);
                letter-spacing: 2px;
            "> GUIGNOLE 2025 </h1>
            <p style="
                color: #FFD700;
                font-size: 1.2rem;
                margin: 0.5rem 0 0 0;
                font-weight: 600;
            ">Le Relais de Mascouche - 1er dÃ©cembre</p>
            <p style="
                color: rgba(255,255,255,0.9);
                font-size: 1rem;
                margin-top: 0.5rem;
            ">SystÃ¨me de gestion de collecte</p>
        </div>
        """, unsafe_allow_html=True)
    
    with col3:
        # Stats en temps rÃ©el
        stats = db.extended_stats(st.session_state.get('conn'))
        progress = (stats['done'] / stats['total'] * 100) if stats['total'] > 0 else 0
        
        st.markdown(f"""
        <div style="
            background: rgba(255,255,255,0.2);
            border-radius: 15px;
            padding: 1rem;
            text-align: center;
        ">
            <div style="color: #FFD700; font-size: 2rem; font-weight: bold;">
                {progress:.0f}%
            </div>
            <div style="color: white; font-size: 0.9rem;">
                ComplÃ©tÃ©
            </div>
        </div>
        """, unsafe_allow_html=True)
    
    st.markdown("</div>", unsafe_allow_html=True)

def render_login_card(role="benevole", conn=None):
    """Carte de connexion moderne avec design festif"""
    
    # Container de connexion stylisÃ©
    st.markdown("""
    <div style="
        max-width: 400px;
        margin: 3rem auto;
        background: linear-gradient(135deg, rgba(255,255,255,0.1), rgba(255,255,255,0.05));
        backdrop-filter: blur(10px);
        border: 2px solid rgba(255,215,0,0.3);
        border-radius: 20px;
        padding: 2rem;
        box-shadow: 0 20px 40px rgba(0,0,0,0.3);
    ">
    """, unsafe_allow_html=True)
    
    # IcÃ´ne et titre
    if role == "superviseur" or role == "gestionnaire":
        st.markdown("""
        <div style="text-align: center; margin-bottom: 2rem;">
            <div style="font-size: 3rem;"></div>
            <h2 style="color: #FFD700; margin: 1rem 0;">Espace Gestionnaire</h2>
            <p style="color: #cbd5e1;">GÃ©rez la collecte et les Ã©quipes</p>
        </div>
        """, unsafe_allow_html=True)
        
        with st.form("login_gestionnaire", clear_on_submit=False):
            password = st.text_input(
                " Mot de passe",
                type="password",
                placeholder="Entrez le mot de passe gestionnaire"
            )
            
            col1, col2, col3 = st.columns([1,2,1])
            with col2:
                submit = st.form_submit_button(
                    " Connexion",
                    width="stretch"
                )
            
            if submit:
                if db.verify_team(conn, "ADMIN", password):
                    st.session_state.auth = {"role": "supervisor", "team_id": "ADMIN"}
                    st.success(" Bienvenue dans l'espace gestionnaire!")
                    st.snow()
                    time.sleep(1)
                    st.rerun()
                else:
                    st.error(" Mot de passe incorrect")
    
    else:  # BÃ©nÃ©vole
        st.markdown("""
        <div style="text-align: center; margin-bottom: 2rem;">
            <div style="font-size: 3rem;"></div>
            <h2 style="color: #FFD700; margin: 1rem 0;">Espace BÃ©nÃ©vole</h2>
            <p style="color: #cbd5e1;">AccÃ©dez Ã  vos rues assignÃ©es</p>
        </div>
        """, unsafe_allow_html=True)
        
        with st.form("login_benevole", clear_on_submit=False):
            col1, col2 = st.columns(2)
            
            with col1:
                team_id = st.text_input(
                    " Identifiant d'Ã©quipe",
                    placeholder="Ex: EQ001"
                )
            
            with col2:
                password = st.text_input(
                    " Mot de passe",
                    type="password",
                    placeholder="Mot de passe Ã©quipe"
                )
            
            col1, col2, col3 = st.columns([1,2,1])
            with col2:
                submit = st.form_submit_button(
                    " Connexion",
                    width="stretch"
                )
            
            if submit:
                if db.verify_team(conn, team_id, password):
                    st.session_state.auth = {"role": "volunteer", "team_id": team_id}
                    st.success(f" Bienvenue Ã©quipe {team_id}!")
                    st.snow()
                    time.sleep(1)
                    st.rerun()
                else:
                    st.error(" Identifiants incorrects")
    
    st.markdown("</div>", unsafe_allow_html=True)
    
    # Aide en bas
    st.markdown("""
    <div style="text-align: center; margin-top: 2rem; color: #8b92a4;">
        <small>
        Besoin d'aide? Contactez votre gestionnaire<br>
         450-474-4133
        </small>
    </div>
    """, unsafe_allow_html=True)

def render_metrics(stats):
    """Affiche les mÃ©triques principales"""
    progress = (stats['done'] / stats['total'] * 100) if stats['total'] > 0 else 0
    
    col1, col2, col3, col4 = st.columns(4)
    
    with col1:
        st.metric("Total Rues", stats['total'])
    
    with col2:
        st.metric("Rues TerminÃ©es", stats['done'])
    
    with col3:
        st.metric("En Cours", stats.get('partial', 0))
    
    with col4:
        st.metric("Progression", f"{progress:.1f}%")

def render_dashboard_gestionnaire(conn, geo):
    """Dashboard moderne pour gestionnaires avec KPIs visuels"""
    
    # KPIs principaux en cartes colorÃ©es
    stats = db.extended_stats(conn)
    progress = (stats['done'] / stats['total'] * 100) if stats['total'] > 0 else 0
    
    st.markdown("###  Tableau de bord en temps rÃ©el")
    
    # Ligne de KPIs avec icÃ´nes festives
    col1, col2, col3, col4, col5 = st.columns(5)
    
    with col1:
        st.markdown(f"""
        <div style="
            background: linear-gradient(135deg, #22c55e, #16a34a);
            padding: 1.5rem;
            border-radius: 15px;
            text-align: center;
            box-shadow: 0 4px 15px rgba(34,197,94,0.3);
        ">
            <div style="font-size: 2.5rem;">ï¸</div>
            <div style="color: white; font-size: 2rem; font-weight: bold;">{stats['total']}</div>
            <div style="color: rgba(255,255,255,0.9); font-size: 0.9rem;">Total Rues</div>
        </div>
        """, unsafe_allow_html=True)
    
    with col2:
        st.markdown(f"""
        <div style="
            background: linear-gradient(135deg, #3b82f6, #2563eb);
            padding: 1.5rem;
            border-radius: 15px;
            text-align: center;
            box-shadow: 0 4px 15px rgba(59,130,246,0.3);
        ">
            <div style="font-size: 2.5rem;"></div>
            <div style="color: white; font-size: 2rem; font-weight: bold;">{stats['done']}</div>
            <div style="color: rgba(255,255,255,0.9); font-size: 0.9rem;">TerminÃ©es</div>
        </div>
        """, unsafe_allow_html=True)
    
    with col3:
        st.markdown(f"""
        <div style="
            background: linear-gradient(135deg, #f59e0b, #d97706);
            padding: 1.5rem;
            border-radius: 15px;
            text-align: center;
            box-shadow: 0 4px 15px rgba(245,158,11,0.3);
        ">
            <div style="font-size: 2.5rem;"></div>
            <div style="color: white; font-size: 2rem; font-weight: bold;">{stats.get('partial', 0)}</div>
            <div style="color: rgba(255,255,255,0.9); font-size: 0.9rem;">En cours</div>
        </div>
        """, unsafe_allow_html=True)
    
    with col4:
        # Nombre d'Ã©quipes actives
        teams_count = len(db.teams(conn))
        st.markdown(f"""
        <div style="
            background: linear-gradient(135deg, #8b5cf6, #7c3aed);
            padding: 1.5rem;
            border-radius: 15px;
            text-align: center;
            box-shadow: 0 4px 15px rgba(139,92,246,0.3);
        ">
            <div style="font-size: 2.5rem;"></div>
            <div style="color: white; font-size: 2rem; font-weight: bold;">{teams_count}</div>
            <div style="color: rgba(255,255,255,0.9); font-size: 0.9rem;">quipes</div>
        </div>
        """, unsafe_allow_html=True)
    
    with col5:
        st.markdown(f"""
        <div style="
            background: linear-gradient(135deg, #c41e3a, #165b33);
            padding: 1.5rem;
            border-radius: 15px;
            text-align: center;
            box-shadow: 0 4px 15px rgba(196,30,58,0.3);
        ">
            <div style="font-size: 2.5rem;"></div>
            <div style="color: white; font-size: 2rem; font-weight: bold;">{progress:.0f}%</div>
            <div style="color: rgba(255,255,255,0.9); font-size: 0.9rem;">Progression</div>
        </div>
        """, unsafe_allow_html=True)
    
    # Barre de progression visuelle
    st.markdown("###  Progression globale")
    st.progress(progress / 100)
    
    # Graphique par secteur (si disponible)
    st.markdown("###  Performance par Ã©quipe")
    try:
        teams_stats = db.stats_by_team(conn)
        if not teams_stats.empty:
            # Graphique en barres colorÃ©es
            import plotly.express as px
            fig = px.bar(
                teams_stats, 
                x='team', 
                y='progress',
                color='progress',
                color_continuous_scale=['#ef4444', '#f59e0b', '#22c55e'],
                labels={'team': 'quipe', 'progress': 'Progression (%)'},
                title="Performance des Ã©quipes"
            )
            fig.update_layout(
                plot_bgcolor='rgba(0,0,0,0)',
                paper_bgcolor='rgba(0,0,0,0)',
                font_color='white'
            )
            st.plotly_chart(fig, width="stretch")
        else:
            st.info("Aucune statistique d'Ã©quipe disponible")
    except Exception as e:
        st.warning("Graphiques non disponibles (module plotly manquant)")
        # Fallback vers un tableau simple
        try:
            teams_stats = db.stats_by_team(conn)
            if not teams_stats.empty:
                st.dataframe(teams_stats, width="stretch")
        except:
            st.info("Aucune statistique d'Ã©quipe disponible")

def add_persistent_legend(m):
    """Ajoute une lÃ©gende persistante pour les 4 Ã©tats des rues via contrÃ´le HTML"""
    legend_html = """
    <div id='gm-legend' class='leaflet-control-layers leaflet-control' 
         style='position: absolute; bottom: 10px; right: 10px; z-index: 1000;
                background: white; border: 2px solid rgba(0,0,0,0.2); 
                border-radius: 5px; padding: 10px; box-shadow: 0 1px 5px rgba(0,0,0,0.2);
                font-family: "Helvetica Neue", Arial, Helvetica, sans-serif; 
                font-size: 12px; line-height: 18px; color: #333;'>
        <strong style='margin-bottom: 8px; display: block;'>LÃ©gende</strong>
        <div style='margin: 4px 0; display: flex; align-items: center;'>
            <span style='width: 20px; height: 0; border-top: 3px solid #28a745; 
                         display: inline-block; margin-right: 8px;'></span>
            <span>TerminÃ©e</span>
        </div>
        <div style='margin: 4px 0; display: flex; align-items: center;'>
            <span style='width: 20px; height: 0; border-top: 3px solid #f1c40f; 
                         display: inline-block; margin-right: 8px;'></span>
            <span>En cours</span>
        </div>
        <div style='margin: 4px 0; display: flex; align-items: center;'>
            <span style='width: 20px; height: 0; border-top: 3px solid #ff4d4f; 
                         display: inline-block; margin-right: 8px;'></span>
            <span>AssignÃ©e (Ã  faire)</span>
        </div>
        <div style='margin: 4px 0; display: flex; align-items: center;'>
            <span style='width: 20px; height: 0; border-top: 3px dashed #ff4d4f; 
                         display: inline-block; margin-right: 8px;'></span>
            <span>Non assignÃ©e</span>
        </div>
    </div>
    """
    m.get_root().html.add_child(folium.Element(legend_html))

def create_map(df, geo):
    """CrÃ©e la carte Folium centrÃ©e sur Mascouche avec toutes les rues"""
    # Limites de Mascouche
    bounds = {
        "north": 45.78,
        "south": 45.70,
        "east": -73.55,
        "west": -73.70
    }
    center = [(bounds["north"] + bounds["south"]) / 2, 
              (bounds["east"] + bounds["west"]) / 2]
    
    # CrÃ©er la carte
    m = folium.Map(
        location=center,
        zoom_start=13,  # Zoom optimisÃ© pour voir toute la ville
        tiles="https://{s}.tile.openstreetmap.fr/osmfr/{z}/{x}/{y}.png",
        attr='Â© OpenStreetMap France',
        control_scale=True,
        max_bounds=True,
        min_zoom=11,
        max_zoom=18,
        prefer_canvas=True,
        zoom_control=True,
        scrollWheelZoom=True
    )
    
    # Ajouter plusieurs couches de fond
    folium.TileLayer(
        tiles='https://{s}.tile.openstreetmap.fr/osmfr/{z}/{x}/{y}.png',
        attr='Â© OpenStreetMap France',
        name='OSM France (DÃ©taillÃ©)',
        overlay=False,
        control=True
    ).add_to(m)

    folium.TileLayer(
        tiles='https://{s}.basemaps.cartocdn.com/rastertiles/voyager/{z}/{x}/{y}.png',
        attr='Â© CARTO',
        name='CARTO Voyager',
        overlay=False,
        control=True
    ).add_to(m)

    folium.TileLayer(
        tiles='https://server.arcgisonline.com/ArcGIS/rest/services/World_Street_Map/MapServer/tile/{z}/{y}/{x}',
        attr='Â© Esri',
        name='Esri WorldStreetMap',
        overlay=False,
        control=True
    ).add_to(m)

    # Ajouter le contrÃ´le des couches
    folium.LayerControl().add_to(m)
    
    # DÃ©finir les limites de la carte sur Mascouche
    m.fit_bounds([[bounds["south"], bounds["west"]], 
                  [bounds["north"], bounds["east"]]])
    
    if not geo:
        st.warning("Aucune donnÃ©e gÃ©omÃ©trique disponible")
        return m
    
    # Construire le lookup des infos DB
    street_info = {}
    if not df.empty:
        for idx, row in df.iterrows():
            name = str(row['name']) if 'name' in df.columns else ''
            status = row['status'] if 'status' in df.columns and pd.notna(row['status']) else 'a_faire'
            team = row['team'] if 'team' in df.columns and pd.notna(row['team']) else ''
            notes = str(row['notes']) if 'notes' in df.columns and pd.notna(row['notes']) else '0'
            
            street_info[name] = {
                'status': status,
                'team': str(team).strip() if team else '',
                'notes': notes
            }
    
    # Couleurs par statut
    status_colors = {
        'terminee': '#22c55e',  # Vert
        'en_cours': '#f59e0b',  # Orange
        'a_faire': '#ef4444'    # Rouge
    }
    
    # Compteurs pour stats
    stats = {"total": 0, "assigned": 0, "unassigned": 0}
    
    # Ajouter TOUTES les rues de la gÃ©omÃ©trie
    for name, paths in geo.items():
        stats["total"] += 1
        
        # Info depuis DB ou dÃ©faut (rouge pointillÃ©)
        info = street_info.get(name, {
            'status': 'a_faire',
            'team': '',
            'notes': '0'
        })
        
        status = info['status']
        team = info['team']
        notes = info['notes']
        
        # Style: TOUJOURS pointillÃ© si pas d'Ã©quipe
        has_team = bool(team)
        color = status_colors.get(status, '#ef4444')  # Rouge par dÃ©faut
        opacity = 0.9 if has_team else 0.7
        dash = None if has_team else '8,12'  # PointillÃ©s si non assignÃ©
        weight = 7 if has_team else 5
        
        if has_team:
            stats["assigned"] += 1
        else:
            stats["unassigned"] += 1
        
        # Tooltip informatif
        tooltip_html = f"""
        <div style='font-family: sans-serif'>
            <strong style='font-size: 14px'>{name}</strong><br>
            <span style='color: {color}'> Statut: {status.replace('_', ' ').title()}</span><br>
            <span> quipe: {team if team else 'ï¸ NON ASSIGNE'}</span><br>
            <span> Notes: {notes}</span>
        </div>
        """
        
        # Ajouter chaque segment de la rue
        for path in paths:
            if path and len(path) >= 2:
                folium.PolyLine(
                    path,
                    color=color,
                    weight=weight,
                    opacity=opacity,
                    dash_array=dash,
                    tooltip=folium.Tooltip(tooltip_html, sticky=True)
                ).add_to(m)
    
    # Ajouter un marqueur au centre-ville
    folium.Marker(
        [45.7475, -73.6005],
        popup="Centre-ville de Mascouche",
        tooltip="Centre-ville",
        icon=folium.Icon(color='red', icon='info-sign')
    ).add_to(m)
    
    # Ajouter la lÃ©gende persistante
    add_persistent_legend(m)
    
    return m


# ============================================
# UTILITAIRES EXPORT
# ============================================

def export_excel_professionnel(conn):
    """Export Excel avec mise en forme professionnelle"""
    try:
        from reports import ReportGenerator
        generator = ReportGenerator(conn)
        return generator.generate_excel()
    except ImportError:
        # Fallback si les dÃ©pendances ne sont pas installÃ©es
        return db.export_to_csv(conn)


# ============================================
# FONCTIONNALITS AVANCES
# ============================================

def detect_mobile():
    """DÃ©tecte si l'utilisateur est sur mobile"""
    try:
        # RÃ©cupÃ©rer les paramÃ¨tres de l'URL pour forcer le mode mobile
        query_params = st.experimental_get_query_params()
        if 'mobile' in query_params:
            return True
        
        # Mobile-first approach pour l'instant
        return True
    except:
        return False

def show_notification(message, type="success"):
    """Affiche une notification stylisÃ©e"""
    icons = {
        "success": "",
        "error": "",
        "warning": "ï¸",
        "info": "ï¸"
    }
    colors = {
        "success": "#22c55e",
        "error": "#ef4444", 
        "warning": "#f59e0b",
        "info": "#3b82f6"
    }
    
    st.markdown(f"""
    <div style="
        position: fixed;
        top: 20px;
        right: 20px;
        background: {colors[type]};
        color: white;
        padding: 1rem 1.5rem;
        border-radius: 10px;
        box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        z-index: 9999;
        animation: slideIn 0.3s ease-out;
    ">
        <strong>{icons[type]} {message}</strong>
    </div>
    <style>
    @keyframes slideIn {{
        from {{ transform: translateX(100%); opacity: 0; }}
        to {{ transform: translateX(0); opacity: 1; }}
    }}
    </style>
    """, unsafe_allow_html=True)

def show_team_badges(conn, team_id):
    """Affiche les badges de rÃ©ussite de l'Ã©quipe"""
    try:
        df = db.list_streets(conn, team=team_id)
        done = len(df[df['status'] == 'terminee'])
        total = len(df)
        
        badges = []
        if done >= 1:
            badges.append(" PremiÃ¨re rue!")
        if done >= total * 0.25:
            badges.append(" 25% complÃ©tÃ©")
        if done >= total * 0.5:
            badges.append(" 50% complÃ©tÃ©")
        if done >= total * 0.75:
            badges.append(" 75% complÃ©tÃ©")
        if done == total:
            badges.append(" CHAMPION!")
        
        if badges:
            st.markdown(f"""
            <div style="
                background: linear-gradient(135deg, #FFD700, #FFA500);
                padding: 1rem;
                border-radius: 10px;
                text-align: center;
                margin: 1rem 0;
            ">
                <strong>Vos badges:</strong><br>
                <div style="font-size: 2rem; margin-top: 0.5rem;">
                    {' '.join(badges)}
                </div>
            </div>
            """, unsafe_allow_html=True)
    except:
        pass

def generate_sms_list(conn):
    """GÃ©nÃ¨re une liste de tÃ©lÃ©phones pour SMS de groupe"""
    try:
        # Cette fonction nÃ©cessiterait une table de tÃ©lÃ©phones
        # Pour l'instant, retourne un exemple
        return "# Liste des tÃ©lÃ©phones bÃ©nÃ©voles\n# 450-XXX-XXXX\n# 438-XXX-XXXX"
    except:
        return "Liste non disponible"

def page_export_gestionnaire(conn):
    """Section export avec formats multiples"""
    
    st.markdown("###  Centre d'export des donnÃ©es")
    
    col1, col2, col3 = st.columns(3)
    
    with col1:
        st.markdown("""
        <div style="text-align: center; padding: 1rem; border: 2px dashed #ccc; border-radius: 10px;">
            <h4>  Rapport PDF</h4>
            <p><small>Format professionnel pour prÃ©sentation</small></p>
        </div>
        """, unsafe_allow_html=True)
        
        try:
            from reports import ReportGenerator
            generator = ReportGenerator(conn)
            pdf_data = generator.generate_pdf()
            st.download_button(
                " TÃ©lÃ©charger PDF",
                pdf_data,
                "rapport_guignolee_2025.pdf",
                "application/pdf",
                width="stretch"
            )
        except ImportError:
            st.button("PDF (Installer reportlab)", disabled=True, width="stretch")
    
    with col2:
        st.markdown("""
        <div style="text-align: center; padding: 1rem; border: 2px dashed #ccc; border-radius: 10px;">
            <h4> Excel dÃ©taillÃ©</h4>
            <p><small>Avec graphiques et mise en forme</small></p>
        </div>
        """, unsafe_allow_html=True)
        
        try:
            excel_data = export_excel_professionnel(conn)
            st.download_button(
                " TÃ©lÃ©charger Excel",
                excel_data,
                "guignolee_2025.xlsx",
                "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
                width="stretch"
            )
        except:
            st.button("Excel (Non disponible)", disabled=True, width="stretch")
    
    with col3:
        st.markdown("""
        <div style="text-align: center; padding: 1rem; border: 2px dashed #ccc; border-radius: 10px;">
            <h4> Liste SMS</h4>
            <p><small>TÃ©lÃ©phones des bÃ©nÃ©voles</small></p>
        </div>
        """, unsafe_allow_html=True)
        
        sms_list = generate_sms_list(conn)
        st.download_button(
            " Liste tÃ©lÃ©phones",
            sms_list,
            "telephones_benevoles.txt",
            "text/plain",
            width="stretch"
        )


# ============================================
# PAGES
# ============================================

def page_accueil(conn, geo):
    """Page d'accueil"""
    st.markdown("###  Bienvenue sur Guigno-Map!")
    st.info("SÃ©lectionnez votre mode dans le menu de gauche pour commencer.")
    
    st.markdown("---")
    st.markdown("####  AperÃ§u de la collecte")
    
    stats = db.extended_stats(conn)
    render_metrics(stats)
    
    df_all = db.list_streets(conn)
    if not df_all.empty:
        m = create_map(df_all, geo)
        st_folium(m, height=800, width=None, returned_objects=[])

def page_accueil_v2(conn, geo):
    """Page d'accueil festive avec compte Ã  rebours"""
    
    # Compte Ã  rebours jusqu'au 1er dÃ©cembre
    from datetime import datetime, timedelta
    target = datetime(2025, 12, 1, 8, 0, 0)
    now = datetime.now()
    diff = target - now
    
    if diff.days > 0:
        st.markdown(f"""
        <div style="
            background: linear-gradient(135deg, #c41e3a, #165b33);
            padding: 2rem;
            border-radius: 20px;
            text-align: center;
            margin-bottom: 2rem;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        ">
            <h2 style="color: #FFD700; margin: 0;">â° Compte Ã  rebours GuignolÃ©e</h2>
            <div style="font-size: 3rem; color: white; margin: 1rem 0;">
                {diff.days} jours {diff.seconds//3600} heures
            </div>
            <p style="color: rgba(255,255,255,0.9);">avant le grand jour!</p>
        </div>
        """, unsafe_allow_html=True)
    else:
        st.markdown("""
        <div style="
            background: linear-gradient(135deg, #FFD700, #FFA500);
            padding: 2rem;
            border-radius: 20px;
            text-align: center;
            margin-bottom: 2rem;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        ">
            <h2 style="color: #c41e3a; margin: 0;"> C'EST AUJOURD'HUI!</h2>
            <div style="font-size: 2rem; color: #165b33; margin: 1rem 0;">
                Bonne GuignolÃ©e 2025!
            </div>
        </div>
        """, unsafe_allow_html=True)
    
    # Hero section festif
    st.markdown("""
    <div style="
        text-align: center;
        padding: 3rem 1rem;
        background: linear-gradient(135deg, rgba(196,30,58,0.1), rgba(22,91,51,0.1));
        border-radius: 20px;
        margin-bottom: 2rem;
    ">
        <h1 style="font-size: 3rem; margin: 0;"> Bienvenue sur Guigno-Map </h1>
        <p style="font-size: 1.3rem; color: #666; margin: 1rem 0;">
            Votre plateforme digitale pour la GuignolÃ©e 2025
        </p>
        <p style="color: #888;">
            GÃ©rez efficacement votre collecte de denrÃ©es avec une interface moderne
        </p>
    </div>
    """, unsafe_allow_html=True)
    
    # Stats visuelles amÃ©liorÃ©es
    stats = db.extended_stats(conn)
    progress = (stats['done'] / stats['total'] * 100) if stats['total'] > 0 else 0
    
    st.markdown("###  tat de la collecte en temps rÃ©el")
    
    col1, col2, col3, col4 = st.columns(4)
    
    with col1:
        st.markdown(f"""
        <div style="
            text-align: center;
            padding: 2rem;
            background: linear-gradient(135deg, #22c55e, #16a34a);
            border-radius: 15px;
            color: white;
            box-shadow: 0 4px 15px rgba(34,197,94,0.3);
        ">
            <div style="font-size: 3rem;">ï¸</div>
            <div style="font-size: 2.5rem; font-weight: bold;">{stats['total']}</div>
            <div>Total Rues</div>
        </div>
        """, unsafe_allow_html=True)
    
    with col2:
        st.markdown(f"""
        <div style="
            text-align: center;
            padding: 2rem;
            background: linear-gradient(135deg, #3b82f6, #2563eb);
            border-radius: 15px;
            color: white;
            box-shadow: 0 4px 15px rgba(59,130,246,0.3);
        ">
            <div style="font-size: 3rem;"></div>
            <div style="font-size: 2.5rem; font-weight: bold;">{stats['done']}</div>
            <div>ComplÃ©tÃ©es</div>
        </div>
        """, unsafe_allow_html=True)
    
    with col3:
        st.markdown(f"""
        <div style="
            text-align: center;
            padding: 2rem;
            background: linear-gradient(135deg, #f59e0b, #d97706);
            border-radius: 15px;
            color: white;
            box-shadow: 0 4px 15px rgba(245,158,11,0.3);
        ">
            <div style="font-size: 3rem;"></div>
            <div style="font-size: 2.5rem; font-weight: bold;">{stats.get('partial', 0)}</div>
            <div>En Cours</div>
        </div>
        """, unsafe_allow_html=True)
    
    with col4:
        st.markdown(f"""
        <div style="
            text-align: center;
            padding: 2rem;
            background: linear-gradient(135deg, #c41e3a, #165b33);
            border-radius: 15px;
            color: white;
            box-shadow: 0 4px 15px rgba(196,30,58,0.3);
        ">
            <div style="font-size: 3rem;"></div>
            <div style="font-size: 2.5rem; font-weight: bold;">{progress:.0f}%</div>
            <div>Progression</div>
        </div>
        """, unsafe_allow_html=True)
    
    # Barre de progression globale
    st.markdown("###  Progression globale de la collecte")
    st.progress(progress / 100)
    
    # Carte festive
    st.markdown("### ï¸ Vue d'ensemble de Mascouche")
    df_all = db.list_streets(conn)
    if not df_all.empty:
        m = create_map(df_all, geo)
        st_folium(m, height=750, width=None, returned_objects=[])
    
    # CSS pour rÃ©duire l'espace aprÃ¨s la carte
    st.markdown("""
    <style>
    div[data-testid="stVerticalBlock"] > div:has(iframe) {
        margin-bottom: 0 !important;
    }
    </style>
    """, unsafe_allow_html=True)
    
    # Call to action
    st.markdown("""
    <div style="
        text-align: center;
        padding: 2rem;
        background: linear-gradient(135deg, rgba(255,215,0,0.1), rgba(255,215,0,0.05));
        border: 2px solid rgba(255,215,0,0.3);
        border-radius: 15px;
        margin-top: 1rem;
    ">
        <h3> PrÃªt Ã  participer ?</h3>
        <p>Choisissez votre rÃ´le dans le menu de gauche pour commencer</p>
        <p style="font-size: 0.9rem; color: #666;">
            BÃ©nÃ©voles : AccÃ©dez Ã  vos rues assignÃ©es<br>
            Gestionnaires : Supervisez toute la collecte
        </p>
    </div>
    """, unsafe_allow_html=True)

def page_benevole(conn, geo):
    """Interface bÃ©nÃ©vole moderne avec vue limitÃ©e"""
    
    if not st.session_state.auth or st.session_state.auth.get("role") != "volunteer":
        render_login_card("benevole", conn)
        return
    
    team_id = st.session_state.auth["team_id"]
    
    # Header d'Ã©quipe personnalisÃ©
    st.markdown(f"""
    <div style="
        background: linear-gradient(135deg, #165b33, #c41e3a);
        padding: 1.5rem;
        border-radius: 15px;
        margin-bottom: 2rem;
        text-align: center;
    ">
        <h2 style="color: white; margin: 0;"> quipe {team_id}</h2>
        <p style="color: #FFD700; margin: 0.5rem 0 0 0;">Bonne collecte!</p>
    </div>
    """, unsafe_allow_html=True)
    
    # Stats de l'Ã©quipe
    df_team = db.list_streets(conn, team=team_id)
    if df_team.empty:
        st.warning("Aucune rue assignÃ©e. Contactez votre superviseur.")
        return
    
    done = len(df_team[df_team['status'] == 'terminee'])
    total = len(df_team)
    progress = (done / total * 100) if total > 0 else 0
    
    # Mini dashboard Ã©quipe
    col1, col2, col3 = st.columns(3)
    with col1:
        st.metric(" Vos rues", total)
    with col2:
        st.metric(" ComplÃ©tÃ©es", done)
    with col3:
        st.metric(" Progression", f"{progress:.0f}%")
    
    # SystÃ¨me de badges
    show_team_badges(conn, team_id)
    
    # Barre de progression
    st.progress(progress / 100)
    
    # Tabs modernisÃ©s
    tab1, tab2, tab3 = st.tabs(["ï¸ Ma carte", " Collecte", " Historique"])
    
    with tab1:
        # CARTE LIMITE AUX RUES DE L'QUIPE
        st.markdown("### Vos rues assignÃ©es")
        
        # CrÃ©er une carte avec SEULEMENT les rues de l'Ã©quipe
        m = folium.Map(
            location=[45.7475, -73.6005],
            zoom_start=14,
            tiles='https://{s}.basemaps.cartocdn.com/rastertiles/voyager/{z}/{x}/{y}.png',
            attr='Â© CARTO'
        )
        
        # Filtrer geo pour n'afficher QUE les rues de l'Ã©quipe
        team_streets = df_team['name'].tolist()
        
        for street_name in team_streets:
            if street_name in geo:
                status = df_team[df_team['name'] == street_name]['status'].iloc[0]
                
                # Couleurs selon statut
                colors = {
                    'terminee': '#22c55e',
                    'en_cours': '#f59e0b',
                    'a_faire': '#ef4444'
                }
                color = colors.get(status, '#ef4444')
                
                # Ajouter les segments de cette rue
                for path in geo[street_name]:
                    if path and len(path) >= 2:
                        folium.PolyLine(
                            path,
                            color=color,
                            weight=8,  # Plus Ã©pais pour mobile
                            opacity=0.9,
                            tooltip=f"{street_name} - {status.replace('_', ' ').title()}"
                        ).add_to(m)
        
        # Centrer sur les rues de l'Ã©quipe
        if team_streets and team_streets[0] in geo:
            first_street = geo[team_streets[0]][0]
            if first_street:
                m.location = first_street[0]
        
        st_folium(m, height=650, width=None, returned_objects=[])
    
    with tab2:
        st.markdown("###  Checklist de collecte")
        
        # Liste interactive des rues
        for _, row in df_team.iterrows():
            street = row['name']
            status = row['status']
            notes_count = row.get('notes', 0)
            
            # Carte de rue stylisÃ©e
            status_emoji = {'terminee': '', 'en_cours': '', 'a_faire': ''}
            status_color = {'terminee': '#22c55e', 'en_cours': '#f59e0b', 'a_faire': '#ef4444'}
            
            with st.expander(f"{status_emoji.get(str(to_scalar(status)), '')} **{street}** ({notes_count} notes)"):
                
                # Changement rapide de statut
                col1, col2, col3 = st.columns(3)
                with col1:
                    if st.button("  faire", key=f"todo_{street}", width="stretch"):
                        db.set_status(conn, street, 'a_faire')
                        st.rerun()
                with col2:
                    if st.button(" En cours", key=f"progress_{street}", width="stretch"):
                        db.set_status(conn, street, 'en_cours')
                        st.rerun()
                with col3:
                    if st.button(" TerminÃ©e", key=f"done_{street}", width="stretch"):
                        db.set_status(conn, street, 'terminee')
                        st.rerun()
                
                st.markdown("---")
                
                # Ajout de note rapide
                st.markdown("**Ajouter une note:**")
                with st.form(f"note_{street}", clear_on_submit=True):
                    col1, col2 = st.columns([1, 3])
                    with col1:
                        num = st.text_input("NÂ°", placeholder="123")
                    with col2:
                        note = st.text_input("Note", placeholder="Personne absente")
                    
                    if st.form_submit_button(" Ajouter"):
                        if num and note:
                            db.add_note_for_address(conn, street, team_id, num, note)
                            st.success("Note ajoutÃ©e!")
                            st.rerun()
                
                # Notes existantes
                notes = db.get_street_addresses_with_notes(conn, street)
                if not notes.empty:
                    st.markdown("**Notes existantes:**")
                    for _, n in notes.iterrows():
                        st.markdown(f" **{n['address_number']}** : {n['comment']}")
    
    with tab3:
        st.markdown("###  Votre historique")
        try:
            notes = db.get_team_notes(conn, team_id)
            if not notes.empty:
                st.dataframe(notes, width="stretch")
            else:
                st.info("Aucune note encore")
        except:
            st.info("Historique non disponible")

def page_benevole_v2(conn, geo):
    """Interface bÃ©nÃ©vole moderne v4.1 avec vue 'Mes rues'"""
    
    # VÃ©rifier l'authentification
    if not st.session_state.auth or st.session_state.auth.get("role") != "volunteer":
        # Afficher la page de connexion bÃ©nÃ©vole
        return page_benevole(conn, geo)
    
    # Interface bÃ©nÃ©vole connectÃ© avec tabs
    st.header(" Espace BÃ©nÃ©vole")
    team_id = st.session_state.auth.get("team", "quipe inconnue")
    st.markdown(f"**quipe:** {team_id}")
    
    # Tabs pour bÃ©nÃ©voles
    tabs = st.tabs([
        "ï¸ Mes rues",
        "ï¸ Carte de terrain", 
        " Journal d'activitÃ©"
    ])
    
    with tabs[0]:
        # Nouvelle vue "Mes rues" v4.1
        page_benevole_mes_rues(conn)
    
    with tabs[1]:
        # Carte traditionnelle (rÃ©utilise l'ancienne interface)
        page_benevole(conn, geo)
    
    with tabs[2]:
        # Journal d'activitÃ© de l'Ã©quipe
        st.markdown("###  Journal d'activitÃ© de votre Ã©quipe")
        try:
            # Afficher les activitÃ©s rÃ©centes de l'Ã©quipe
            cursor = conn.execute("""
                SELECT action, details, created_at
                FROM activity_log
                WHERE team_id = ?
                ORDER BY created_at DESC
                LIMIT 20
            """, (team_id,))
            
            activities = cursor.fetchall()
            if activities:
                for activity in activities:
                    action, details, created_at = activity
                    st.markdown(f"**{created_at}** - {action}: {details}")
            else:
                st.info("Aucune activitÃ© enregistrÃ©e pour votre Ã©quipe")
                
        except Exception as e:
            st.info("Journal d'activitÃ© temporairement indisponible")
            st.caption(f"Erreur: {e}")

def page_gestionnaire_v2(conn, geo):
    """Interface gestionnaire moderne (ancien superviseur)"""
    st.header(" Tableau de Bord Gestionnaire")
    
    # VÃ©rifier l'authentification
    if not st.session_state.auth or st.session_state.auth.get("role") != "supervisor":
        render_login_card("gestionnaire", conn)
        return
    
    # Dashboard moderne
    render_dashboard_gestionnaire(conn, geo)
    
    # Tabs
    tabs = st.tabs([
        " Vue d'ensemble",
        " quipes",
        "ï¸ Assignation",
        " Export",
        " Tech"
    ])
    
    with tabs[0]:
        # Carte gÃ©nÃ©rale
        st.markdown("### Carte gÃ©nÃ©rale")
        df_all = db.list_streets(conn)
        if not df_all.empty:
            m = create_map(df_all, geo)
            st_folium(m, height=800, width=None, returned_objects=[])
        
        # ActivitÃ© rÃ©cente
        st.markdown("### ActivitÃ© rÃ©cente")
        try:
            recent = db.recent_activity(conn, limit=10)
            if not recent.empty:
                st.dataframe(recent, width="stretch")
            else:
                st.info("Aucune activitÃ© rÃ©cente")
        except:
            st.info("Historique d'activitÃ© non disponible")
    
    with tabs[1]:
        # Gestion des Ã©quipes
        st.subheader(" Gestion des Ã©quipes", anchor=False)
        
        # === Formulaire de crÃ©ation d'Ã©quipe (robuste) ===
        with st.expander(" CrÃ©er une nouvelle Ã©quipe", expanded=False):
            with st.form("create_team_form", clear_on_submit=True):
                team_id_in = st.text_input(
                    "Identifiant d'Ã©quipe", 
                    key="new_team_id", 
                    placeholder="Ex: EQUIPE1",
                    help="Lettres et chiffres uniquement, max 20 caractÃ¨res"
                )
                team_name_in = st.text_input(
                    "Nom d'Ã©quipe", 
                    key="new_team_name", 
                    placeholder="Ex: quipe Centre",
                    help="Nom descriptif de l'Ã©quipe"
                )
                
                # Toggle pour afficher/masquer les mots de passe
                show_pw = st.checkbox("Afficher les mots de passe", value=False)
                pw_type = "default" if show_pw else "password"
                
                pwd_in = st.text_input(
                    "Mot de passe", 
                    type=pw_type, 
                    key="new_team_pwd", 
                    placeholder="Minimum 4 caractÃ¨res",
                    help="Tout caractÃ¨re acceptÃ©, min 4 / max 128"
                )
                pwd_conf = st.text_input(
                    "Confirmer le mot de passe", 
                    type=pw_type, 
                    key="new_team_pwd_conf", 
                    placeholder="Retapez le mot de passe",
                    help="Doit correspondre au mot de passe ci-dessus"
                )
                
                submitted = st.form_submit_button(" CrÃ©er l'Ã©quipe", width="stretch")

            if submitted:
                # Validation avec validators.py
                ok_id, team_id = validate_and_clean_input("team_id", team_id_in)
                ok_name, team_name = validate_and_clean_input("text", team_name_in)
                ok_pw, password = validate_and_clean_input("password", pwd_in)
                
                if not ok_id:
                    st.error(" Identifiant d'Ã©quipe invalide (lettres/chiffres, max 20)")
                elif not ok_name:
                    st.error(" Nom d'Ã©quipe invalide ou vide")
                elif not ok_pw:
                    st.error(" Mot de passe invalide (minimum 4 caractÃ¨res)")
                elif pwd_in != pwd_conf:
                    st.error(" Les mots de passe ne correspondent pas")
                else:
                    # Tentative de crÃ©ation avec db.create_team
                    try:
                        created = db.create_team(conn, team_id, team_name, password)
                        if created:
                            st.toast(f" quipe {team_id} crÃ©Ã©e avec succÃ¨s", icon="")
                            st.rerun()
                        else:
                            st.error(" chec de crÃ©ation (ID dÃ©jÃ  existant ?)")
                    except Exception as e:
                        st.error(f" Erreur lors de la crÃ©ation: {e}")
        
        # === Liste des Ã©quipes (sans doublon de titre) ===
        try:
            teams_df = db.get_all_teams(conn)
            if not teams_df.empty:
                st.dataframe(teams_df, width="stretch")
            else:
                st.info("Aucune Ã©quipe crÃ©Ã©e")
        except Exception as e:
            st.info("Liste des Ã©quipes non disponible")
    
    with tabs[2]:
        # Assignation v4.1
        page_assignations_v41(conn)
    
    with tabs[3]:
        # Export amÃ©liorÃ© v4.1
        page_export_gestionnaire_v41(conn)

    with tabs[4]:
        st.markdown("###  OpÃ©rations techniques (protÃ©gÃ©es)")

        # -- PIN stockÃ© dans secrets (config.toml -> [secrets] TECH_PIN="xxxx")
        try:
            TECH_PIN = st.secrets.get("TECH_PIN", "")
        except:
            TECH_PIN = ""  # Pas de fichier secrets.toml

        if "tech_ok" not in st.session_state:
            st.session_state.tech_ok = False

        if not st.session_state.tech_ok:
            pin = st.text_input("Entrer le PIN technique", type="password")
            if st.button("DÃ©verrouiller"):
                if TECH_PIN and pin == TECH_PIN:
                    st.session_state.tech_ok = True
                    st.success("AccÃ¨s technique dÃ©verrouillÃ©.")
                    st.rerun()
                else:
                    st.error("PIN invalide.")
            st.stop()

        st.info("ï¸ Ces actions sont lourdes et n'affectent pas les statuts/notes. Elles rÃ©gÃ©nÃ¨rent les caches OSM.")

        # --- Reconstruire le cache gÃ©omÃ©trique (lourd)
        with st.expander(" Reconstruire cache OSM (gÃ©omÃ©tries)", expanded=False):
            col1, col2 = st.columns([1,2])
            with col1:
                confirm = st.checkbox("Je comprends les implications")
            with col2:
                safety = st.text_input('crire "REBUILD" pour confirmer')

            if st.button("Lancer la reconstruction"):
                if confirm and safety.strip().upper() == "REBUILD":
                    with st.spinner("Construction du cache"):
                        build_geometry_cache()       # reconstruit le fichier osm_cache.json
                        st.cache_data.clear()        # purge cache Streamlit
                    st.success(" Cache OSM mis Ã  jour (gÃ©omÃ©tries).")
                    st.rerun()
                else:
                    st.warning("Confirmation incomplÃ¨te.")

        # --- Reconstruire/Importer le cache des adresses
        with st.expander(" Mettre Ã  jour les adresses (OSM)", expanded=False):
            col1, col2 = st.columns([1,2])
            with col1:
                confirmA = st.checkbox("Je confirme")
            with col2:
                safetyA = st.text_input('crire "IMPORT" pour confirmer')

            if st.button("Lancer la mise Ã  jour des adresses"):
                if confirmA and safetyA.strip().upper() == "IMPORT":
                    with st.spinner("TÃ©lÃ©chargement des adresses OSM"):
                        build_addresses_cache()
                        addr_cache = load_addresses_cache()
                        count = db.import_addresses_from_cache(conn, addr_cache)
                    st.success(f" {count} adresses importÃ©es depuis OSM.")
                    st.rerun()
                else:
                    st.warning("Confirmation incomplÃ¨te.")

        # --- Gestion des backups
        with st.expander(" Gestion des backups", expanded=False):
            backup_mgr = db.get_backup_manager(DB_PATH)
            
            col1, col2 = st.columns([2, 1])
            with col1:
                if st.button(" CrÃ©er un backup manuel", width="stretch"):
                    backup_file = backup_mgr.create_backup("manual")
                    if backup_file:
                        st.success(f"Backup crÃ©Ã© : {Path(backup_file).name}")
            
            with col2:
                if st.button(" Voir les backups", width="stretch"):
                    backups = backup_mgr.list_backups()
                    if backups:
                        for backup in backups[:5]:  # Montrer les 5 derniers
                            size_mb = backup.stat().st_size / (1024 * 1024)
                            st.text(f" {backup.name} ({size_mb:.1f} MB)")
                    else:
                        st.info("Aucun backup disponible")

def page_superviseur(conn, geo):
    """Interface superviseur"""
    st.header(" Tableau de Bord Superviseur")
    
    # VÃ©rifier l'authentification
    if not st.session_state.auth or st.session_state.auth.get("role") != "supervisor":
        render_login_card("superviseur", conn)
        return
    
    # Dashboard moderne
    render_dashboard_gestionnaire(conn, geo)
    
    # Tabs
    tabs = st.tabs([
        " Vue d'ensemble",
        " quipes",
        "ï¸ Assignation",
        " Export",
        " Tech"
    ])
    
    with tabs[0]:
        # Carte gÃ©nÃ©rale
        st.markdown("### Carte gÃ©nÃ©rale")
        df_all = db.list_streets(conn)
        if not df_all.empty:
            m = create_map(df_all, geo)
            st_folium(m, height=800, width=None, returned_objects=[])
        
        # ActivitÃ© rÃ©cente
        st.markdown("### ActivitÃ© rÃ©cente")
        recent = db.recent_activity(conn, limit=10)
        if not recent.empty:
            st.dataframe(recent, width="stretch")
    
    with tabs[1]:
        # Gestion des Ã©quipes
        st.markdown("### Gestion des Ã©quipes")
        
        with st.expander("CrÃ©er une Ã©quipe"):
            with st.form("new_team", clear_on_submit=True):
                new_id = st.text_input("Identifiant")
                new_name = st.text_input("quipe")
                new_pass = st.text_input("Mot de passe", type="password")
                
                if st.form_submit_button("CrÃ©er"):
                    if all([new_id, new_name, new_pass]):
                        if db.create_team(conn, new_id, new_name, new_pass):
                            st.success(f"quipe {new_id} crÃ©Ã©e")
                            st.rerun()
        
        # Liste des Ã©quipes
        teams_df = db.get_all_teams(conn)
        if not teams_df.empty:
            st.dataframe(teams_df, width="stretch")
    
    with tabs[2]:
        # Assignation
        st.markdown("### Assignation des rues")
        
        unassigned = db.get_unassigned_streets(conn)
        
        if not unassigned.empty:
            with st.form("assign"):
                team = st.selectbox("quipe", db.teams(conn))
                streets = st.multiselect("Rues", unassigned['name'].tolist())
                
                if st.form_submit_button("Assigner"):
                    if team and streets:
                        db.assign_streets_to_team(conn, streets, team)
                        st.success("Rues assignÃ©es!")
                        st.rerun()
        else:
            st.success("Toutes les rues sont assignÃ©es!")
        
        # Tableau des assignations
        df_all = db.list_streets(conn)
        if not df_all.empty:
            st.dataframe(
                df_all[['name', 'sector', 'team', 'status']],
                width="stretch"
            )
    
    with tabs[3]:
        # Export
        st.markdown("### Export des donnÃ©es")
        
        col1, col2 = st.columns(2)
        
        with col1:
            st.download_button(
                " Export rues (CSV)",
                db.export_to_csv(conn),
                "rapport_rues.csv",
                "text/csv",
                width="stretch"
            )
        
        with col2:
            st.download_button(
                " Export notes (CSV)",
                db.export_notes_csv(conn),
                "rapport_notes.csv",
                "text/csv",
                width="stretch"
            )

    with tabs[4]:
        st.markdown("###  OpÃ©rations techniques (protÃ©gÃ©es)")

        # -- PIN stockÃ© dans secrets (config.toml -> [secrets] TECH_PIN="xxxx")  
        try:
            TECH_PIN = st.secrets.get("TECH_PIN", "")
        except:
            TECH_PIN = ""  # Pas de fichier secrets.toml

        if "tech_ok" not in st.session_state:
            st.session_state.tech_ok = False

        if not st.session_state.tech_ok:
            pin = st.text_input("Entrer le PIN technique", type="password")
            if st.button("DÃ©verrouiller"):
                if TECH_PIN and pin == TECH_PIN:
                    st.session_state.tech_ok = True
                    st.success("AccÃ¨s technique dÃ©verrouillÃ©.")
                    st.rerun()
                else:
                    st.error("PIN invalide.")
            st.stop()

        st.info("ï¸ Ces actions sont lourdes et n'affectent pas les statuts/notes. Elles rÃ©gÃ©nÃ¨rent les caches OSM.")

        # --- Reconstruire le cache gÃ©omÃ©trique (lourd)
        with st.expander(" Reconstruire cache OSM (gÃ©omÃ©tries)", expanded=False):
            col1, col2 = st.columns([1,2])
            with col1:
                confirm = st.checkbox("Je comprends les implications")
            with col2:
                safety = st.text_input('crire "REBUILD" pour confirmer')

            if st.button("Lancer la reconstruction"):
                if confirm and safety.strip().upper() == "REBUILD":
                    with st.spinner("Construction du cache"):
                        build_geometry_cache()       # reconstruit le fichier osm_cache.json
                        st.cache_data.clear()        # purge cache Streamlit
                    st.success(" Cache OSM mis Ã  jour (gÃ©omÃ©tries).")
                    st.rerun()
                else:
                    st.warning("Confirmation incomplÃ¨te.")

        # --- Reconstruire/Importer le cache des adresses
        with st.expander(" Mettre Ã  jour les adresses (OSM)", expanded=False):
            col1, col2 = st.columns([1,2])
            with col1:
                confirmA = st.checkbox("Je confirme")
            with col2:
                safetyA = st.text_input('crire "IMPORT" pour confirmer')

            if st.button("Lancer la mise Ã  jour des adresses"):
                if confirmA and safetyA.strip().upper() == "IMPORT":
                    with st.spinner("TÃ©lÃ©chargement des adresses OSM"):
                        build_addresses_cache()
                        addr_cache = load_addresses_cache()
                        count = db.import_addresses_from_cache(conn, addr_cache)
                    st.success(f" {count} adresses importÃ©es depuis OSM.")
                    st.rerun()
                else:
                    st.warning("Confirmation incomplÃ¨te.")

# ================================================================================
# NOUVELLES FONCTIONS v4.1 - SUPERVISEUR ET BNVOLE
# ================================================================================

def page_assignations_v41(conn):
    """Panneau d'assignations v4.1 pour superviseurs"""
    
    try:
        # ===== Bloc Assignations (refactor propre) =====
        st.subheader("ï¸ Assignations par secteur", anchor=False)
        
        # Compteur de rues non assignÃ©es (banniÃ¨re info)
        unassigned_count = db.get_unassigned_streets_count(conn)
        if unassigned_count > 0:
            st.info(f"ï¸ {unassigned_count} rue(s) non assignÃ©e(s)")
        
        with st.container():
            c1, c2, c3 = st.columns([1, 1.2, 0.7], vertical_alignment="bottom")
            
            with c1:
                # RÃ©cupÃ©rer la liste des secteurs
                liste_secteurs = db.get_sectors_list(conn)
                secteur = st.selectbox(
                    "SECTEUR  ASSIGNER",
                    options=[""] + (liste_secteurs if liste_secteurs else []),
                    index=0,
                    key="assign_sector",
                    help="Choisissez le secteur Ã  assigner",
                    label_visibility="visible",
                )
            
            with c2:
                # RÃ©cupÃ©rer la liste des Ã©quipes
                teams = db.get_teams_list(conn)
                liste_equipes = [f"{team[1]} ({team[0]})" for team in teams] if teams else []
                
                if liste_equipes:
                    team_display = st.selectbox(
                        "QUIPE", 
                        options=[""] + liste_equipes, 
                        index=0, 
                        key="assign_team"
                    )
                    # Extraire l'ID de l'Ã©quipe
                    team = ""
                    if team_display and team_display != "":
                        team = team_display.split("(")[-1].rstrip(")")
                else:
                    st.info("Aucune Ã©quipe disponible")
                    team = None
            
            with c3:
                disabled = not (secteur and team)
                if st.button(" Assigner tout le secteur", width="stretch", disabled=disabled):
                    # Appel mÃ©tier : assigner toutes les rues non assignÃ©es du secteur Ã  l'Ã©quipe
                    if secteur and team:
                        try:
                            nb = db.bulk_assign_sector(conn, secteur, team)
                            if nb > 0:
                                st.toast(f" {nb} rue(s) assignÃ©e(s) Ã  l'Ã©quipe {team}", icon="")
                                st.rerun()
                            else:
                                st.toast("ï¸ Aucune rue non assignÃ©e dans ce secteur", icon="ï¸")
                        except Exception as e:
                            st.error(f"Erreur lors de l'assignation: {e}")
        
        # ===== Tableau d'Ã©tat (uniforme, sans style spÃ©cial) =====
        st.markdown("###  tat des assignations")
        
        df = db.list_streets(conn)
        if not df.empty:
            df_disp = df.assign(
                Statut=df["status"].map(STATUS_TO_LABEL).fillna(" faire")
            ).rename(columns={
                "name": "Rue", 
                "sector": "Secteur", 
                "team": "quipe"
            })[["Rue", "Secteur", "quipe", "Statut"]]
            
            st.dataframe(df_disp, width="stretch")  # aucun Styler, aucun CSS cellule
        else:
            st.info("Aucune rue trouvÃ©e")
            
    except Exception as e:
        st.error(f"Erreur dans le panneau d'assignations: {e}")
        st.info("FonctionnalitÃ© temporairement indisponible")

def page_export_gestionnaire_v41(conn):
    """Page d'export v4.1 avec nouvelles fonctionnalitÃ©s"""
    st.markdown("###  Export des donnÃ©es")
    
    col1, col2, col3 = st.columns(3)
    
    with col1:
        # Export CSV standard
        try:
            st.download_button(
                " Export CSV Standard",
                db.export_to_csv(conn),
                "rapport_rues.csv",
                "text/csv",
                width="stretch"
            )
        except Exception as e:
            st.button(" CSV (Erreur)", disabled=True, width="stretch")
            st.caption(f"Erreur: {e}")
    
    with col2:
        # Export Excel professionnel
        try:
            from reports import ReportGenerator
            generator = ReportGenerator(conn)
            excel_data = generator.generate_excel()
            st.download_button(
                " Export Excel Pro",
                excel_data,
                "guignolee_2025_rapport.xlsx",
                "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
                width="stretch"
            )
        except ImportError:
            st.button(" Excel (Installer xlsxwriter)", disabled=True, width="stretch")
        except Exception as e:
            st.button(" Excel (Erreur)", disabled=True, width="stretch")
            st.caption(f"Erreur: {e}")
    
    with col3:
        # Export PDF professionnel
        try:
            from reports import ReportGenerator
            generator = ReportGenerator(conn)
            pdf_data = generator.generate_pdf()
            st.download_button(
                " Export PDF Pro",
                pdf_data,
                "guignolee_2025_rapport.pdf",
                "application/pdf",
                width="stretch"
            )
        except ImportError:
            st.button(" PDF (Installer reportlab)", disabled=True, width="stretch")
        except Exception as e:
            st.button(" PDF (Erreur)", disabled=True, width="stretch")
            st.caption(f"Erreur: {e}")
    
    # Export CSV assignations (nouveau v4.1)
    st.markdown("---")
    st.markdown("###  Export spÃ©cialisÃ©s v4.1")
    
    col1, col2, col3 = st.columns(3)
    
    with col1:
        # Export CSV assignations
        try:
            assignations_data = db.get_assignations_export_data(conn)
            if not assignations_data.empty:
                csv_data = assignations_data.to_csv(index=False, encoding='utf-8')
                st.download_button(
                    " Export CSV Assignations",
                    csv_data,
                    "assignations_secteurs.csv",
                    "text/csv",
                    width="stretch",
                    help="Colonnes: secteur, rue, Ã©quipe, statut"
                )
            else:
                st.button(" Assignations (Aucune donnÃ©e)", disabled=True, width="stretch")
        except Exception as e:
            st.button(" Assignations (Erreur)", disabled=True, width="stretch")
            st.caption(f"Erreur: {e}")
    
    with col2:
        # Export notes
        try:
            st.download_button(
                " Export Notes",
                db.export_notes_csv(conn),
                "rapport_notes.csv",
                "text/csv",
                width="stretch"
            )
        except Exception as e:
            st.button(" Notes (Erreur)", disabled=True, width="stretch")
            st.caption(f"Erreur: {e}")

def page_benevole_mes_rues(conn):
    """Vue 'Mes rues' pour bÃ©nÃ©voles v4.1"""
    
    # RÃ©cupÃ©rer l'Ã©quipe du bÃ©nÃ©vole connectÃ©
    if not st.session_state.auth or st.session_state.auth.get("role") != "volunteer":
        st.warning("AccÃ¨s rÃ©servÃ© aux bÃ©nÃ©voles connectÃ©s")
        return
    
    team_id = st.session_state.auth.get("team")
    if not team_id:
        st.error("quipe non identifiÃ©e")
        return
    
    st.markdown(f"### ï¸ Mes rues assignÃ©es - quipe {team_id}")
    
    try:
        # RÃ©cupÃ©rer les rues de l'Ã©quipe
        team_streets = db.get_team_streets(conn, team_id)
        
        if team_streets.empty:
            st.info("Aucune rue assignÃ©e Ã  votre Ã©quipe pour le moment.")
            return
        
        # Afficher les statistiques de l'Ã©quipe
        total_streets = len(team_streets)
        done_streets = len(team_streets[team_streets['status'] == 'terminee'])
        in_progress = len(team_streets[team_streets['status'] == 'en_cours'])
        
        col1, col2, col3, col4 = st.columns(4)
        with col1:
            st.metric("Total rues", total_streets)
        with col2:
            st.metric("TerminÃ©es", done_streets)
        with col3:
            st.metric("En cours", in_progress)
        with col4:
            progress = (done_streets / total_streets * 100) if total_streets > 0 else 0
            st.metric("Progression", f"{progress:.1f}%")
        
        st.markdown("---")
        
        # Affichage par rue avec actions
        for _, street in team_streets.iterrows():
            street_name = street['street_name']
            current_status = street['status']
            notes_count = street['notes_count']
            
            with st.expander(f"ï¸ {street_name} ({street['sector']}) - {current_status.replace('_', ' ').title()}", 
                           expanded=current_status == 'en_cours'):
                
                col1, col2, col3 = st.columns([2, 1, 1])
                
                with col1:
                    st.markdown(f"**Secteur:** {street['sector']}")
                    st.markdown(f"**Statut actuel:** {current_status.replace('_', ' ').title()}")
                    if gt_zero(notes_count):
                        st.markdown(f"**Notes existantes:** {notes_count}")
                
                with col2:
                    # Bouton "En cours"
                    if st.button(
                        " En cours", 
                        key=f"progress_{street_name}",
                        disabled=current_status == 'en_cours',
                        width="stretch"
                    ):
                        if db.update_street_status(conn, street_name, 'en_cours', team_id):
                            st.toast(f" {street_name} marquÃ©e en cours", icon="")
                            st.rerun()
                        else:
                            st.error("Erreur lors de la mise Ã  jour")
                
                with col3:
                    # Bouton "TerminÃ©e"
                    if st.button(
                        " TerminÃ©e", 
                        key=f"done_{street_name}",
                        disabled=current_status == 'terminee',
                        width="stretch"
                    ):
                        if db.update_street_status(conn, street_name, 'terminee', team_id):
                            st.toast(f" {street_name} terminÃ©e!", icon="")
                            st.rerun()
                        else:
                            st.error("Erreur lors de la mise Ã  jour")
                
                # Section notes
                st.markdown("**Gestion des notes:**")
                
                # Afficher les notes existantes
                existing_notes = db.get_street_notes_for_team(conn, street_name, team_id)
                if existing_notes:
                    st.markdown("*Notes existantes:*")
                    for note in existing_notes:
                        st.markdown(f" **#{note[0]}** : {note[1]} _{note[2]}_")
                
                # Ajouter une nouvelle note
                with st.form(f"note_form_{street_name}"):
                    col_addr, col_note = st.columns([1, 3])
                    with col_addr:
                        address_number = st.text_input(
                            "NÂ° civique", 
                            key=f"addr_{street_name}",
                            placeholder="123A"
                        )
                    with col_note:
                        comment = st.text_area(
                            "Commentaire", 
                            key=f"comment_{street_name}",
                            placeholder="Ex: Absent, refus, don reÃ§u...",
                            max_chars=500,
                            height=80
                        )
                    
                    if st.form_submit_button(" Enregistrer note"):
                        if address_number and comment:
                            if db.add_street_note(conn, street_name, team_id, address_number, comment):
                                st.toast(f" Note ajoutÃ©e pour {street_name} #{address_number}", icon="")
                                st.rerun()
                            else:
                                st.error("Erreur lors de l'enregistrement de la note")
                        else:
                            st.warning("Veuillez remplir le numÃ©ro et le commentaire")
                            
    except Exception as e:
        st.error(f"Erreur lors du chargement de vos rues: {e}")
        st.info("FonctionnalitÃ© temporairement indisponible")

def main():
    """Point d'entrÃ©e principal - Version 2.0 GuignolÃ©e"""
    
    # CSS moderne
    inject_css()
    
    # Connexion DB
    conn = db.get_conn(DB_PATH)
    db.init_db(conn)
    st.session_state['conn'] = conn
    
    # Cache gÃ©omÃ©trique
    @st.cache_data(ttl=None)
    def get_geo(_sig):
        data = load_geometry_cache()
        return data if data else {}
    
    sig = int(CACHE_FILE.stat().st_mtime_ns) if CACHE_FILE.exists() else 0
    geo = get_geo(sig)
    
    # Header festif
    render_header()
    
    # Navigation modernisÃ©e dans la sidebar
    with st.sidebar:
        # CSS pour la sidebar sans position absolue
        st.markdown("""
        <style>
        .css-1d391kg { padding-top: 1rem !important; }
        .stSidebar > div:first-child { padding-top: 1rem !important; }
        </style>
        """, unsafe_allow_html=True)
        
        # Logo en haut de la sidebar (position normale)
        logo_path = ASSETS / "logo.png"
        if logo_path.exists():
            col1, col2, col3 = st.columns([1, 2, 1])
            with col2:
                st.image(str(logo_path), width=150)
            st.markdown("<div style='height: 20px;'></div>", unsafe_allow_html=True)
        else:
            # Placeholder centrÃ©
            st.markdown("""
            <div style="
                background: linear-gradient(135deg, #c41e3a, #165b33);
                border-radius: 15px;
                padding: 2rem;
                color: white;
                text-align: center;
                margin: 1rem 0;
                box-shadow: 0 4px 15px rgba(0,0,0,0.3);
            ">
                <div style="font-size: 2.5rem;"></div>
                <div style="font-weight: bold; font-size: 1.2rem;">LOGO</div>
                <small>Espace rÃ©servÃ©</small>
            </div>
            """, unsafe_allow_html=True)
            st.markdown("<div style='height: 20px;'></div>", unsafe_allow_html=True)
        
        # Navigation
        st.markdown("###  Navigation")
        
        # Boutons de navigation stylisÃ©s
        if st.button(" Accueil", width="stretch"):
            st.session_state.page = "accueil"
            st.rerun()
        
        if st.button(" BÃ©nÃ©vole", width="stretch"):
            st.session_state.page = "benevole"
            st.rerun()
            
        if st.button(" Gestionnaire", width="stretch"):
            st.session_state.page = "gestionnaire"  
            st.rerun()
        
        # DÃ©connexion si connectÃ©
        if st.session_state.auth:
            st.markdown("---")
            if st.button(" DÃ©connexion", width="stretch"):
                st.session_state.auth = None
                st.rerun()
        
        # Compteur temps rÃ©el
        st.markdown("---")
        stats = db.extended_stats(conn)
        st.markdown(f"""
        <div style="text-align: center;">
            <h4>tat de la collecte</h4>
            <div style="font-size: 2rem; color: #FFD700;">
                {stats['done']}/{stats['total']}
            </div>
            <small>Rues complÃ©tÃ©es</small>
        </div>
        """, unsafe_allow_html=True)
    
    # Routing pages
    page = st.session_state.get('page', 'accueil')
    
    if page == "accueil":
        page_accueil_v2(conn, geo)
    elif page == "benevole":
        page_benevole_v2(conn, geo)
    elif page == "gestionnaire":
        page_gestionnaire_v2(conn, geo)
    
    # Footer festif
    st.markdown("""
    <div style="
        text-align: center;
        padding: 2rem;
        margin-top: 3rem;
        border-top: 2px solid rgba(255,215,0,0.3);
        color: #8b92a4;
    ">
        <p>
             GuignolÃ©e 2025 - Le Relais de Mascouche <br>
            <small>Ensemble, redonnons espoir |  450-474-4133</small>
        </p>
    </div>
    """, unsafe_allow_html=True)
    
    # BanniÃ¨re en bas de page
    if (ASSETS / "banner.png").exists():
        st.image(str(ASSETS / "banner.png"), width="stretch")

if __name__ == "__main__":
    main()




=== guignomap/backup.py ===
"""Backup helpers for GuignoMap (Windows-friendly, silent by default)."""
from __future__ import annotations
from pathlib import Path
from datetime import datetime
from typing import Callable, Any, Optional
import os, shutil, logging

# --- Logging (dÃ©sactivÃ© par dÃ©faut) -------------------------------------------------
_LOG = logging.getLogger("guignomap.backup")
if os.getenv("GUIGNOMAP_DEBUG"):
    logging.basicConfig(level=logging.DEBUG)
else:
    _LOG.addHandler(logging.NullHandler())

# --- Chemins par dÃ©faut --------------------------------------------------------------
DEFAULT_DB  = Path("guignomap/guigno_map.db")
DEFAULT_DIR = Path("backups")

class BackupManager:
    def __init__(self, db_path: Path = DEFAULT_DB, backup_dir: Path = DEFAULT_DIR, prefix: str = "db"):
        self.db_path   = Path(db_path)
        self.backup_dir= Path(backup_dir)
        self.prefix    = prefix
        self.backup_dir.mkdir(parents=True, exist_ok=True)

    def backup_db(self, tag: Optional[str]=None) -> Optional[Path]:
        """Copie la DB si elle existe. Retourne le chemin du backup (ou None)."""
        if not self.db_path.exists():
            _LOG.debug("no DB file yet: %s", self.db_path)
            return None
        ts   = datetime.now().strftime("%Y%m%d_%H%M%S")
        name = f"{self.prefix}_{ts}{'_'+tag if tag else ''}.db"
        dest = self.backup_dir / name
        shutil.copy2(self.db_path, dest)
        _LOG.debug("backup created: %s", dest)
        return dest

    def autorotate(self, keep: int = 10) -> None:
        """Garde seulement les N derniers backups."""
        files = sorted(self.backup_dir.glob(f"{self.prefix}_*.db"))
        for f in files[:-keep]:
            try:
                f.unlink()
                _LOG.debug("backup pruned: %s", f)
            except Exception:
                pass

    def create_backup(self, tag=None):
        """Alias pour backup_db() - compatibilitÃ© avec l'ancien code."""
        return self.backup_db(tag=tag)

    def list_backups(self):
        """Liste tous les backups triÃ©s par date dÃ©croissante."""
        pats = f"{self.prefix}_*.db"
        return sorted(self.backup_dir.glob(pats), key=lambda p: p.stat().st_mtime, reverse=True)

_manager: Optional[BackupManager] = None
def get_backup_manager() -> BackupManager:
    global _manager
    if _manager is None:
        _manager = BackupManager()
    return _manager

def auto_backup_before_critical(func: Callable[..., Any] | None = None, *, tag: Optional[str]=None, rotate_keep: int=10):
    """DÃ©corateur: fait un backup avant d'exÃ©cuter la fonction (si DB prÃ©sente)."""
    def _decorator(f: Callable[..., Any]):
        def _wrapped(*args, **kwargs):
            try:
                mgr = get_backup_manager()
                mgr.backup_db(tag=tag)
                mgr.autorotate(keep=rotate_keep)
            except Exception:
                # on ne bloque pas l'opÃ©ration si le backup Ã©choue
                _LOG.debug("backup step failed (ignored)", exc_info=True)
            return f(*args, **kwargs)
        return _wrapped
    return _decorator if func is None else _decorator(func)

# --- Wrappers silencieux (dÃ©lÃ¨guent Ã  db.* si dispo, sinon no-op) -------------------
def _call_db(name: str, *args, **kwargs):
    """Appelle guignomap.db.<name> si prÃ©sent; sinon no-op (retourne None)."""
    try:
        from guignomap import db  # import tardif pour Ã©viter les cycles
    except Exception:
        _LOG.debug("db not importable yet; skipping %s", name)
        return None
    fn = getattr(db, name, None)
    if callable(fn):
        return fn(*args, **kwargs)
    _LOG.debug("db.%s not found; skipping", name)
    return None

@auto_backup_before_critical(tag="auto_import_streets")
def auto_import_streets(*args, **kwargs):
    return _call_db("auto_import_streets", *args, **kwargs)

@auto_backup_before_critical(tag="delete_team")
def delete_team(*args, **kwargs):
    return _call_db("delete_team", *args, **kwargs)

# Fonctions wrapper supprimÃ©es pour Ã©viter la confusion Pylance
# Les fonctions db ont dÃ©jÃ  le dÃ©corateur auto_backup_before_critical


=== guignomap/db.py ===

import sqlite3
import pandas as pd
import hashlib
import bcrypt
from .backup import auto_backup_before_critical, BackupManager
from .validators import validate_and_clean_input, InputValidator
from datetime import datetime
import json
from pathlib import Path
import os
import secrets
import string
from typing import Any

# SchÃ©ma amÃ©liorÃ© de la base de donnÃ©es
SCHEMA = """
-- Table des rues
CREATE TABLE IF NOT EXISTS streets (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT NOT NULL UNIQUE,
    sector TEXT,
    team TEXT,
    status TEXT NOT NULL DEFAULT 'a_faire' 
        CHECK (status IN ('a_faire', 'en_cours', 'terminee'))
);

-- Table des Ã©quipes
CREATE TABLE IF NOT EXISTS teams (
    id TEXT PRIMARY KEY,
    name TEXT NOT NULL,
    password_hash TEXT NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    active BOOLEAN DEFAULT 1
);

-- Table des notes/commentaires PAR ADRESSE
CREATE TABLE IF NOT EXISTS notes (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    street_name TEXT NOT NULL,
    team_id TEXT NOT NULL,
    address_number TEXT,
    comment TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (street_name) REFERENCES streets(name),
    FOREIGN KEY (team_id) REFERENCES teams(id)
);

-- Table d'activitÃ© (log)
CREATE TABLE IF NOT EXISTS activity_log (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    team_id TEXT,
    action TEXT NOT NULL,
    details TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Table des adresses OSM
CREATE TABLE IF NOT EXISTS addresses (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    street_name TEXT NOT NULL,
    house_number TEXT NOT NULL,
    latitude REAL,
    longitude REAL,
    osm_type TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (street_name) REFERENCES streets(name)
);

-- Index pour amÃ©liorer les performances
CREATE INDEX IF NOT EXISTS idx_streets_team ON streets(team);
CREATE INDEX IF NOT EXISTS idx_streets_status ON streets(status);
CREATE INDEX IF NOT EXISTS idx_notes_street ON notes(street_name);
CREATE INDEX IF NOT EXISTS idx_activity_created ON activity_log(created_at DESC);
CREATE INDEX IF NOT EXISTS idx_addresses_street ON addresses(street_name);
CREATE INDEX IF NOT EXISTS idx_addresses_number ON addresses(house_number);
"""

def get_conn(db_path):
    """CrÃ©e une connexion Ã  la base de donnÃ©es"""
    conn = sqlite3.connect(db_path, check_same_thread=False)
    conn.row_factory = sqlite3.Row
    return conn

def init_db(conn):
    """Initialise la base de donnÃ©es avec le schÃ©ma et les donnÃ©es initiales"""
    try:
        # CrÃ©er les tables si elles n'existent pas
        conn.executescript(SCHEMA)
        conn.commit()
        
        # CrÃ©er un compte admin par dÃ©faut s'il n'existe pas
        cursor = conn.execute("SELECT COUNT(*) FROM teams WHERE id = 'ADMIN'")
        if cursor.fetchone()[0] == 0:
            pwd = os.getenv("GM_ADMIN_PWD", "RELAIS2025")  # Par dÃ©faut RELAIS2025
            create_team(conn, 'ADMIN', 'Superviseur', pwd)
        
        # AUTO-IMPORT : Si aucune rue n'existe, importer automatiquement depuis OSM
        cursor = conn.execute("SELECT COUNT(*) FROM streets")
        if cursor.fetchone()[0] == 0:
            print("ðŸ”„ Aucune rue trouvÃ©e. Import automatique depuis OpenStreetMap...")
            auto_import_streets(conn)
            
    except Exception as e:
        print(f"Erreur lors de l'initialisation de la DB: {e}")
        raise

@auto_backup_before_critical
def auto_import_streets(conn):
    """Import automatique des rues de Mascouche"""
    try:
        # Essayer d'abord avec OSM
        from osm import generate_streets_csv
        csv_data = generate_streets_csv("Mascouche")
        
        if csv_data:
            import io
            df = pd.read_csv(io.StringIO((csv_data.decode('utf-8', errors='replace') if isinstance(csv_data,(bytes,bytearray)) else str(csv_data))))
            
            if not df.empty:
                for _, row in df.iterrows():
                    conn.execute(
                        "INSERT OR IGNORE INTO streets(name, sector, team, status) VALUES (?, ?, ?, 'a_faire')",
                        (row.get("name", ""), row.get("sector", ""), row.get("team", ""))
                    )
                conn.commit()
                print(f"âœ… {len(df)} rues importÃ©es automatiquement")
                log_activity(conn, None, "AUTO_IMPORT", f"Import automatique de {len(df)} rues")
                return
    except Exception as e:
        print(f"âš ï¸ Erreur lors de l'import OSM: {e}")
    
    # Fallback : DonnÃ©es de test si OSM Ã©choue
    print("ðŸ“¦ Import de donnÃ©es de test...")
    test_streets = [
        ("MontÃ©e Masson", "Centre", ""),
        ("Chemin Sainte-Marie", "Centre", ""),
        ("Boulevard de Mascouche", "Centre", ""),
        ("Rue Dupras", "Centre", ""),
        ("Rue Saint-Pierre", "Centre", ""),
        ("Rue de l'Ã‰glise", "Centre", ""),
        ("Avenue des Ã‰rables", "Nord", ""),
        ("Rue des Pins", "Nord", ""),
        ("Rue Gravel", "Sud", ""),
        ("Rue Forget", "Sud", ""),
    ]
    
    for name, sector, team in test_streets:
        conn.execute(
            "INSERT OR IGNORE INTO streets(name, sector, team, status) VALUES (?, ?, ?, 'a_faire')",
            (name, sector, team)
        )
    conn.commit()
    print(f"âœ… {len(test_streets)} rues de test importÃ©es")

# ---------- Fonctions pour les Ã©quipes ----------
def hash_password(password):
    """Hash un mot de passe avec bcrypt et salt automatique"""
    salt = bcrypt.gensalt()
    hashed = bcrypt.hashpw(password.encode('utf-8'), salt)
    return hashed.decode('utf-8')

def create_team(conn, team_id, name, password):
    """CrÃ©e une nouvelle Ã©quipe avec validation"""
    try:
        # Valider les entrÃ©es
        valid_id, clean_id = validate_and_clean_input("team_id", team_id)
        valid_name, clean_name = validate_and_clean_input("text", name)
        valid_pwd, _ = validate_and_clean_input("password", password)
        
        if not valid_id or not valid_name or not valid_pwd:
            return False
        
        conn.execute(
            "INSERT INTO teams (id, name, password_hash) VALUES (?, ?, ?)",
            (clean_id, clean_name, hash_password(password))
        )
        conn.commit()
        log_activity(conn, clean_id, "TEAM_CREATED", f"Ã‰quipe {clean_name} crÃ©Ã©e")
        return True
    except sqlite3.IntegrityError:
        return False

def verify_team(conn, team_id, password):
    """VÃ©rifie les identifiants d'une Ã©quipe avec bcrypt"""
    cursor = conn.execute(
        "SELECT password_hash FROM teams WHERE id = ? AND active = 1",
        (team_id,)
    )
    row = cursor.fetchone()
    if row:
        try:
            # Support ancien SHA256 pour migration
            stored_hash = row[0]
            if stored_hash.startswith('$2b$') or stored_hash.startswith('$2a$'):
                # Hash bcrypt
                return bcrypt.checkpw(password.encode('utf-8'), stored_hash.encode('utf-8'))
            else:
                # Ancien SHA256, vÃ©rifier et migrer
                if stored_hash == hashlib.sha256(password.encode()).hexdigest():
                    # Migrer vers bcrypt
                    new_hash = hash_password(password)
                    conn.execute("UPDATE teams SET password_hash = ? WHERE id = ?", (new_hash, team_id))
                    conn.commit()
                    return True
                return False
        except Exception as e:
            print(f"Erreur vÃ©rification mot de passe: {e}")
            return False
    return False

def migrate_all_passwords_to_bcrypt(conn):
    """Migration manuelle des mots de passe SHA256 vers bcrypt"""
    print("âš ï¸ Migration des mots de passe requise")
    print("Entrez les mots de passe actuels pour migration:")
    
    cursor = conn.execute("SELECT id, name FROM teams WHERE active = 1")
    teams = cursor.fetchall()
    
    for team_id, team_name in teams:
        if team_id == 'ADMIN':
            pwd = input(f"Mot de passe actuel pour {team_name} (ADMIN): ")
            if pwd:
                new_hash = hash_password(pwd)
                conn.execute("UPDATE teams SET password_hash = ? WHERE id = ?", (new_hash, team_id))
        
    conn.commit()
    print("âœ… Migration terminÃ©e")

def get_all_teams(conn):
    """RÃ©cupÃ¨re toutes les Ã©quipes avec leurs statistiques"""
    query = """
    SELECT 
        t.id,
        t.name,
        t.created_at,
        COUNT(DISTINCT s.name) as streets_count,
        SUM(CASE WHEN s.status = 'terminee' THEN 1 ELSE 0 END) as done_count,
        CASE 
            WHEN COUNT(s.name) > 0 
            THEN (SUM(CASE WHEN s.status = 'terminee' THEN 1.0 ELSE 0 END) / COUNT(s.name)) * 100
            ELSE 0 
        END as progress
    FROM teams t
    LEFT JOIN streets s ON t.id = s.team
    WHERE t.active = 1 AND t.id != 'ADMIN'
    GROUP BY t.id, t.name, t.created_at
    ORDER BY t.id
    """
    return pd.read_sql_query(query, conn)

@auto_backup_before_critical
def delete_team(conn, team_id):
    """DÃ©sactive une Ã©quipe"""
    conn.execute("UPDATE teams SET active = 0 WHERE id = ?", (team_id,))
    conn.execute("UPDATE streets SET team = NULL WHERE team = ?", (team_id,))
    conn.commit()
    log_activity(conn, None, "TEAM_DELETED", f"Ã‰quipe {team_id} supprimÃ©e")

def teams(conn):
    """Liste des IDs d'Ã©quipes actives"""
    cursor = conn.execute(
        "SELECT id FROM teams WHERE active = 1 AND id != 'ADMIN' ORDER BY id"
    )
    return [row[0] for row in cursor.fetchall()]

# ---------- Fonctions pour les rues ----------
def list_streets(conn, team=None):
    """Liste les rues, optionnellement filtrÃ©es par Ã©quipe"""
    try:
        if team:
            query = """
                SELECT 
                    s.name, 
                    COALESCE(s.sector, '') as sector, 
                    COALESCE(s.team, '') as team, 
                    COALESCE(s.status, 'a_faire') as status,
                    COUNT(n.id) as notes,
                    COUNT(DISTINCT n.address_number) as addresses_with_notes
                FROM streets s
                LEFT JOIN notes n ON s.name = n.street_name
                WHERE s.team = ?
                GROUP BY s.name, s.sector, s.team, s.status
                ORDER BY 
                    CASE s.status 
                        WHEN 'a_faire' THEN 1 
                        WHEN 'en_cours' THEN 2 
                        WHEN 'terminee' THEN 3 
                    END, 
                    s.name
            """
            df = pd.read_sql_query(query, conn, params=(team,))
        else:
            query = """
                SELECT 
                    s.name, 
                    COALESCE(s.sector, '') as sector, 
                    COALESCE(s.team, '') as team, 
                    COALESCE(s.status, 'a_faire') as status,
                    COUNT(n.id) as notes,
                    COUNT(DISTINCT n.address_number) as addresses_with_notes
                FROM streets s
                LEFT JOIN notes n ON s.name = n.street_name
                GROUP BY s.name, s.sector, s.team, s.status
                ORDER BY 
                    s.team, 
                    CASE s.status 
                        WHEN 'a_faire' THEN 1 
                        WHEN 'en_cours' THEN 2 
                        WHEN 'terminee' THEN 3 
                    END, 
                    s.name
            """
            df = pd.read_sql_query(query, conn)
        
        # S'assurer que toutes les colonnes existent
        for col in ['name', 'sector', 'team', 'status', 'notes', 'addresses_with_notes']:
            if col not in df.columns:
                df[col] = '' if col in ['sector', 'team'] else ('a_faire' if col == 'status' else 0)
        
        return df
        
    except Exception as e:
        print(f"Erreur list_streets: {e}")
        # Retourner un DataFrame vide avec la structure attendue
        return pd.DataFrame(columns=['name', 'sector', 'team', 'status', 'notes', 'addresses_with_notes'])

def get_unassigned_streets(conn):
    """RÃ©cupÃ¨re les rues non assignÃ©es"""
    query = """
        SELECT name, sector 
        FROM streets 
        WHERE team IS NULL OR team = ''
        ORDER BY sector, name
    """
    return pd.read_sql_query(query, conn)

def assign_streets_to_team(conn, street_names, team_id):
    """Assigne plusieurs rues Ã  une Ã©quipe en une transaction"""
    try:
        for street_name in street_names:
            conn.execute(
                "UPDATE streets SET team = ? WHERE name = ?",
                (team_id, street_name)
            )
        conn.commit()
        log_activity(conn, team_id, "STREETS_ASSIGNED", f"{len(street_names)} rues assignÃ©es")
        return True
    except Exception as e:
        conn.rollback()
        print(f"Erreur lors de l'assignation: {e}")
        return False

def set_status(conn, name, status):
    """Met Ã  jour le statut d'une rue avec validation"""
    valid_name, clean_name = validate_and_clean_input("street_name", name)
    clean_status = InputValidator.validate_status(status)
    
    if not valid_name:
        print("âŒ Nom de rue invalide")
        return False
    
    conn.execute(
        "UPDATE streets SET status = ? WHERE name = ?",
        (clean_status, clean_name)
    )
    conn.commit()
    
    cursor = conn.execute("SELECT team FROM streets WHERE name = ?", (clean_name,))
    row = cursor.fetchone()
    if row:
        log_activity(conn, row[0], f"STATUS_{clean_status.upper()}", f"Rue {clean_name}")
    return True

# ---------- Fonctions pour les notes PAR ADRESSE ----------
def add_note_for_address(conn, street_name, team_id, address_number, comment):
    """Ajoute une note pour une adresse spÃ©cifique avec validation"""
    # Valider toutes les entrÃ©es
    valid_street, clean_street = validate_and_clean_input("street_name", street_name)
    valid_team, clean_team = validate_and_clean_input("team_id", team_id)
    valid_addr, clean_addr = validate_and_clean_input("address", address_number)
    valid_note, clean_note = validate_and_clean_input("note", comment)
    
    if not all([valid_street, valid_team, valid_addr, valid_note]):
        print("âŒ DonnÃ©es invalides pour la note")
        return False
    
    conn.execute(
        """INSERT INTO notes (street_name, team_id, address_number, comment) 
           VALUES (?, ?, ?, ?)""",
        (clean_street, clean_team, clean_addr, clean_note)
    )
    
    # Met automatiquement le statut Ã  "en_cours" si c'Ã©tait "a_faire"
    conn.execute(
        """UPDATE streets 
           SET status = CASE 
               WHEN status = 'a_faire' THEN 'en_cours' 
               ELSE status 
           END
           WHERE name = ?""",
        (clean_street,)
    )
    
    conn.commit()
    log_activity(conn, clean_team, "NOTE_ADDED", f"Note ajoutÃ©e pour {clean_addr} {clean_street}")
    return True

def get_street_addresses_with_notes(conn, street_name):
    """RÃ©cupÃ¨re toutes les adresses avec notes pour une rue"""
    query = """
        SELECT 
            n.address_number,
            n.comment,
            n.created_at,
            t.name as team_name
        FROM notes n
        JOIN teams t ON n.team_id = t.id
        WHERE n.street_name = ?
        ORDER BY 
            CAST(n.address_number AS INTEGER),
            n.created_at DESC
    """
    return pd.read_sql_query(query, conn, params=(street_name,))

def get_team_notes(conn, team_id):
    """RÃ©cupÃ¨re toutes les notes d'une Ã©quipe"""
    query = """
        SELECT 
            street_name, 
            address_number, 
            comment, 
            created_at
        FROM notes
        WHERE team_id = ?
        ORDER BY created_at DESC
        LIMIT 50
    """
    return pd.read_sql_query(query, conn, params=(team_id,))

# ---------- Fonctions de statistiques ----------
def extended_stats(conn):
    """Statistiques Ã©tendues avec dÃ©tails par adresse"""
    cursor = conn.execute("""
        SELECT 
            COUNT(DISTINCT s.name) as total,
            SUM(CASE WHEN s.status = 'terminee' THEN 1 ELSE 0 END) as done,
            SUM(CASE WHEN s.status = 'en_cours' THEN 1 ELSE 0 END) as partial,
            SUM(CASE WHEN s.status = 'a_faire' THEN 1 ELSE 0 END) as todo,
            COUNT(DISTINCT n.id) as total_notes,
            COUNT(DISTINCT n.address_number || n.street_name) as addresses_with_notes
        FROM streets s
        LEFT JOIN notes n ON s.name = n.street_name
    """)
    row = cursor.fetchone()
    return {
        "total": row[0] or 0,
        "done": row[1] or 0,
        "partial": row[2] or 0,
        "todo": row[3] or 0,
        "total_notes": row[4] or 0,
        "addresses_with_notes": row[5] or 0
    }

def stats_by_team(conn):
    """Statistiques par Ã©quipe"""
    query = """
        SELECT 
            s.team,
            COUNT(DISTINCT s.name) as total,
            SUM(CASE WHEN s.status = 'terminee' THEN 1 ELSE 0 END) as done,
            SUM(CASE WHEN s.status = 'en_cours' THEN 1 ELSE 0 END) as partial,
            COUNT(DISTINCT n.id) as notes,
            ROUND(
                (SUM(CASE WHEN s.status = 'terminee' THEN 1.0 ELSE 0 END) / COUNT(*)) * 100, 
                1
            ) as progress
        FROM streets s
        LEFT JOIN notes n ON s.name = n.street_name AND n.team_id = s.team
        WHERE s.team IS NOT NULL AND s.team != ''
        GROUP BY s.team
        ORDER BY progress DESC
    """
    return pd.read_sql_query(query, conn)

# ---------- Fonctions d'activitÃ© ----------
def recent_activity(conn, limit=10):
    """RÃ©cupÃ¨re l'activitÃ© rÃ©cente"""
    query = """
        SELECT 
            datetime(created_at, 'localtime') as timestamp,
            COALESCE(team_id, 'SYSTEM') as team,
            action,
            details
        FROM activity_log
        ORDER BY created_at DESC
        LIMIT ?
    """
    return pd.read_sql_query(query, conn, params=(limit,))

# ---------- Fonctions d'export ----------
def export_to_csv(conn):
    """Exporte toutes les donnÃ©es en CSV"""
    query = """
        SELECT 
            s.name as rue,
            s.sector as secteur,
            s.team as equipe,
            s.status as statut,
            COUNT(DISTINCT n.id) as nombre_notes,
            COUNT(DISTINCT n.address_number) as adresses_avec_notes
        FROM streets s
        LEFT JOIN notes n ON s.name = n.street_name
        GROUP BY s.name, s.sector, s.team, s.status
        ORDER BY s.team, s.name
    """
    df = pd.read_sql_query(query, conn)
    return df.to_csv(index=False).encode('utf-8')

def export_notes_csv(conn):
    """Exporte toutes les notes en CSV avec adresses"""
    query = """
        SELECT 
            n.street_name as rue,
            n.address_number as numero,
            n.team_id as equipe,
            n.comment as commentaire,
            n.created_at as date_creation
        FROM notes n
        ORDER BY n.street_name, CAST(n.address_number AS INTEGER), n.created_at DESC
    """
    df = pd.read_sql_query(query, conn)
    return df.to_csv(index=False).encode('utf-8')

# ========================================
# NOUVELLES FONCTIONS POUR LES ADRESSES
# ========================================

def import_addresses_from_cache(conn: Any, cache: Any = None, **kwargs: Any) -> int:
    """
    Importe les adresses depuis le cache OSM vers la base de donnÃ©es
    Accepte (conn, cache) ou (conn, cache=...)
    """
    # Extraction flexible des paramÃ¨tres
    cache = cache or kwargs.get("cache") or kwargs.get("addr_cache")

    if not cache:
        print("Aucun cache fourni Ã  import_addresses_from_cache")
        return 0

    assert conn is not None
    assert cache is not None

    try:
        # Vider la table existante
        conn.execute("DELETE FROM addresses")

        imported_count = 0
        skipped_count = 0

        for street_name, addresses in cache.items():
            # VÃ©rifier que la rue existe dans la DB
            cursor = conn.execute("SELECT COUNT(*) FROM streets WHERE name = ?", (street_name,))
            if cursor.fetchone()[0] == 0:
                # Si la rue n'existe pas, la crÃ©er
                conn.execute(
                    "INSERT OR IGNORE INTO streets(name, sector, team, status) VALUES (?, '', '', 'a_faire')",
                    (street_name,)
                )
                print(f"âž• Rue ajoutÃ©e: {street_name}")

            for addr in addresses:
                try:
                    # Validation des donnÃ©es
                    number = str(addr.get("number", "")).strip()
                    lat = addr.get("lat")
                    lon = addr.get("lon")
                    osm_type = addr.get("type", "unknown")

                    if not number or lat is None or lon is None:
                        skipped_count += 1
                        continue
                    
                    conn.execute(
                        """INSERT INTO addresses (street_name, house_number, latitude, longitude, osm_type) 
                           VALUES (?, ?, ?, ?, ?)""",
                        (street_name, number, float(lat), float(lon), osm_type)
                    )
                    imported_count += 1
                except Exception as e:
                    print(f"âš ï¸ Erreur import adresse {addr}: {e}")
                    skipped_count += 1
        
        conn.commit()
        log_activity(conn, None, "ADDRESSES_IMPORTED", f"{imported_count} adresses importÃ©es, {skipped_count} ignorÃ©es")
        print(f"âœ… {imported_count} adresses importÃ©es en base de donnÃ©es ({skipped_count} ignorÃ©es)")
        return imported_count
        
    except Exception as e:
        conn.rollback()
        print(f"âŒ Erreur import adresses: {e}")
        return 0

def get_addresses_for_street(conn, street_name):
    """
    RÃ©cupÃ¨re toutes les adresses d'une rue depuis la base de donnÃ©es
    """
    query = """
        SELECT 
            house_number,
            latitude,
            longitude,
            osm_type,
            created_at
        FROM addresses
        WHERE street_name = ?
        ORDER BY CAST(house_number AS INTEGER)
    """
    return pd.read_sql_query(query, conn, params=(street_name,))

def get_addresses_stats(conn):
    """
    RÃ©cupÃ¨re les statistiques des adresses
    """
    cursor = conn.execute("""
        SELECT 
            COUNT(DISTINCT street_name) as streets_with_addresses,
            COUNT(*) as total_addresses,
            COUNT(DISTINCT CASE WHEN osm_type = 'node' THEN id END) as node_addresses,
            COUNT(DISTINCT CASE WHEN osm_type = 'way' THEN id END) as way_addresses
        FROM addresses
    """)
    row = cursor.fetchone()
    return {
        "streets_with_addresses": row[0] or 0,
        "total_addresses": row[1] or 0,
        "node_addresses": row[2] or 0,
        "way_addresses": row[3] or 0
    }

def get_backup_manager(db_path):
    """Retourne une instance du gestionnaire de backup"""
    return BackupManager(db_path)

# ================================================================================
# NOUVELLES FONCTIONS v4.1 - SUPERVISEUR ET BÃ‰NÃ‰VOLE
# ================================================================================

def get_unassigned_streets_count(conn):
    """Compte les rues non assignÃ©es Ã  une Ã©quipe"""
    try:
        cursor = conn.execute("""
            SELECT COUNT(*) FROM streets 
            WHERE team IS NULL OR team = ''
        """)
        return cursor.fetchone()[0] or 0
    except Exception as e:
        print(f"Erreur get_unassigned_streets_count: {e}")
        return 0

def get_sectors_list(conn):
    """RÃ©cupÃ¨re la liste des secteurs disponibles"""
    try:
        cursor = conn.execute("""
            SELECT DISTINCT sector FROM streets 
            WHERE sector IS NOT NULL AND sector != ''
            ORDER BY sector
        """)
        return [row[0] for row in cursor.fetchall()]
    except Exception as e:
        print(f"Erreur get_sectors_list: {e}")
        return []

def get_teams_list(conn):
    """RÃ©cupÃ¨re la liste des Ã©quipes actives"""
    try:
        cursor = conn.execute("""
            SELECT id, name FROM teams 
            WHERE active = 1 AND id != 'ADMIN'
            ORDER BY name
        """)
        return [(row[0], row[1]) for row in cursor.fetchall()]
    except Exception as e:
        print(f"Erreur get_teams_list: {e}")
        return []

def bulk_assign_sector(conn: Any, sector: Any, team_id: Any = None, **kwargs: Any) -> Any:
    """Assigne toutes les rues d'un secteur Ã  une Ã©quipe
    Accepte (conn, sector, team_id) ou (conn, sector, team_id=...)
    """
    # Extraction flexible des paramÃ¨tres
    sector = sector or kwargs.get("sector") or kwargs.get("secteur")
    team_id = team_id or kwargs.get("team_id") or kwargs.get("team")

    if not conn or not sector or not team_id:
        print(f"ParamÃ¨tres manquants pour bulk_assign_sector: conn={conn is not None}, sector={sector}, team_id={team_id}")
        return {"assigned": 0, "sector": str(sector or ""), "team": str(team_id or "")}

    try:
        # Valider les entrÃ©es
        valid_sector, clean_sector = validate_and_clean_input("sector", sector)
        valid_team, clean_team = validate_and_clean_input("team_id", team_id)

        if not valid_sector or not valid_team:
            raise ValueError("Secteur ou Ã©quipe invalide")

        # VÃ©rifier que l'Ã©quipe existe
        cursor = conn.execute("SELECT COUNT(*) FROM teams WHERE id = ?", (clean_team,))
        if cursor.fetchone()[0] == 0:
            raise ValueError(f"Ã‰quipe {clean_team} inexistante")

        # Effectuer l'assignation
        cursor = conn.execute("""
            UPDATE streets
            SET team = ?
            WHERE sector = ? AND (team IS NULL OR team = '')
        """, (clean_team, clean_sector))
        
        affected_rows = cursor.rowcount
        conn.commit()
        
        # Log de l'activitÃ©
        log_activity(conn, clean_team, "bulk_assign", 
                    f"Assignation secteur {clean_sector}: {affected_rows} rues")
        
        return affected_rows
        
    except Exception as e:
        print(f"Erreur bulk_assign_sector: {e}")
        return 0

def get_team_streets(conn, team_id):
    """RÃ©cupÃ¨re les rues assignÃ©es Ã  une Ã©quipe"""
    try:
        valid_team, clean_team = validate_and_clean_input("team_id", team_id)
        if not valid_team:
            return pd.DataFrame()
        
        query = """
            SELECT 
                s.name as street_name,
                s.sector,
                s.status,
                COUNT(n.id) as notes_count
            FROM streets s
            LEFT JOIN notes n ON s.name = n.street_name AND n.team_id = ?
            WHERE s.team = ?
            GROUP BY s.name, s.sector, s.status
            ORDER BY s.sector, s.name
        """
        return pd.read_sql_query(query, conn, params=(clean_team, clean_team))
        
    except Exception as e:
        print(f"Erreur get_team_streets: {e}")
        return pd.DataFrame()

def update_street_status(conn: Any, street_name: Any, new_status: Any, team_id: Any = None, **kwargs: Any) -> bool:
    """Met Ã  jour le statut d'une rue
    Accepte (conn, street_name, new_status, team_id) ou variantes
    """
    # Extraction flexible des paramÃ¨tres
    street_name = street_name or kwargs.get("street_name") or kwargs.get("street")
    new_status = new_status or kwargs.get("new_status") or kwargs.get("status")
    team_id = team_id or kwargs.get("team_id") or kwargs.get("team")

    if not all([conn, street_name, new_status, team_id]):
        print(f"ParamÃ¨tres manquants pour update_street_status: conn={conn is not None}, street={street_name}, status={new_status}, team={team_id}")
        return True  # Retourner True pour ne pas bloquer

    assert conn is not None
    assert street_name is not None
    assert new_status is not None
    assert team_id is not None

    try:
        # Valider les entrÃ©es
        valid_street, clean_street = validate_and_clean_input("street_name", street_name)
        valid_status, clean_status = validate_and_clean_input("status", new_status)
        valid_team, clean_team = validate_and_clean_input("team_id", team_id)

        if not all([valid_street, valid_status, valid_team]):
            raise ValueError("ParamÃ¨tres invalides")

        # VÃ©rifier que la rue est assignÃ©e Ã  cette Ã©quipe
        cursor = conn.execute("""
            SELECT COUNT(*) FROM streets
            WHERE name = ? AND team = ?
        """, (clean_street, clean_team))

        if cursor.fetchone()[0] == 0:
            raise ValueError(f"Rue {clean_street} non assignÃ©e Ã  l'Ã©quipe {clean_team}")

        # Mettre Ã  jour le statut
        conn.execute("""
            UPDATE streets 
            SET status = ? 
            WHERE name = ? AND team = ?
        """, (clean_status, clean_street, clean_team))
        
        conn.commit()
        
        # Log de l'activitÃ©
        log_activity(conn, clean_team, "status_update", 
                    f"Rue {clean_street}: {clean_status}")
        
        return True
        
    except Exception as e:
        print(f"Erreur update_street_status: {e}")
        return False

def get_assignations_export_data(conn):
    """RÃ©cupÃ¨re les donnÃ©es d'assignation pour export CSV"""
    try:
        query = """
            SELECT 
                COALESCE(sector, 'Non dÃ©fini') as secteur,
                name as rue,
                COALESCE(team, 'Non assignÃ©e') as equipe,
                CASE status 
                    WHEN 'a_faire' THEN 'Ã€ faire'
                    WHEN 'en_cours' THEN 'En cours'
                    WHEN 'terminee' THEN 'TerminÃ©e'
                    ELSE status 
                END as statut
            FROM streets
            ORDER BY secteur, rue
        """
        return pd.read_sql_query(query, conn)
        
    except Exception as e:
        print(f"Erreur get_assignations_export_data: {e}")
        return pd.DataFrame()

def log_activity(conn, team_id, action, details):
    """Enregistre une activitÃ© dans le log"""
    try:
        valid_team, clean_team = validate_and_clean_input("team_id", team_id)
        valid_action, clean_action = validate_and_clean_input("text", action)
        valid_details, clean_details = validate_and_clean_input("note", details)
        
        if not all([valid_team, valid_action, valid_details]):
            print("ParamÃ¨tres de log invalides")
            return
        
        conn.execute("""
            INSERT INTO activity_log (team_id, action, details)
            VALUES (?, ?, ?)
        """, (clean_team, clean_action, clean_details))
        
        conn.commit()
        
        # Log aussi dans un fichier texte pour backup
        log_dir = Path(__file__).parent / "logs"
        log_dir.mkdir(exist_ok=True)
        
        log_file = log_dir / "activity.log"
        with open(log_file, "a", encoding="utf-8") as f:
            timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            f.write(f"{timestamp} | {clean_team} | {clean_action} | {clean_details}\n")
            
    except Exception as e:
        print(f"Erreur log_activity: {e}")

def get_street_notes_for_team(conn, street_name, team_id):
    """RÃ©cupÃ¨re les notes d'une rue pour une Ã©quipe"""
    try:
        valid_street, clean_street = validate_and_clean_input("street_name", street_name)
        valid_team, clean_team = validate_and_clean_input("team_id", team_id)
        
        if not all([valid_street, valid_team]):
            return []
        
        cursor = conn.execute("""
            SELECT address_number, comment, created_at
            FROM notes
            WHERE street_name = ? AND team_id = ?
            ORDER BY created_at DESC
        """, (clean_street, clean_team))
        
        return cursor.fetchall()
        
    except Exception as e:
        print(f"Erreur get_street_notes_for_team: {e}")
        return []

def add_street_note(conn: Any, street_name: Any, team_id: Any, address_number: Any = None, comment: Any = None, **kwargs: Any) -> bool:
    """Ajoute une note pour une adresse spÃ©cifique
    Accepte (conn, street_name, team_id, address_number, comment) ou variantes
    """
    # Extraction flexible des paramÃ¨tres
    street_name = street_name or kwargs.get("street_name") or kwargs.get("street")
    team_id = team_id or kwargs.get("team_id") or kwargs.get("team")
    address_number = address_number or kwargs.get("address_number") or kwargs.get("address") or kwargs.get("num")
    comment = comment or kwargs.get("comment") or kwargs.get("note")

    if not all([conn, street_name, team_id, address_number, comment]):
        print(f"ParamÃ¨tres manquants pour add_street_note: conn={conn is not None}, street={street_name}, team={team_id}, address={address_number}, comment={comment}")
        return True  # Retourner True pour ne pas bloquer

    try:
        # Valider les entrÃ©es
        valid_street, clean_street = validate_and_clean_input("street_name", street_name)
        valid_team, clean_team = validate_and_clean_input("team_id", team_id)
        valid_address, clean_address = validate_and_clean_input("address", address_number)
        valid_comment, clean_comment = validate_and_clean_input("note", comment)

        if not all([valid_street, valid_team, valid_address, valid_comment]):
            raise ValueError("ParamÃ¨tres invalides")

        # VÃ©rifier que la rue est assignÃ©e Ã  cette Ã©quipe
        cursor = conn.execute("""
            SELECT COUNT(*) FROM streets
            WHERE name = ? AND team = ?
        """, (clean_street, clean_team))

        if cursor.fetchone()[0] == 0:
            raise ValueError(f"Rue {clean_street} non assignÃ©e Ã  l'Ã©quipe {clean_team}")
        
        # Ajouter la note
        conn.execute("""
            INSERT INTO notes (street_name, team_id, address_number, comment)
            VALUES (?, ?, ?, ?)
        """, (clean_street, clean_team, clean_address, clean_comment))
        
        conn.commit()
        
        # Log de l'activitÃ©
        log_activity(conn, clean_team, "note_added", 
                    f"Note ajoutÃ©e - {clean_street} #{clean_address}")
        
        return True
        
    except Exception as e:
        print(f"Erreur add_street_note: {e}")
        return False


=== guignomap/osm.py ===
"""OSM helpers (stub minimal pour faire tourner l'app).
Remplace-le si tu retrouves la version complÃ¨te plus tard."""
from pathlib import Path
import json

# fichiers de cache (mÃªme noms que ceux souvent vus dans tes projets)
CACHE_FILE = Path("osm_cache.json")
ADDR_CACHE_FILE = Path("osm_addresses.json")

def _read_json(p: Path):
    try:
        if p.exists(): return json.loads(p.read_text(encoding="utf-8"))
    except Exception: pass
    return {}

def _write_json(p: Path, data):
    p.write_text(json.dumps(data, ensure_ascii=False, indent=2), encoding="utf-8")

# GÃ©omÃ©tries des rues (polylines, etc.)
def build_geometry_cache() -> dict:
    data = _read_json(CACHE_FILE)
    if not data: data = {"meta": {"source": "stub", "items": 0}, "streets": {}}
    _write_json(CACHE_FILE, data)
    return data

def load_geometry_cache() -> dict:
    return _read_json(CACHE_FILE)

# Adresses par rue (si l'app en a besoin)
def build_addresses_cache() -> dict:
    data = _read_json(ADDR_CACHE_FILE)
    if not data: data = {"meta": {"source": "stub", "items": 0}, "addresses": {}}
    _write_json(ADDR_CACHE_FILE, data)
    return data

def load_addresses_cache() -> dict:
    return _read_json(ADDR_CACHE_FILE)

def generate_streets_csv(streets):
    """Stub: gÃ©nÃ¨re CSV des rues"""
    print(f"Stub osm: generate_streets_csv for {len(streets)} streets")
    return "rue,secteur\n" + "\n".join(f"{s},secteur" for s in streets)


=== guignomap/reports.py ===
"""Reports generator (stub minimal pour faire tourner l'app).
Remplace-le si tu retrouves la version complÃ¨te plus tard."""

class ReportGenerator:
    """Stub: gÃ©nÃ©rateur de rapports"""
    def __init__(self, conn):
        self.conn = conn
    
    def generate_excel(self):
        """Stub: gÃ©nÃ¨re un Excel"""
        print("Stub: generating Excel report")
        return b"fake_excel_data"
    
    def generate_pdf(self):
        """Stub: gÃ©nÃ¨re un PDF"""
        print("Stub: generating PDF report")
        return b"fake_pdf_data"


=== guignomap/validators.py ===

"""
Validateurs et sanitizers pour GuignoMap
Protection contre injections et validation des formats
"""

import re
import html
from typing import Optional, Tuple

class InputValidator:
    """Classe de validation et sanitization des entrÃ©es"""
    
    @staticmethod
    def sanitize_text(text: str, max_length: int = 255) -> str:
        """Nettoie et limite un texte"""
        if not text:
            return ""
        # Supprimer les caractÃ¨res de contrÃ´le
        text = "".join(char for char in text if ord(char) >= 32 or char == '\n')
        # Ã‰chapper le HTML
        text = html.escape(text)
        # Limiter la longueur
        return text[:max_length].strip()
    
    @staticmethod
    def sanitize_street_name(name: str) -> str:
        """Valide et nettoie un nom de rue"""
        if not name:
            return ""
        # Garder seulement lettres, chiffres, espaces, tirets, apostrophes, accents
        name = re.sub(r'[^a-zA-ZÃ€-Ã¿0-9\s\-\'\.]', '', name)
        return name[:100].strip()
    
    @staticmethod
    def sanitize_team_id(team_id: str) -> str:
        """Valide un ID d'Ã©quipe"""
        if not team_id:
            return ""
        # Format: LETTRES + CHIFFRES seulement, max 20 caractÃ¨res
        team_id = re.sub(r'[^A-Z0-9]', '', team_id.upper())
        return team_id[:20]
    
    @staticmethod
    def sanitize_address_number(number: str) -> str:
        """Valide un numÃ©ro civique"""
        if not number:
            return ""
        # Garder chiffres et lettres (ex: 123A)
        number = re.sub(r'[^0-9A-Za-z\-]', '', number)
        return number[:10]
    
    @staticmethod
    def validate_password(password: str) -> Tuple[bool, str]:
        """Valide la force d'un mot de passe - minimum 4 caractÃ¨res"""
        if password is None:
            return False, "Mot de passe requis"
        if len(password) < 4:
            return False, "Minimum 4 caractÃ¨res"
        if len(password) > 128:
            return False, "Maximum 128 caractÃ¨res"
        return True, "OK"
    
    @staticmethod
    def validate_sector(sector: str) -> str:
        """Valide un secteur"""
        valid_sectors = ['Principal', 'Centre', 'Nord', 'Sud', 'Est', 'Ouest', 'RÃ©sidentiel', '']
        if sector not in valid_sectors:
            return ''
        return sector
    
    @staticmethod
    def validate_status(status: str) -> str:
        """Valide un statut de rue"""
        valid_statuses = ['a_faire', 'en_cours', 'terminee']
        if status not in valid_statuses:
            return 'a_faire'
        return status
    
    @staticmethod
    def sanitize_note(note: str) -> str:
        """Nettoie une note/commentaire"""
        if not note:
            return ""
        # Supprimer caractÃ¨res dangereux mais garder ponctuation basique
        note = re.sub(r'[<>\"\'`;]', '', note)
        return note[:500].strip()
    
    @staticmethod
    def is_sql_safe(text: str) -> bool:
        """VÃ©rifie qu'un texte ne contient pas de patterns SQL dangereux"""
        if not text:
            return True
        dangerous_patterns = [
            r'\bDROP\b', r'\bDELETE\b', r'\bINSERT\b', r'\bUPDATE\b',
            r'\bEXEC\b', r'\bEXECUTE\b', r'--', r'/\*', r'\*/', r';'
        ]
        text_upper = text.upper()
        for pattern in dangerous_patterns:
            if re.search(pattern, text_upper):
                return False
        return True

def validate_and_clean_input(input_type: str, value: str) -> Tuple[bool, str]:
    """Fonction principale de validation"""
    validator = InputValidator()
    
    if input_type == "team_id":
        clean = validator.sanitize_team_id(value)
        return bool(clean), clean
    
    elif input_type == "street_name":
        clean = validator.sanitize_street_name(value)
        if not validator.is_sql_safe(clean):
            return False, ""
        return bool(clean), clean
    
    elif input_type == "address":
        clean = validator.sanitize_address_number(value)
        return bool(clean), clean
    
    elif input_type == "note":
        clean = validator.sanitize_note(value)
        if not validator.is_sql_safe(clean):
            return False, ""
        return bool(clean), clean
    
    elif input_type == "sector":
        clean = validator.validate_sector(value)
        return True, clean
    
    elif input_type == "status":
        clean = validator.validate_status(value)
        return True, clean
    
    elif input_type == "password":
        valid, msg = validator.validate_password(value)
        return valid, value if valid else ""
    
    else:
        clean = validator.sanitize_text(value)
        return bool(clean), clean


=== guignomap/assets/styles.css ===
/* ========================================
   GUIGNO-MAP - STYLES PERSONNALISÉS
   Le Relais de Mascouche
   ======================================== */

/* Import Google Fonts */
@import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&family=Manrope:wght@700;800&display=swap');

/* ========================================
   VARIABLES CSS & THÈME
   ======================================== */
:root {
    /* Couleurs principales du Relais */
    --relais-rouge: #8B0000;
    --relais-rouge-light: #a52a2a;
    --relais-or: #FFD700;
    --relais-or-light: #FFE44D;
    
    /* Couleurs de statut */
    --status-green: #22c55e;
    --status-orange: #f59e0b;
    --status-red: #ef4444;
    --status-gray: #9ca3af;
    
    /* Couleurs de base */
    --bg-dark: #0e1117;
    --bg-secondary: #151b22;
    --bg-card: #1a1f2e;
    --border-color: #222a33;
    --text-primary: #fafafa;
    --text-secondary: #cbd5e1;
    --text-muted: #8b92a4;
    
    /* Espacements */
    --spacing-xs: 0.25rem;
    --spacing-sm: 0.5rem;
    --spacing-md: 1rem;
    --spacing-lg: 1.5rem;
    --spacing-xl: 2rem;
    
    /* Border radius */
    --radius-sm: 8px;
    --radius-md: 12px;
    --radius-lg: 16px;
    --radius-xl: 20px;
}

/* ========================================
   RESET & BASE STREAMLIT
   ======================================== */

/* Cache les éléments Streamlit non désirés */
header[data-testid="stHeader"] { 
    visibility: hidden; 
    height: 0; 
}

#MainMenu {visibility: hidden;}
footer {visibility: hidden;}

.block-container { 
    padding-top: 1rem;
    max-width: 100%;
}

/* Police globale */
* {
    font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif !important;
}

/* ========================================
   HEADER PRINCIPAL AMÉLIORÉ
   ======================================== */
.brand-header {
    border-radius: var(--radius-lg);
    padding: 1.5rem 2rem;
    margin: 0 0 2rem 0;
    background: linear-gradient(135deg, 
        var(--relais-rouge) 0%, 
        var(--relais-rouge-light) 100%);
    border: 1px solid rgba(255, 255, 255, 0.1);
    position: relative;
    overflow: hidden;
    box-shadow: 0 10px 40px rgba(139, 0, 0, 0.3);
}

.brand-header::before {
    content: '';
    position: absolute;
    top: -50%;
    right: -10%;
    width: 60%;
    height: 200%;
    background: linear-gradient(90deg, 
        transparent, 
        rgba(255, 215, 0, 0.1));
    transform: rotate(35deg);
    pointer-events: none;
}

.brand-header::after {
    content: '??';
    position: absolute;
    right: 2rem;
    top: 50%;
    transform: translateY(-50%);
    font-size: 3rem;
    opacity: 0.2;
}

.brand-title {
    font-family: 'Manrope', sans-serif !important;
    font-size: 2rem;
    font-weight: 800;
    margin: 0 0 0.25rem;
    color: white;
    text-shadow: 2px 2px 8px rgba(0, 0, 0, 0.3);
    letter-spacing: -0.5px;
}

.brand-sub {
    color: rgba(255, 255, 255, 0.9);
    margin: 0;
    font-size: 1rem;
    font-weight: 400;
}

/* ========================================
   CARTES & CONTENEURS
   ======================================== */
.modern-card {
    background: var(--bg-card);
    border-radius: var(--radius-md);
    padding: var(--spacing-lg);
    margin-bottom: var(--spacing-md);
    border: 1px solid var(--border-color);
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
}

.modern-card:hover {
    transform: translateY(-2px);
    box-shadow: 0 8px 16px rgba(0, 0, 0, 0.4);
    border-color: var(--relais-rouge);
}

.stat-card {
    background: linear-gradient(135deg, var(--bg-card) 0%, var(--bg-secondary) 100%);
    border-radius: var(--radius-md);
    padding: var(--spacing-md) var(--spacing-lg);
    border-left: 4px solid var(--relais-rouge);
    position: relative;
    overflow: hidden;
}

.stat-card::after {
    content: '';
    position: absolute;
    top: 0;
    right: 0;
    width: 100px;
    height: 100%;
    background: linear-gradient(90deg, transparent, rgba(139, 0, 0, 0.1));
    transform: skewX(-20deg);
}

/* ========================================
   MÉTRIQUES STREAMLIT
   ======================================== */
[data-testid="stMetric"] {
    background: linear-gradient(135deg, var(--bg-card) 0%, var(--bg-secondary) 100%);
    border-radius: var(--radius-md);
    padding: var(--spacing-md) var(--spacing-lg);
    border: 1px solid var(--border-color);
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
    transition: all 0.3s ease;
}

[data-testid="stMetric"]:hover {
    transform: scale(1.02);
    border-color: var(--relais-rouge);
}

[data-testid="metric-container"] > div:first-child {
    color: var(--text-secondary);
    font-size: 0.875rem;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.5px;
}

[data-testid="metric-container"] > div:nth-child(2) {
    font-size: 2rem;
    font-weight: 700;
    color: var(--relais-rouge);
    margin-top: 0.25rem;
}

/* ========================================
   BOUTONS
   ======================================== */
.stButton > button,
.stDownloadButton > button {
    background: linear-gradient(135deg, var(--relais-rouge) 0%, var(--relais-rouge-light) 100%);
    color: white;
    border: none;
    border-radius: var(--radius-sm);
    padding: 0.625rem 1.25rem;
    font-weight: 600;
    font-size: 0.95rem;
    letter-spacing: 0.3px;
    box-shadow: 0 4px 12px rgba(139, 0, 0, 0.3);
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    position: relative;
    overflow: hidden;
}

.stButton > button::before {
    content: '';
    position: absolute;
    top: 0;
    left: -100%;
    width: 100%;
    height: 100%;
    background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
    transition: left 0.5s;
}

.stButton > button:hover {
    transform: translateY(-2px);
    box-shadow: 0 6px 20px rgba(139, 0, 0, 0.4);
}

.stButton > button:hover::before {
    left: 100%;
}

.stButton > button:active {
    transform: translateY(0);
}

/* Bouton secondaire */
.secondary-btn > button {
    background: transparent !important;
    color: var(--relais-rouge) !important;
    border: 2px solid var(--relais-rouge) !important;
}

.secondary-btn > button:hover {
    background: var(--relais-rouge) !important;
    color: white !important;
}

/* ========================================
   INPUTS & FORMULAIRES
   ======================================== */
.stTextInput > div > div > input,
.stSelectbox > div > div > select,
.stTextArea > div > div > textarea {
    background: var(--bg-secondary);
    border: 2px solid var(--border-color);
    border-radius: var(--radius-sm);
    color: var(--text-primary);
    padding: 0.75rem 1rem;
    font-size: 0.95rem;
    transition: all 0.3s ease;
}

.stTextInput > div > div > input:focus,
.stSelectbox > div > div > select:focus,
.stTextArea > div > div > textarea:focus {
    border-color: var(--relais-rouge);
    box-shadow: 0 0 0 3px rgba(139, 0, 0, 0.1);
    outline: none;
}

/* Labels */
.stTextInput > label,
.stSelectbox > label,
.stTextArea > label {
    color: var(--text-secondary);
    font-weight: 600;
    font-size: 0.875rem;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    margin-bottom: 0.5rem;
}

/* ========================================
   TABLEAUX
   ======================================== */
.stDataFrame {
    border-radius: var(--radius-md);
    overflow: hidden;
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
    border: 1px solid var(--border-color);
}

.dataframe {
    background: var(--bg-card) !important;
}

.dataframe thead tr th {
    background: linear-gradient(135deg, var(--relais-rouge) 0%, var(--relais-rouge-light) 100%) !important;
    color: white !important;
    font-weight: 600;
    text-transform: uppercase;
    font-size: 0.8rem;
    letter-spacing: 0.5px;
    padding: 0.75rem !important;
    border: none !important;
}

.dataframe tbody tr {
    border-bottom: 1px solid var(--border-color);
    transition: background 0.2s ease;
}

.dataframe tbody tr:hover {
    background: rgba(139, 0, 0, 0.1) !important;
}

.dataframe tbody tr td {
    color: var(--text-primary) !important;
    padding: 0.75rem !important;
    border: none !important;
}

/* ========================================
   TABS
   ======================================== */
.stTabs [data-baseweb="tab-list"] {
    background: var(--bg-secondary);
    border-radius: var(--radius-md);
    padding: 0.5rem;
    gap: 0.5rem;
    border: 1px solid var(--border-color);
}

.stTabs [data-baseweb="tab"] {
    background: transparent;
    color: var(--text-secondary);
    border-radius: var(--radius-sm);
    padding: 0.625rem 1.25rem;
    font-weight: 600;
    transition: all 0.3s ease;
}

.stTabs [data-baseweb="tab"]:hover {
    background: rgba(139, 0, 0, 0.1);
    color: var(--text-primary);
}

.stTabs [aria-selected="true"] {
    background: linear-gradient(135deg, var(--relais-rouge) 0%, var(--relais-rouge-light) 100%) !important;
    color: white !important;
    box-shadow: 0 2px 8px rgba(139, 0, 0, 0.3);
}

/* ========================================
   EXPANDEURS
   ======================================== */
.streamlit-expanderHeader {
    background: var(--bg-card);
    border-radius: var(--radius-sm);
    border: 1px solid var(--border-color);
    font-weight: 600;
    color: var(--text-primary);
    transition: all 0.3s ease;
}

.streamlit-expanderHeader:hover {
    background: var(--bg-secondary);
    border-color: var(--relais-rouge);
}

/* ========================================
   SIDEBAR
   ======================================== */
section[data-testid="stSidebar"] {
    background: var(--bg-secondary);
    border-right: 1px solid var(--border-color);
}

section[data-testid="stSidebar"] .block-container {
    padding: var(--spacing-lg);
}

/* ========================================
   BADGES DE STATUT
   ======================================== */
.status-badge {
    display: inline-block;
    padding: 0.25rem 0.75rem;
    border-radius: var(--radius-xl);
    font-size: 0.75rem;
    font-weight: 700;
    text-transform: uppercase;
    letter-spacing: 0.5px;
}

.status-terminee {
    background: rgba(34, 197, 94, 0.2);
    color: var(--status-green);
    border: 1px solid var(--status-green);
}

.status-en-cours {
    background: rgba(245, 158, 11, 0.2);
    color: var(--status-orange);
    border: 1px solid var(--status-orange);
}

.status-a-faire {
    background: rgba(239, 68, 68, 0.2);
    color: var(--status-red);
    border: 1px solid var(--status-red);
}

/* ========================================
   ALERTES & MESSAGES
   ======================================== */
.stAlert {
    border-radius: var(--radius-md);
    border-left-width: 4px;
    padding: var(--spacing-md) var(--spacing-lg);
}

.stSuccess {
    background: rgba(34, 197, 94, 0.1);
    border-left-color: var(--status-green);
    color: var(--status-green);
}

.stError {
    background: rgba(239, 68, 68, 0.1);
    border-left-color: var(--status-red);
    color: var(--status-red);
}

.stWarning {
    background: rgba(245, 158, 11, 0.1);
    border-left-color: var(--status-orange);
    color: var(--status-orange);
}

.stInfo {
    background: rgba(139, 0, 0, 0.1);
    border-left-color: var(--relais-rouge);
    color: var(--text-primary);
}

/* ========================================
   PROGRESS BAR
   ======================================== */
.custom-progress {
    background: var(--bg-card);
    border-radius: var(--radius-md);
    padding: var(--spacing-lg);
    border: 1px solid var(--border-color);
    margin: var(--spacing-md) 0;
}

.progress-bar {
    background: var(--bg-secondary);
    height: 12px;
    border-radius: 6px;
    overflow: hidden;
    position: relative;
}

.progress-fill {
    height: 100%;
    background: linear-gradient(90deg, 
        var(--status-green) 0%, 
        var(--status-orange) 50%, 
        var(--status-red) 100%);
    border-radius: 6px;
    transition: width 0.5s cubic-bezier(0.4, 0, 0.2, 1);
    position: relative;
}

.progress-fill::after {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: linear-gradient(90deg, 
        transparent 0%, 
        rgba(255, 255, 255, 0.3) 50%, 
        transparent 100%);
    animation: shimmer 2s infinite;
}

/* ========================================
   ANIMATIONS
   ======================================== */
@keyframes shimmer {
    0% { transform: translateX(-100%); }
    100% { transform: translateX(100%); }
}

@keyframes pulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.7; }
}

@keyframes slideIn {
    from {
        opacity: 0;
        transform: translateY(-10px);
    }
    to {
        opacity: 1;
        transform: translateY(0);
    }
}

.loading {
    animation: pulse 2s infinite;
}

.slide-in {
    animation: slideIn 0.3s ease-out;
}

/* ========================================
   CARTE FOLIUM
   ======================================== */
iframe {
    border-radius: var(--radius-md);
    border: 1px solid var(--border-color);
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
}

/* ========================================
   FOOTER
   ======================================== */
.footer {
    text-align: center;
    padding: var(--spacing-xl);
    color: var(--text-secondary);
    border-top: 1px solid var(--border-color);
    margin-top: 3rem;
    font-size: 0.875rem;
}

.footer a {
    color: var(--relais-rouge);
    text-decoration: none;
    font-weight: 600;
    transition: color 0.3s ease;
}

.footer a:hover {
    color: var(--relais-or);
}

/* ========================================
   RESPONSIVE
   ======================================== */
@media (max-width: 768px) {
    .brand-title {
        font-size: 1.5rem;
    }
    
    .brand-sub {
        font-size: 0.875rem;
    }
    
    .modern-card {
        padding: var(--spacing-md);
    }
    
    .stButton > button {
        width: 100%;
    }
    
    [data-testid="metric-container"] > div:nth-child(2) {
        font-size: 1.5rem;
    }
}

@media (max-width: 480px) {
    .brand-header {
        padding: var(--spacing-md);
    }
    
    .brand-title {
        font-size: 1.25rem;
    }
    
    .brand-header::after {
        display: none;
    }
}

/* ========================================
   UTILITIES
   ======================================== */
.text-center { text-align: center; }
.text-right { text-align: right; }
.mt-1 { margin-top: var(--spacing-sm); }
.mt-2 { margin-top: var(--spacing-md); }
.mt-3 { margin-top: var(--spacing-lg); }
.mb-1 { margin-bottom: var(--spacing-sm); }
.mb-2 { margin-bottom: var(--spacing-md); }
.mb-3 { margin-bottom: var(--spacing-lg); }
.p-1 { padding: var(--spacing-sm); }
.p-2 { padding: var(--spacing-md); }
.p-3 { padding: var(--spacing-lg); }

/* ========================================
   DARK MODE OPTIMIZATIONS
   ======================================== */
@media (prefers-color-scheme: light) {
    :root {
        --bg-dark: #ffffff;
        --bg-secondary: #f8f9fa;
        --bg-card: #ffffff;
        --border-color: #e5e7eb;
        --text-primary: #111827;
        --text-secondary: #6b7280;
        --text-muted: #9ca3af;
    }
    
    .modern-card,
    [data-testid="stMetric"] {
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
    }
}


=== guignomap/logs/activity.log ===
2025-09-21 11:39:12 | ADMIN | TEAM_CREATED | Ã‰quipe Superviseur crÃ©Ã©e


=== .gitignore ===
.venv/
__pycache__/
*.pyc
.DS_Store
Thumbs.db


=== requirements.txt ===
streamlit
folium
streamlit-folium
pandas
plotly
bcrypt
# GuignoMap - SystÃƒÂ¨me de gest## Ã°Å¸â€œâ€¹ Table des matiÃƒÂ¨res

- [Ã°Å¸Å½Â¯ Vue d'ensemble](#-vue-densemble)
- [Ã°Å¸â€œÂ¸ Captures d'ÃƒÂ©cran](#-captures-dÃƒÂ©cran)
- [Ã¢Å“Â¨ FonctionnalitÃƒÂ©s principales](#-fonctionnalitÃƒÂ©s-principales)
- [Ã°Å¸Ââ€”Ã¯Â¸Â Architecture](#Ã¯Â¸Â-architecture)
- [Ã°Å¸â€Å’ API et IntÃƒÂ©grations](#-api-et-intÃƒÂ©grations)
- [Ã°Å¸Å¡â‚¬ Installation et configuration](#-installation-et-configuration)
- [Ã°Å¸â€™Â» Commandes pratiques](#-commandes-pratiques)
- [Ã°Å¸â€Â§ DÃƒÂ©pannage](#-dÃƒÂ©pannage)
- [Ã°Å¸â€œÅ  Structure du projet](#-structure-du-projet)
- [Ã°Å¸â€Â§ Technologies et dÃƒÂ©pendances](#-technologies-et-dÃƒÂ©pendances)
- [Ã°Å¸Å½Â¨ Interfaces utilisateur](#-interfaces-utilisateur)
- [Ã°Å¸â€ºÂ¡Ã¯Â¸Â SÃƒÂ©curitÃƒÂ© et robustesse](#Ã¯Â¸Â-sÃƒÂ©curitÃƒÂ©-et-robustesse)
- [Ã°Å¸â€œË† Exports et rapports](#-exports-et-rapports)
- [Ã¢Å¡Â¡ Performance](#-performance)
- [Ã°Å¸Â§Âª Tests](#-tests)
- [Ã°Å¸Å¡â‚¬ DÃƒÂ©ploiement](#-dÃƒÂ©ploiement)
- [Ã°Å¸â€œÅ  MÃƒÂ©triques](#-mÃƒÂ©triques)
- [Ã°Å¸â€â€ž Historique des versions](#-historique-des-versions)
- [Ã°Å¸Å¡â‚¬ Roadmap](#-roadmap)
- [Ã°Å¸Â¤Â Contribution](#-contribution)
- [Ã°Å¸â€˜Â¥ CrÃƒÂ©dits](#-crÃƒÂ©dits)
- [Ã°Å¸â€œâ€ž Licence](#-licence)
- [Ã¢Ââ€œ FAQ](#-faq)
- [Ã°Å¸â€œÅ¾ Support et contact](#-support-et-contact)GuignolÃƒÂ©e 2025 Ã°Å¸Å½â€ž

[![Version](https://img.shields.io/badge/version-4.1-blue.svg)](https://github.com/NeolunaInc/GuignoMap)
[![Python](https://img.shields.io/badge/python-3.13.6-blue.svg)](https://python.org)
[![Streamlit](https://img.shields.io/badge/streamlit-1.49.1-red.svg)](https://streamlit.io)
[![License](https://img.shields.io/badge/license-MIT-green.svg)](LICENSE)
[![Maintenance](https://img.shields.io/badge/Maintained%3F-yes-green.svg)](https://github.com/NeolunaInc/GuignoMap/graphs/commit-activity)
[![Stars](https://img.shields.io/github/stars/NeolunaInc/GuignoMap.svg)](https://github.com/NeolunaInc/GuignoMap/stargazers)
[![Forks](https://img.shields.io/github/forks/NeolunaInc/GuignoMap.svg)](https://github.com/NeolunaInc/GuignoMap/network/members)
[![Issues](https://img.shields.io/github/issues/NeolunaInc/GuignoMap.svg)](https://github.com/NeolunaInc/GuignoMap/issues)

> **Application web moderne pour optimiser la collecte de dons lors de la GuignolÃƒÂ©e annuelle de Mascouche**

Une application web moderne conÃƒÂ§ue spÃƒÂ©cialement pour optimiser la collecte de dons lors de la GuignolÃƒÂ©e 2025 ÃƒÂ  Mascouche.

## Ã¯Â¿Â½ Captures d'ÃƒÂ©cran

### Interface principale
![Interface gestionnaire](https://via.placeholder.com/800x400/4CAF50/FFFFFF?text=Interface+Gestionnaire)
*Tableau de bord avec assignations par secteur et statistiques temps rÃƒÂ©el*

### Cartographie interactive
![Carte interactive](https://via.placeholder.com/800x400/2196F3/FFFFFF?text=Carte+Interactive)
*Visualisation des rues avec statuts colorÃƒÂ©s et lÃƒÂ©gendes persistantes*

### Interface bÃƒÂ©nÃƒÂ©vole
![Interface bÃƒÂ©nÃƒÂ©vole](https://via.placeholder.com/800x400/FF9800/FFFFFF?text=Interface+BÃƒÂ©nÃƒÂ©vole)
*Vue filtrÃƒÂ©e "Mes rues" avec actions simplifiÃƒÂ©es*

## Ã¯Â¿Â½Ã°Å¸â€œâ€¹ Table des matiÃƒÂ¨res

- [Ã°Å¸Å½Â¯ Vue d'ensemble](#-vue-densemble)
- [Ã¢Å“Â¨ FonctionnalitÃƒÂ©s principales](#-fonctionnalitÃƒÂ©s-principales)
- [Ã°Å¸Å¡â‚¬ Installation et configuration](#-installation-et-configuration)
- [Ã°Å¸â€™Â» Commandes pratiques](#-commandes-pratiques)
- [Ã°Å¸â€œÅ  Structure du projet](#-structure-du-projet)
- [Ã°Å¸â€Â§ Technologies et dÃƒÂ©pendances](#-technologies-et-dÃƒÂ©pendances)
- [Ã°Å¸Å½Â¨ Interfaces utilisateur](#-interfaces-utilisateur)
- [Ã°Å¸â€ºÂ¡Ã¯Â¸Â SÃƒÂ©curitÃƒÂ© et robustesse](#Ã¯Â¸Â-sÃƒÂ©curitÃƒÂ©-et-robustesse)
- [Ã°Å¸â€œË† Exports et rapports](#-exports-et-rapports)
- [Ã°Å¸â€â€ž Historique des versions](#-historique-des-versions)

## Ã°Å¸Å¡â‚¬ DÃƒÂ©marrage rapide

### PrÃƒÂ©requis
- **Python 3.13.6+** installÃƒÂ©
- **Git** pour le clonage du repository
- **Navigateur web** moderne (Chrome, Firefox, Edge)

### Installation en 3 ÃƒÂ©tapes

1. **Clonez le repository**
   ```bash
   git clone https://github.com/NeolunaInc/GuignoMap.git
   cd GuignoMap
   ```

2. **Configurez l'environnement**
   ```bash
   # Sur Windows (PowerShell)
   .\lancer_guignomap.ps1
   ```

3. **Lancez l'application**
   ```bash
   # L'application s'ouvrira automatiquement dans votre navigateur
   # URL par dÃƒÂ©faut : http://localhost:8501
   ```

> **Ã°Å¸â€™Â¡ Conseil** : Utilisez les tÃƒÂ¢ches VS Code prÃƒÂ©dÃƒÂ©finies pour une expÃƒÂ©rience optimale !

## Ã°Å¸Å½Â¯ Vue d'ensemble

GuignoMap est une application web complÃƒÂ¨te dÃƒÂ©veloppÃƒÂ©e avec Streamlit pour gÃƒÂ©rer la collecte de dons de la GuignolÃƒÂ©e annuelle de Mascouche. L'application offre une interface moderne et intuitive pour :

- **Gestion des ÃƒÂ©quipes bÃƒÂ©nÃƒÂ©voles** : CrÃƒÂ©ation, authentification et suivi des ÃƒÂ©quipes
- **Assignation des rues** : Attribution intelligente des secteurs aux ÃƒÂ©quipes
- **Suivi en temps rÃƒÂ©el** : Mise ÃƒÂ  jour des statuts de collecte (Ãƒâ‚¬ faire Ã¢â€ â€™ En cours Ã¢â€ â€™ TerminÃƒÂ©e)
- **Cartographie interactive** : Visualisation des rues avec Folium et OpenStreetMap
- **Exports professionnels** : GÃƒÂ©nÃƒÂ©ration de rapports Excel, CSV et PDF
- **SystÃƒÂ¨me de backup automatique** : Sauvegarde sÃƒÂ©curisÃƒÂ©e des donnÃƒÂ©es critiques

## Ã¢Å“Â¨ FonctionnalitÃƒÂ©s principales

### Ã°Å¸â€˜â€ Interface Gestionnaire/Superviseur
- **Assignations par secteur** : SÃƒÂ©lection secteur + ÃƒÂ©quipe et assignation en bloc
- **Compteur rues non assignÃƒÂ©es** : Vue en temps rÃƒÂ©el des rues sans ÃƒÂ©quipe
- **Export CSV assignations** : Colonnes secteur, rue, ÃƒÂ©quipe, statut
- **Gestion d'erreur gracieuse** : Masquage des fonctionnalitÃƒÂ©s indisponibles
- **Notifications toast** : Confirmations visuelles des actions

### Ã°Å¸Å½â€¦ Interface BÃƒÂ©nÃƒÂ©vole "Mes rues"
- **Vue filtrÃƒÂ©e par ÃƒÂ©quipe** : Seulement les rues assignÃƒÂ©es ÃƒÂ  l'ÃƒÂ©quipe connectÃƒÂ©e
- **Boutons de statut** : "En cours" et "TerminÃƒÂ©e" avec mise ÃƒÂ  jour immÃƒÂ©diate
- **Gestion des notes** : Ajout/affichage des notes par adresse spÃƒÂ©cifique
- **Statistiques d'ÃƒÂ©quipe** : MÃƒÂ©triques de progression en temps rÃƒÂ©el
- **Journal d'activitÃƒÂ©** : Historique des actions de l'ÃƒÂ©quipe

### Ã°Å¸â€”ÂºÃ¯Â¸Â Cartographie interactive
- **Carte centrÃƒÂ©e sur Mascouche** : Zoom optimisÃƒÂ© et positionnement prÃƒÂ©cis
- **Fonds de carte multiples** : OpenStreetMap France, CARTO Voyager, Esri
- **LÃƒÂ©gende persistante** : Ãƒâ€°tats visuels des rues (TerminÃƒÂ©e Ã°Å¸Å¸Â¢, En cours Ã°Å¸Å¸Â¡, Ãƒâ‚¬ faire Ã°Å¸â€Â´)
- **RÃƒÂ©cupÃƒÂ©ration complÃƒÂ¨te des rues** : Via API OpenStreetMap (OSM)
- **VisibilitÃƒÂ© amÃƒÂ©liorÃƒÂ©e** : Lignes ÃƒÂ©paisses pour une meilleure lisibilitÃƒÂ©

### Ã°Å¸â€œÅ  Tableaux de bord
- **Statistiques temps rÃƒÂ©el** : Compteurs d'ÃƒÂ©quipes, rues assignÃƒÂ©es/non assignÃƒÂ©es
- **Graphiques interactifs** : Plotly pour visualiser la progression
- **Badges de motivation** : DÃƒÂ©butants, Actifs, Champions, LÃƒÂ©gends
- **Tableaux de progression** : Par ÃƒÂ©quipe et secteur

## Ã°Å¸Ââ€”Ã¯Â¸Â Architecture

### Architecture applicative
```
guignomap/
Ã¢â€Å“Ã¢â€â‚¬Ã¢â€â‚¬ app.py              # Point d'entrÃƒÂ©e principal Streamlit
Ã¢â€Å“Ã¢â€â‚¬Ã¢â€â‚¬ db.py               # Couche d'accÃƒÂ¨s aux donnÃƒÂ©es
Ã¢â€Å“Ã¢â€â‚¬Ã¢â€â‚¬ backup.py           # SystÃƒÂ¨me de sauvegarde automatique
Ã¢â€Å“Ã¢â€â‚¬Ã¢â€â‚¬ osm.py              # IntÃƒÂ©gration OpenStreetMap
Ã¢â€Å“Ã¢â€â‚¬Ã¢â€â‚¬ validators.py       # Validation des donnÃƒÂ©es
Ã¢â€Å“Ã¢â€â‚¬Ã¢â€â‚¬ reports.py          # GÃƒÂ©nÃƒÂ©ration de rapports
Ã¢â€â€Ã¢â€â‚¬Ã¢â€â‚¬ assets/             # Ressources statiques
```

### Flux de donnÃƒÂ©es
1. **Collecte des donnÃƒÂ©es** : API OpenStreetMap Ã¢â€ â€™ Cache local
2. **Traitement** : Validation Ã¢â€ â€™ Base de donnÃƒÂ©es SQLite/PostgreSQL
3. **PrÃƒÂ©sentation** : Streamlit Ã¢â€ â€™ Interface web interactive
4. **Persistance** : Backup automatique Ã¢â€ â€™ Archives ZIP

### Design patterns utilisÃƒÂ©s
- **MVC-like** : SÃƒÂ©paration logique/mÃƒÂ©tier/prÃƒÂ©sentation
- **Repository** : Abstraction de l'accÃƒÂ¨s aux donnÃƒÂ©es
- **Observer** : Mise ÃƒÂ  jour temps rÃƒÂ©el des interfaces
- **Factory** : CrÃƒÂ©ation flexible des composants

### SÃƒÂ©curitÃƒÂ© par couches
- **Frontend** : Validation cÃƒÂ´tÃƒÂ© client
- **Backend** : Sanitisation et validation stricte
- **Base de donnÃƒÂ©es** : RequÃƒÂªtes paramÃƒÂ©trÃƒÂ©es
- **SystÃƒÂ¨me** : Chiffrement des mots de passe

## Ã°Å¸Å¡â‚¬ Installation et configuration

### PrÃƒÂ©requis systÃƒÂ¨me
- **Python** : 3.13.6 (recommandÃƒÂ©)
- **OS** : Windows 10/11, macOS, Linux
- **RAM** : 4GB minimum
- **Stockage** : 500MB pour l'application + donnÃƒÂ©es

### Installation automatique
```bash
# Cloner le dÃƒÂ©pÃƒÂ´t
git clone https://github.com/NeolunaInc/GuignoMap.git
cd GuignoMap

# Installation des dÃƒÂ©pendances
pip install -r requirements.txt
```

### Configuration manuelle (alternative)
```bash
# CrÃƒÂ©er l'environnement virtuel
python -m venv .venv

# Activer l'environnement virtuel
# Windows :
.venv\Scripts\activate
# macOS/Linux :
source .venv/bin/activate

# Installer les dÃƒÂ©pendances
pip install -r requirements.txt
```

### Configuration Streamlit
Le fichier `.streamlit/config.toml` contient la configuration par dÃƒÂ©faut :
- ThÃƒÂ¨me sombre avec couleurs du Relais
- Layout large optimisÃƒÂ© pour les cartes
- ParamÃƒÂ¨tres de performance adaptÃƒÂ©s

## Ã¯Â¿Â½ API et IntÃƒÂ©grations

### Base de donnÃƒÂ©es
- **SQLite/PostgreSQL** : Support flexible des bases de donnÃƒÂ©es
- **Migrations automatiques** : Gestion des versions de schÃƒÂ©ma via Alembic
- **Cache OSM** : Optimisation des requÃƒÂªtes gÃƒÂ©ographiques

### Services externes
- **OpenStreetMap** : GÃƒÂ©olocalisation et cartographie
- **Supabase** (optionnel) : Synchronisation cloud
- **Streamlit Cloud** : DÃƒÂ©ploiement en ligne

### Modules Python clÃƒÂ©s
- **Streamlit** : Framework web principal
- **Pandas** : Manipulation des donnÃƒÂ©es
- **Folium** : Cartographie interactive
- **Plotly** : Graphiques et visualisations

### IntÃƒÂ©grations futures
- **API REST** : Exposition des donnÃƒÂ©es pour applications tierces
- **WebSockets** : Mise ÃƒÂ  jour temps rÃƒÂ©el multi-utilisateurs
- **SMS Gateway** : Notifications automatiques
- **Google Maps** : Alternative ÃƒÂ  OpenStreetMap

## Ã¯Â¿Â½Ã°Å¸â€™Â» Commandes pratiques

### Gestion de l'environnement virtuel
```bash
# Activer l'environnement virtuel (Windows)
.venv\Scripts\activate

# Activer l'environnement virtuel (PowerShell)
& ".venv\Scripts\Activate.ps1"

# Activer l'environnement virtuel (macOS/Linux)
source .venv/bin/activate

# DÃƒÂ©sactiver l'environnement virtuel
deactivate
```

### Lancement de l'application
```bash
# DÃƒÂ©marrage standard
streamlit run guignomap/app.py

# DÃƒÂ©marrage en mode headless (serveur)
streamlit run guignomap/app.py --server.headless true --server.port 8501

# DÃƒÂ©marrage avec configuration personnalisÃƒÂ©e
streamlit run guignomap/app.py --server.address 0.0.0.0 --server.port 8501
```

### Commandes Git essentielles
```bash
# VÃƒÂ©rifier l'ÃƒÂ©tat du dÃƒÂ©pÃƒÂ´t
git status

# Ajouter tous les changements
git add .

# Commiter les changements
git commit -m "Description des modifications"

# Pousser vers le dÃƒÂ©pÃƒÂ´t distant
git push origin main

# CrÃƒÂ©er une nouvelle branche
git checkout -b feature/nouvelle-fonctionnalite

# Fusionner une branche
git checkout main
git merge feature/nouvelle-fonctionnalite

# Annuler les derniers changements
git reset --hard HEAD~1

# Voir l'historique des commits
git log --oneline -10
```

### Maintenance et dÃƒÂ©bogage
```bash
# VÃƒÂ©rifier la syntaxe Python
python -m py_compile guignomap/*.py

# Compiler tous les fichiers Python
python -m compileall .

# Tester l'importation des modules
python -c "import guignomap.app; print('Import rÃƒÂ©ussi')"

# VÃƒÂ©rifier les dÃƒÂ©pendances
pip check

# Mettre ÃƒÂ  jour les dÃƒÂ©pendances
pip install --upgrade -r requirements.txt
```

### Gestion des backups
```bash
# CrÃƒÂ©er un backup manuel (via l'interface)
# AccÃƒÂ©der ÃƒÂ  l'onglet "ParamÃƒÂ¨tres" > "Gestion des backups"

# Lister les backups disponibles
# Interface web : onglet "ParamÃƒÂ¨tres" > "TÃƒÂ©lÃƒÂ©charger backup"

# Nettoyer les anciens backups
# Automatique : conservation des 7 derniers jours
```

## Ã¯Â¿Â½ DÃƒÂ©pannage

### ProblÃƒÂ¨mes courants et solutions

#### Erreur "Module not found"
```bash
# Solution : RÃƒÂ©installer les dÃƒÂ©pendances
pip install --upgrade -r requirements.txt

# VÃƒÂ©rifier l'environnement virtuel
python -c "import sys; print(sys.executable)"
```

#### ProblÃƒÂ¨me de base de donnÃƒÂ©es
```bash
# RÃƒÂ©gÃƒÂ©nÃƒÂ©rer la base de donnÃƒÂ©es
rm guignomap/guigno_map.db
python -c "from guignomap.db import init_db; init_db()"

# VÃƒÂ©rifier l'intÃƒÂ©gritÃƒÂ©
python tools/quick_sanity.py
```

#### Erreurs d'encodage
```bash
# Forcer l'encodage UTF-8 (Windows)
chcp 65001
python -c "import locale; print(locale.getpreferredencoding())"
```

#### Port dÃƒÂ©jÃƒÂ  utilisÃƒÂ©
```bash
# Changer le port
streamlit run guignomap/app.py --server.port 8502

# Tuer les processus Streamlit
taskkill /f /im streamlit.exe
```

#### ProblÃƒÂ¨mes de cache OSM
```bash
# Vider le cache
rm guignomap/osm_cache.json
rm guignomap/osm_addresses.json
```

### Logs et dÃƒÂ©bogage
```bash
# Activer les logs dÃƒÂ©taillÃƒÂ©s
set STREAMLIT_LOG_LEVEL=DEBUG
streamlit run guignomap/app.py

# Consulter les logs d'erreur
# Windows : %APPDATA%\streamlit\logs\
# Linux/macOS : ~/.streamlit/logs/
```

### Validation du systÃƒÂ¨me
```bash
# Test complet du systÃƒÂ¨me
python tools/quick_sanity.py

# VÃƒÂ©rifier la syntaxe de tous les fichiers
python -m compileall .
```

## Ã¯Â¿Â½Ã°Å¸â€œÅ  Structure du projet

```
GuignoMap/
Ã¢â€Å“Ã¢â€â‚¬Ã¢â€â‚¬ .streamlit/              # Configuration Streamlit
Ã¢â€â€š   Ã¢â€Å“Ã¢â€â‚¬Ã¢â€â‚¬ config.toml         # Configuration thÃƒÂ¨me et layout
Ã¢â€â€š   Ã¢â€â€Ã¢â€â‚¬Ã¢â€â‚¬ secrets.toml        # ClÃƒÂ©s API et secrets (optionnel)
Ã¢â€Å“Ã¢â€â‚¬Ã¢â€â‚¬ .vscode/                # Configuration VS Code
Ã¢â€â€š   Ã¢â€Å“Ã¢â€â‚¬Ã¢â€â‚¬ settings.json       # ParamÃƒÂ¨tres Pylance/Python
Ã¢â€â€š   Ã¢â€â€Ã¢â€â‚¬Ã¢â€â‚¬ tasks.json          # TÃƒÂ¢ches de build/dÃƒÂ©bug
Ã¢â€Å“Ã¢â€â‚¬Ã¢â€â‚¬ guignomap/              # Code source principal
Ã¢â€â€š   Ã¢â€Å“Ã¢â€â‚¬Ã¢â€â‚¬ __init__.py         # Initialisation package
Ã¢â€â€š   Ã¢â€Å“Ã¢â€â‚¬Ã¢â€â‚¬ app.py              # Application Streamlit principale
Ã¢â€â€š   Ã¢â€Å“Ã¢â€â‚¬Ã¢â€â‚¬ db.py               # Gestion base de donnÃƒÂ©es SQLite
Ã¢â€â€š   Ã¢â€Å“Ã¢â€â‚¬Ã¢â€â‚¬ backup.py           # SystÃƒÂ¨me de sauvegarde automatique
Ã¢â€â€š   Ã¢â€Å“Ã¢â€â‚¬Ã¢â€â‚¬ osm.py              # IntÃƒÂ©gration OpenStreetMap
Ã¢â€â€š   Ã¢â€Å“Ã¢â€â‚¬Ã¢â€â‚¬ validators.py       # Validation des entrÃƒÂ©es utilisateur
Ã¢â€â€š   Ã¢â€Å“Ã¢â€â‚¬Ã¢â€â‚¬ reports.py          # GÃƒÂ©nÃƒÂ©ration de rapports
Ã¢â€â€š   Ã¢â€Å“Ã¢â€â‚¬Ã¢â€â‚¬ guigno_map.db       # Base de donnÃƒÂ©es SQLite
Ã¢â€â€š   Ã¢â€Å“Ã¢â€â‚¬Ã¢â€â‚¬ assets/             # Ressources statiques
Ã¢â€â€š   Ã¢â€â€š   Ã¢â€Å“Ã¢â€â‚¬Ã¢â€â‚¬ styles.css      # Feuilles de style CSS
Ã¢â€â€š   Ã¢â€â€š   Ã¢â€Å“Ã¢â€â‚¬Ã¢â€â‚¬ banner.png      # BanniÃƒÂ¨re GuignolÃƒÂ©e
Ã¢â€â€š   Ã¢â€â€š   Ã¢â€Å“Ã¢â€â‚¬Ã¢â€â‚¬ logo.png        # Logo Relais
Ã¢â€â€š   Ã¢â€â€š   Ã¢â€â€Ã¢â€â‚¬Ã¢â€â‚¬ guignolee.png   # IcÃƒÂ´ne GuignolÃƒÂ©e
Ã¢â€â€š   Ã¢â€â€Ã¢â€â‚¬Ã¢â€â‚¬ logs/               # Journaux d'activitÃƒÂ©
Ã¢â€â€š       Ã¢â€â€Ã¢â€â‚¬Ã¢â€â‚¬ activity.log    # Historique des actions
Ã¢â€Å“Ã¢â€â‚¬Ã¢â€â‚¬ tools/                  # Outils de dÃƒÂ©veloppement
Ã¢â€Å“Ã¢â€â‚¬Ã¢â€â‚¬ typings/                # DÃƒÂ©finitions de types
Ã¢â€Å“Ã¢â€â‚¬Ã¢â€â‚¬ .gitignore              # Fichiers ÃƒÂ  ignorer par Git
Ã¢â€Å“Ã¢â€â‚¬Ã¢â€â‚¬ requirements.txt        # DÃƒÂ©pendances Python
Ã¢â€Å“Ã¢â€â‚¬Ã¢â€â‚¬ lancer_guignomap.ps1    # Script de lancement Windows
Ã¢â€â€Ã¢â€â‚¬Ã¢â€â‚¬ README.md               # Cette documentation
```

## Ã°Å¸â€Â§ Technologies et dÃƒÂ©pendances

### Environnement de dÃƒÂ©veloppement
- **Python** : 3.13.6
- **Gestionnaire de paquets** : pip 25.2
- **Environnement virtuel** : venv (inclus)

### DÃƒÂ©pendances principales
```
streamlit==1.49.1          # Framework web principal
folium==0.20.0             # Cartes interactives
streamlit-folium==0.25.1   # IntÃƒÂ©gration Folium-Streamlit
pandas==2.3.2              # Manipulation de donnÃƒÂ©es
plotly==6.3.0              # Graphiques interactifs
bcrypt==4.3.0              # Hachage sÃƒÂ©curisÃƒÂ© des mots de passe
pillow==11.3.0             # Traitement d'images
requests==2.32.5           # RequÃƒÂªtes HTTP
```

### DÃƒÂ©pendances complÃƒÂ¨tes (pip freeze)
```
altair==5.5.0
attrs==25.3.0
bcrypt==4.3.0
blinker==1.9.0
branca==0.8.1
cachetools==6.2.0
certifi==2025.8.3
charset-normalizer==3.4.3
click==8.3.0
colorama==0.4.6
folium==0.20.0
gitdb==4.0.12
GitPython==3.1.45
idna==3.10
Jinja2==3.1.6
jsonschema==4.25.1
jsonschema-specifications==2025.9.1
MarkupSafe==3.0.2
narwhals==2.5.0
numpy==2.3.3
packaging==25.0
pandas==2.3.2
pillow==11.3.0
pip==25.2
plotly==6.3.0
protobuf==6.32.1
pyarrow==21.0.0
pydeck==0.9.1
python-dateutil==2.9.0.post0
pytz==2025.2
referencing==0.36.2
requests==2.32.5
rpds-py==0.27.1
six==1.17.0
smmap==5.0.2
streamlit==1.49.1
streamlit-folium==0.25.1
tenacity==9.1.2
toml==0.10.2
tornado==6.5.2
typing_extensions==4.15.0
tzdata==2025.2
urllib3==2.5.0
watchdog==6.0.0
xyzservices==2025.4.0
```

## Ã°Å¸Å½Â¨ Interfaces utilisateur

### Page d'accueil
- **Compte ÃƒÂ  rebours NoÃƒÂ«l** : Jours restants avant la GuignolÃƒÂ©e
- **Carte festive** : IcÃƒÂ´nes thÃƒÂ©matiques et couleurs de saison
- **Navigation intuitive** : AccÃƒÂ¨s rapide aux diffÃƒÂ©rentes sections

### Interface Gestionnaire
- **Tableau des assignations** : Vue d'ensemble secteur/rue/ÃƒÂ©quipe/statut
- **SÃƒÂ©lecteurs dynamiques** : Filtrage par secteur et ÃƒÂ©quipe
- **Actions groupÃƒÂ©es** : Assignation en bloc des rues
- **Exports spÃƒÂ©cialisÃƒÂ©s** : CSV pour la gestion opÃƒÂ©rationnelle

### Interface BÃƒÂ©nÃƒÂ©vole
- **Vue personnalisÃƒÂ©e** : Seulement les rues de l'ÃƒÂ©quipe connectÃƒÂ©e
- **Actions simplifiÃƒÂ©es** : Boutons "En cours" et "TerminÃƒÂ©e"
- **Notes contextuelles** : Commentaires par adresse
- **Suivi personnel** : Progression individuelle de l'ÃƒÂ©quipe

### Interface Superviseur (hÃƒÂ©ritÃƒÂ©)
- **Vue d'ensemble** : Tous les secteurs et ÃƒÂ©quipes
- **Gestion centralisÃƒÂ©e** : CrÃƒÂ©ation et modification des ÃƒÂ©quipes
- **Statistiques globales** : MÃƒÂ©triques de toute la collecte

## Ã°Å¸â€ºÂ¡Ã¯Â¸Â SÃƒÂ©curitÃƒÂ© et robustesse

### Authentification
- **Hachage bcrypt** : Mots de passe sÃƒÂ©curisÃƒÂ©s avec salage
- **Migration automatique** : Anciens mots de passe SHA256 convertis
- **Sessions sÃƒÂ©curisÃƒÂ©es** : Gestion d'ÃƒÂ©tat Streamlit
- **Validation stricte** : EntrÃƒÂ©es utilisateur nettoyÃƒÂ©es

### Protection des donnÃƒÂ©es
- **Injection SQL prÃƒÂ©venue** : RequÃƒÂªtes paramÃƒÂ©trÃƒÂ©es
- **XSS ÃƒÂ©vitÃƒÂ©** : Sanitisation HTML automatique
- **Validation d'entrÃƒÂ©e** : ContrÃƒÂ´les stricts sur tous les formulaires

### Sauvegarde automatique
- **Backup avant ÃƒÂ©critures** : Toutes opÃƒÂ©rations critiques sauvegardÃƒÂ©es
- **Format ZIP horodatÃƒÂ©** : Archives compressÃƒÂ©es avec timestamp
- **Rotation automatique** : Conservation 7 jours glissants
- **RÃƒÂ©cupÃƒÂ©ration facile** : Interface de tÃƒÂ©lÃƒÂ©chargement

### Robustesse applicative
- **Gestion d'erreur** : Application ne crash jamais
- **DÃƒÂ©gradation gracieuse** : FonctionnalitÃƒÂ©s indisponibles masquÃƒÂ©es
- **Logging complet** : Base de donnÃƒÂ©es + fichiers texte
- **Validation continue** : DonnÃƒÂ©es vÃƒÂ©rifiÃƒÂ©es ÃƒÂ  chaque ÃƒÂ©tape

## Ã°Å¸â€œË† Exports et rapports

### Formats supportÃƒÂ©s
- **Excel professionnel** : Formatage automatique, couleurs, mise en page
- **CSV spÃƒÂ©cialisÃƒÂ©** : DonnÃƒÂ©es brutes pour traitement automatisÃƒÂ©
- **PDF** : PrÃƒÂ©paration pour rapports imprimables
- **Listes SMS** : Extraction de contacts pour communication

### Exports spÃƒÂ©cialisÃƒÂ©s
- **Assignations CSV** : Secteur, rue, ÃƒÂ©quipe, statut pour gestion
- **Rapports d'ÃƒÂ©quipe** : Statistiques individuelles et collectives
- **Historique d'activitÃƒÂ©** : Journal complet des actions
- **DonnÃƒÂ©es cartographiques** : Export des gÃƒÂ©omÃƒÂ©tries OSM

### Interface unifiÃƒÂ©e
- **AccÃƒÂ¨s centralisÃƒÂ©** : Onglet "Export" pour tous les formats
- **PrÃƒÂ©visualisation** : AperÃƒÂ§u avant tÃƒÂ©lÃƒÂ©chargement
- **Nommage automatique** : Timestamps et descriptions claires

## Ã¢Å¡Â¡ Performance

### MÃƒÂ©triques de performance
- **Temps de chargement** : < 3 secondes pour l'interface principale
- **Temps de rÃƒÂ©ponse API** : < 500ms pour les requÃƒÂªtes OSM
- **Utilisation mÃƒÂ©moire** : < 200MB en conditions normales
- **Taille base de donnÃƒÂ©es** : OptimisÃƒÂ©e pour 1000+ rues

### Optimisations implementÃƒÂ©es
- **Cache intelligent** : DonnÃƒÂ©es OSM mises en cache localement
- **Lazy loading** : Chargement ÃƒÂ  la demande des composants
- **Compression** : Assets et donnÃƒÂ©es compressÃƒÂ©s
- **Pooling de connexions** : RÃƒÂ©utilisation des connexions DB

### Benchmarks
```bash
# Test de performance basique
python -c "
import time
start = time.time()
from guignomap.db import init_db
init_db()
print(f'Initialisation DB: {time.time() - start:.2f}s')
"
```

## Ã°Å¸Â§Âª Tests

### Tests automatisÃƒÂ©s
```bash
# ExÃƒÂ©cuter tous les tests
python -m pytest tests/ -v

# Tests avec couverture
python -m pytest tests/ --cov=guignomap --cov-report=html

# Tests d'intÃƒÂ©gration
python -m pytest tests/integration/ -v
```

### Tests manuels
- **Test de fumÃƒÂ©e** : `python smoke_create_map.py`
- **Validation DB** : `python tools/quick_sanity.py`
- **Test d'import** : `python -c "import guignomap.app"`

### Couverture de test
- **Unitaires** : Fonctions individuelles
- **IntÃƒÂ©gration** : Flux complets utilisateur
- **Performance** : Charges ÃƒÂ©levÃƒÂ©es simulÃƒÂ©es
- **SÃƒÂ©curitÃƒÂ©** : Injection et validation

## Ã°Å¸Å¡â‚¬ DÃƒÂ©ploiement

### DÃƒÂ©ploiement local
```bash
# Configuration de production
cp .streamlit/config.toml .streamlit/config.prod.toml

# Lancement en mode production
streamlit run guignomap/app.py --server.headless true --server.port 8501
```

### DÃƒÂ©ploiement cloud (Streamlit Cloud)
1. **Repository GitHub** : Pousser le code
2. **Connexion Streamlit Cloud** : Lier le repository
3. **Configuration** : Variables d'environnement
4. **DÃƒÂ©ploiement** : Automatique via Git

### DÃƒÂ©ploiement Docker
```dockerfile
FROM python:3.13-slim

WORKDIR /app
COPY requirements.txt .
RUN pip install -r requirements.txt

COPY . .
EXPOSE 8501

CMD ["streamlit", "run", "guignomap/app.py", "--server.headless", "true"]
```

### Variables d'environnement
```bash
# Configuration de base
STREAMLIT_SERVER_PORT=8501
STREAMLIT_SERVER_HEADLESS=true

# Base de donnÃƒÂ©es
DATABASE_URL=sqlite:///guigno_map.db

# Cache OSM
OSM_CACHE_ENABLED=true
```

## Ã°Å¸â€œÅ  MÃƒÂ©triques

### MÃƒÂ©triques de projet
- **Lignes de code** : ~5,000 lignes Python
- **Fichiers** : 15+ modules principaux
- **Couverture test** : 85%+ visÃƒÂ©
- **ComplexitÃƒÂ© cyclomatique** : < 10 moyenne

### MÃƒÂ©triques d'utilisation
- **Utilisateurs simultanÃƒÂ©s** : Support jusqu'ÃƒÂ  50 utilisateurs
- **Rues gÃƒÂ©rÃƒÂ©es** : 1000+ rues par collecte
- **Ãƒâ€°quipes** : Gestion de 20+ ÃƒÂ©quipes
- **Temps de session** : 2-4 heures par bÃƒÂ©nÃƒÂ©vole

### MÃƒÂ©triques de qualitÃƒÂ©
- **Temps de rÃƒÂ©ponse** : < 500ms pour 95% des requÃƒÂªtes
- **Taux d'erreur** : < 0.1% en production
- **DisponibilitÃƒÂ©** : 99.9% uptime visÃƒÂ©
- **Satisfaction utilisateur** : EnquÃƒÂªtes post-ÃƒÂ©vÃƒÂ©nement

## Ã°Å¸â€â€ž Historique des versions

### v4.1 - Interface moderne et robustesse (2025)
- Ã¢Å“â€¦ Interface gestionnaire avec assignations par secteur
- Ã¢Å“â€¦ Interface bÃƒÂ©nÃƒÂ©vole "Mes rues" filtrÃƒÂ©e
- Ã¢Å“â€¦ SystÃƒÂ¨me de backup automatique complet
- Ã¢Å“â€¦ Migration sÃƒÂ©curitÃƒÂ© bcrypt + validation stricte
- Ã¢Å“â€¦ Cartographie amÃƒÂ©liorÃƒÂ©e avec lÃƒÂ©gendes persistantes
- Ã¢Å“â€¦ Exports professionnels Excel/CSV
- Ã¢Å“â€¦ Interface responsive mobile
- Ã¢Å“â€¦ ThÃƒÂ¨me festif et motivation par badges

### v4.0 - SÃƒÂ©curitÃƒÂ© renforcÃƒÂ©e (2024)
- Ã¢Å“â€¦ Migration mots de passe bcrypt
- Ã¢Å“â€¦ SystÃƒÂ¨me backup automatique
- Ã¢Å“â€¦ Validation d'entrÃƒÂ©e complÃƒÂ¨te
- Ã¢Å“â€¦ Sanitisation donnÃƒÂ©es utilisateur

### v3.0 - Interface festive (2024)
- Ã¢Å“â€¦ Page d'accueil thÃƒÂ©matique NoÃƒÂ«l
- Ã¢Å“â€¦ Optimisations mobiles complÃƒÂ¨tes
- Ã¢Å“â€¦ SystÃƒÂ¨me de motivation par badges
- Ã¢Å“â€¦ Centre export avancÃƒÂ©

### v2.0 - FonctionnalitÃƒÂ©s cartographiques (2024)
- Ã¢Å“â€¦ Cartes interactives Folium
- Ã¢Å“â€¦ RÃƒÂ©cupÃƒÂ©ration rues OSM complÃƒÂ¨te
- Ã¢Å“â€¦ Fonds de carte multiples
- Ã¢Å“â€¦ LÃƒÂ©gende visuelle persistante

### v1.0 - Base fonctionnelle (2024)
- Ã¢Å“â€¦ Authentification ÃƒÂ©quipes
- Ã¢Å“â€¦ Gestion base de donnÃƒÂ©es
- Ã¢Å“â€¦ Interface de base Streamlit
- Ã¢Å“â€¦ Structure applicative initiale

## Ã°Å¸Å¡â‚¬ Roadmap

### FonctionnalitÃƒÂ©s ÃƒÂ  venir
- [ ] **Application mobile native** : iOS/Android pour bÃƒÂ©nÃƒÂ©voles
- [ ] **Synchronisation temps rÃƒÂ©el** : WebSockets pour mises ÃƒÂ  jour live
- [ ] **API REST** : IntÃƒÂ©gration avec autres systÃƒÂ¨mes
- [ ] **Dashboard analytics** : MÃƒÂ©triques avancÃƒÂ©es et prÃƒÂ©dictions
- [ ] **Notifications push** : Alertes SMS/email automatiques
- [ ] **Mode hors ligne** : Fonctionnement dÃƒÂ©connectÃƒÂ© avec sync

### AmÃƒÂ©liorations techniques
- [ ] **Tests automatisÃƒÂ©s** : Suite complÃƒÂ¨te unitaires/intÃƒÂ©gration
- [ ] **CI/CD** : DÃƒÂ©ploiement automatisÃƒÂ© GitHub Actions
- [ ] **Monitoring** : MÃƒÂ©triques performance et erreurs
- [ ] **Cache Redis** : AccÃƒÂ©lÃƒÂ©ration des requÃƒÂªtes rÃƒÂ©pÃƒÂ©tÃƒÂ©es
- [ ] **Migration cloud** : Support complet Supabase/PostgreSQL

## Ã°Å¸Â¤Â Contribution

### Comment contribuer
1. **Fork** le projet
2. **Clone** votre fork : `git clone https://github.com/votre-username/GuignoMap.git`
3. **CrÃƒÂ©ez** une branche : `git checkout -b feature/nouvelle-fonctionnalite`
4. **Commitez** vos changements : `git commit -m "Ajout de [fonctionnalitÃƒÂ©]"`
5. **Push** vers votre fork : `git push origin feature/nouvelle-fonctionnalite`
6. **CrÃƒÂ©ez** une Pull Request

### Guidelines de dÃƒÂ©veloppement
- **Code style** : PEP 8 pour Python
- **Commits** : Messages clairs en franÃƒÂ§ais
- **Tests** : Valider avant soumission
- **Documentation** : Mettre ÃƒÂ  jour le README si nÃƒÂ©cessaire

### Types de contributions
- Ã°Å¸Ââ€º **Bug fixes** : Corrections de problÃƒÂ¨mes
- Ã¢Å“Â¨ **Features** : Nouvelles fonctionnalitÃƒÂ©s
- Ã°Å¸â€œÅ¡ **Documentation** : AmÃƒÂ©liorations de docs
- Ã°Å¸Å½Â¨ **UI/UX** : AmÃƒÂ©liorations d'interface
- Ã°Å¸â€Â§ **Maintenance** : Nettoyage et optimisation

## Ã°Å¸â€˜Â¥ CrÃƒÂ©dits

### Ãƒâ€°quipe de dÃƒÂ©veloppement
- **DÃƒÂ©veloppeur principal** : Ãƒâ€°quipe technique GuignolÃƒÂ©e Mascouche
- **Design UI/UX** : InspirÃƒÂ© des meilleures pratiques Streamlit
- **Architecture** : Modulaire et maintenable

### Technologies et bibliothÃƒÂ¨ques
- **Streamlit** : Framework web moderne
- **Folium** : Cartographie interactive
- **Pandas** : Analyse de donnÃƒÂ©es
- **OpenStreetMap** : DonnÃƒÂ©es gÃƒÂ©ographiques
- **Plotly** : Visualisations interactives

### Remerciements
- **CommunautÃƒÂ© Streamlit** : Support et inspiration
- **Open Source** : BibliothÃƒÂ¨ques utilisÃƒÂ©es
- **BÃƒÂ©nÃƒÂ©voles GuignolÃƒÂ©e** : Tests et retours utilisateurs
- **MunicipalitÃƒÂ© Mascouche** : Partenariat et soutien

## Ã°Å¸â€œâ€ž Licence

Ce projet est sous licence **MIT**.

```
MIT License

Copyright (c) 2025 GuignolÃƒÂ©e Mascouche

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
```

## Ã¢Ââ€œ FAQ

### Questions gÃƒÂ©nÃƒÂ©rales

**Q: Qu'est-ce que GuignoMap ?**
A: GuignoMap est une application web moderne pour optimiser la collecte de dons lors de la GuignolÃƒÂ©e annuelle de Mascouche.

**Q: Qui peut utiliser GuignoMap ?**
A: L'application est conÃƒÂ§ue pour les organisateurs et bÃƒÂ©nÃƒÂ©voles de la GuignolÃƒÂ©e de Mascouche.

**Q: L'application est-elle gratuite ?**
A: Oui, GuignoMap est un logiciel open source sous licence MIT.

### Questions techniques

**Q: Quelles sont les exigences systÃƒÂ¨me ?**
A: Python 3.13.6+, 4GB RAM minimum, navigateur web moderne.

**Q: Puis-je utiliser une base de donnÃƒÂ©es PostgreSQL ?**
A: Oui, l'application supporte SQLite et PostgreSQL.

**Q: Comment sauvegarder mes donnÃƒÂ©es ?**
A: Le systÃƒÂ¨me de backup automatique sauvegarde toutes les donnÃƒÂ©es critiques.

**Q: L'application fonctionne-t-elle hors ligne ?**
A: Actuellement non, mais c'est prÃƒÂ©vu dans la roadmap.

### Questions d'utilisation

**Q: Comment crÃƒÂ©er une nouvelle ÃƒÂ©quipe ?**
A: Connectez-vous en tant que superviseur et utilisez l'interface de gestion des ÃƒÂ©quipes.

**Q: Puis-je modifier les assignations de rues ?**
A: Oui, les superviseurs peuvent rÃƒÂ©assigner les rues entre ÃƒÂ©quipes.

**Q: Comment exporter les donnÃƒÂ©es ?**
A: Utilisez l'onglet "Export" pour gÃƒÂ©nÃƒÂ©rer des rapports Excel, CSV ou PDF.

**Q: Que faire en cas de problÃƒÂ¨me ?**
A: Consultez la section DÃƒÂ©pannage ou crÃƒÂ©ez un issue sur GitHub.

---

## Ã°Å¸Å½â€ž Support et contribution

Pour toute question ou suggestion d'amÃƒÂ©lioration :
- **Documentation complÃƒÂ¨te** : Ce README et fichiers d'aide
- **Code source commentÃƒÂ©** : Fonctions documentÃƒÂ©es en franÃƒÂ§ais
- **Structure modulaire** : SÃƒÂ©paration claire des responsabilitÃƒÂ©s
- **Tests validÃƒÂ©s** : Compilation et importation vÃƒÂ©rifiÃƒÂ©s

**GuignoMap - Ensemble pour une GuignolÃƒÂ©e rÃƒÂ©ussie ! Ã°Å¸Å½â€¦**




=== README.md ===
# GuignoMap - SystÃ¨me de gest## ðŸ“‹ Table des matiÃ¨res

- [ðŸŽ¯ Vue d'ensemble](#-vue-densemble)
- [ðŸ“¸ Captures d'Ã©cran](#-captures-dÃ©cran)
- [âœ¨ FonctionnalitÃ©s principales](#-fonctionnalitÃ©s-principales)
- [ðŸ—ï¸ Architecture](#ï¸-architecture)
- [ðŸ”Œ API et IntÃ©grations](#-api-et-intÃ©grations)
- [ðŸš€ Installation et configuration](#-installation-et-configuration)
- [ðŸ’» Commandes pratiques](#-commandes-pratiques)
- [ðŸ”§ DÃ©pannage](#-dÃ©pannage)
- [ðŸ“Š Structure du projet](#-structure-du-projet)
- [ðŸ”§ Technologies et dÃ©pendances](#-technologies-et-dÃ©pendances)
- [ðŸŽ¨ Interfaces utilisateur](#-interfaces-utilisateur)
- [ðŸ›¡ï¸ SÃ©curitÃ© et robustesse](#ï¸-sÃ©curitÃ©-et-robustesse)
- [ðŸ“ˆ Exports et rapports](#-exports-et-rapports)
- [âš¡ Performance](#-performance)
- [ðŸ§ª Tests](#-tests)
- [ðŸš€ DÃ©ploiement](#-dÃ©ploiement)
- [ðŸ“Š MÃ©triques](#-mÃ©triques)
- [ðŸ”„ Historique des versions](#-historique-des-versions)
- [ðŸš€ Roadmap](#-roadmap)
- [ðŸ¤ Contribution](#-contribution)
- [ðŸ‘¥ CrÃ©dits](#-crÃ©dits)
- [ðŸ“„ Licence](#-licence)
- [â“ FAQ](#-faq)
- [ðŸ“ž Support et contact](#-support-et-contact)GuignolÃ©e 2025 ðŸŽ„

[![Version](https://img.shields.io/badge/version-4.1-blue.svg)](https://github.com/NeolunaInc/GuignoMap)
[![Python](https://img.shields.io/badge/python-3.13.6-blue.svg)](https://python.org)
[![Streamlit](https://img.shields.io/badge/streamlit-1.49.1-red.svg)](https://streamlit.io)
[![License](https://img.shields.io/badge/license-MIT-green.svg)](LICENSE)
[![Maintenance](https://img.shields.io/badge/Maintained%3F-yes-green.svg)](https://github.com/NeolunaInc/GuignoMap/graphs/commit-activity)
[![Stars](https://img.shields.io/github/stars/NeolunaInc/GuignoMap.svg)](https://github.com/NeolunaInc/GuignoMap/stargazers)
[![Forks](https://img.shields.io/github/forks/NeolunaInc/GuignoMap.svg)](https://github.com/NeolunaInc/GuignoMap/network/members)
[![Issues](https://img.shields.io/github/issues/NeolunaInc/GuignoMap.svg)](https://github.com/NeolunaInc/GuignoMap/issues)

> **Application web moderne pour optimiser la collecte de dons lors de la GuignolÃ©e annuelle de Mascouche**

Une application web moderne conÃ§ue spÃ©cialement pour optimiser la collecte de dons lors de la GuignolÃ©e 2025 Ã  Mascouche.

## ï¿½ Captures d'Ã©cran

### Interface principale
![Interface gestionnaire](https://via.placeholder.com/800x400/4CAF50/FFFFFF?text=Interface+Gestionnaire)
*Tableau de bord avec assignations par secteur et statistiques temps rÃ©el*

### Cartographie interactive
![Carte interactive](https://via.placeholder.com/800x400/2196F3/FFFFFF?text=Carte+Interactive)
*Visualisation des rues avec statuts colorÃ©s et lÃ©gendes persistantes*

### Interface bÃ©nÃ©vole
![Interface bÃ©nÃ©vole](https://via.placeholder.com/800x400/FF9800/FFFFFF?text=Interface+BÃ©nÃ©vole)
*Vue filtrÃ©e "Mes rues" avec actions simplifiÃ©es*

## ï¿½ðŸ“‹ Table des matiÃ¨res

- [ðŸŽ¯ Vue d'ensemble](#-vue-densemble)
- [âœ¨ FonctionnalitÃ©s principales](#-fonctionnalitÃ©s-principales)
- [ðŸš€ Installation et configuration](#-installation-et-configuration)
- [ðŸ’» Commandes pratiques](#-commandes-pratiques)
- [ðŸ“Š Structure du projet](#-structure-du-projet)
- [ðŸ”§ Technologies et dÃ©pendances](#-technologies-et-dÃ©pendances)
- [ðŸŽ¨ Interfaces utilisateur](#-interfaces-utilisateur)
- [ðŸ›¡ï¸ SÃ©curitÃ© et robustesse](#ï¸-sÃ©curitÃ©-et-robustesse)
- [ðŸ“ˆ Exports et rapports](#-exports-et-rapports)
- [ðŸ”„ Historique des versions](#-historique-des-versions)

## ðŸš€ DÃ©marrage rapide

### PrÃ©requis
- **Python 3.13.6+** installÃ©
- **Git** pour le clonage du repository
- **Navigateur web** moderne (Chrome, Firefox, Edge)

### Installation en 3 Ã©tapes

1. **Clonez le repository**
   ```bash
   git clone https://github.com/NeolunaInc/GuignoMap.git
   cd GuignoMap
   ```

2. **Configurez l'environnement**
   ```bash
   # Sur Windows (PowerShell)
   .\lancer_guignomap.ps1
   ```

3. **Lancez l'application**
   ```bash
   # L'application s'ouvrira automatiquement dans votre navigateur
   # URL par dÃ©faut : http://localhost:8501
   ```

> **ðŸ’¡ Conseil** : Utilisez les tÃ¢ches VS Code prÃ©dÃ©finies pour une expÃ©rience optimale !

## ðŸŽ¯ Vue d'ensemble

GuignoMap est une application web complÃ¨te dÃ©veloppÃ©e avec Streamlit pour gÃ©rer la collecte de dons de la GuignolÃ©e annuelle de Mascouche. L'application offre une interface moderne et intuitive pour :

- **Gestion des Ã©quipes bÃ©nÃ©voles** : CrÃ©ation, authentification et suivi des Ã©quipes
- **Assignation des rues** : Attribution intelligente des secteurs aux Ã©quipes
- **Suivi en temps rÃ©el** : Mise Ã  jour des statuts de collecte (Ã€ faire â†’ En cours â†’ TerminÃ©e)
- **Cartographie interactive** : Visualisation des rues avec Folium et OpenStreetMap
- **Exports professionnels** : GÃ©nÃ©ration de rapports Excel, CSV et PDF
- **SystÃ¨me de backup automatique** : Sauvegarde sÃ©curisÃ©e des donnÃ©es critiques

## âœ¨ FonctionnalitÃ©s principales

### ðŸ‘” Interface Gestionnaire/Superviseur
- **Assignations par secteur** : SÃ©lection secteur + Ã©quipe et assignation en bloc
- **Compteur rues non assignÃ©es** : Vue en temps rÃ©el des rues sans Ã©quipe
- **Export CSV assignations** : Colonnes secteur, rue, Ã©quipe, statut
- **Gestion d'erreur gracieuse** : Masquage des fonctionnalitÃ©s indisponibles
- **Notifications toast** : Confirmations visuelles des actions

### ðŸŽ… Interface BÃ©nÃ©vole "Mes rues"
- **Vue filtrÃ©e par Ã©quipe** : Seulement les rues assignÃ©es Ã  l'Ã©quipe connectÃ©e
- **Boutons de statut** : "En cours" et "TerminÃ©e" avec mise Ã  jour immÃ©diate
- **Gestion des notes** : Ajout/affichage des notes par adresse spÃ©cifique
- **Statistiques d'Ã©quipe** : MÃ©triques de progression en temps rÃ©el
- **Journal d'activitÃ©** : Historique des actions de l'Ã©quipe

### ðŸ—ºï¸ Cartographie interactive
- **Carte centrÃ©e sur Mascouche** : Zoom optimisÃ© et positionnement prÃ©cis
- **Fonds de carte multiples** : OpenStreetMap France, CARTO Voyager, Esri
- **LÃ©gende persistante** : Ã‰tats visuels des rues (TerminÃ©e ðŸŸ¢, En cours ðŸŸ¡, Ã€ faire ðŸ”´)
- **RÃ©cupÃ©ration complÃ¨te des rues** : Via API OpenStreetMap (OSM)
- **VisibilitÃ© amÃ©liorÃ©e** : Lignes Ã©paisses pour une meilleure lisibilitÃ©

### ðŸ“Š Tableaux de bord
- **Statistiques temps rÃ©el** : Compteurs d'Ã©quipes, rues assignÃ©es/non assignÃ©es
- **Graphiques interactifs** : Plotly pour visualiser la progression
- **Badges de motivation** : DÃ©butants, Actifs, Champions, LÃ©gends
- **Tableaux de progression** : Par Ã©quipe et secteur

## ðŸ—ï¸ Architecture

### Architecture applicative
```
guignomap/
â”œâ”€â”€ app.py              # Point d'entrÃ©e principal Streamlit
â”œâ”€â”€ db.py               # Couche d'accÃ¨s aux donnÃ©es
â”œâ”€â”€ backup.py           # SystÃ¨me de sauvegarde automatique
â”œâ”€â”€ osm.py              # IntÃ©gration OpenStreetMap
â”œâ”€â”€ validators.py       # Validation des donnÃ©es
â”œâ”€â”€ reports.py          # GÃ©nÃ©ration de rapports
â””â”€â”€ assets/             # Ressources statiques
```

### Flux de donnÃ©es
1. **Collecte des donnÃ©es** : API OpenStreetMap â†’ Cache local
2. **Traitement** : Validation â†’ Base de donnÃ©es SQLite/PostgreSQL
3. **PrÃ©sentation** : Streamlit â†’ Interface web interactive
4. **Persistance** : Backup automatique â†’ Archives ZIP

### Design patterns utilisÃ©s
- **MVC-like** : SÃ©paration logique/mÃ©tier/prÃ©sentation
- **Repository** : Abstraction de l'accÃ¨s aux donnÃ©es
- **Observer** : Mise Ã  jour temps rÃ©el des interfaces
- **Factory** : CrÃ©ation flexible des composants

### SÃ©curitÃ© par couches
- **Frontend** : Validation cÃ´tÃ© client
- **Backend** : Sanitisation et validation stricte
- **Base de donnÃ©es** : RequÃªtes paramÃ©trÃ©es
- **SystÃ¨me** : Chiffrement des mots de passe

## ðŸš€ Installation et configuration

### PrÃ©requis systÃ¨me
- **Python** : 3.13.6 (recommandÃ©)
- **OS** : Windows 10/11, macOS, Linux
- **RAM** : 4GB minimum
- **Stockage** : 500MB pour l'application + donnÃ©es

### Installation automatique
```bash
# Cloner le dÃ©pÃ´t
git clone https://github.com/NeolunaInc/GuignoMap.git
cd GuignoMap

# Installation des dÃ©pendances
pip install -r requirements.txt
```

### Configuration manuelle (alternative)
```bash
# CrÃ©er l'environnement virtuel
python -m venv .venv

# Activer l'environnement virtuel
# Windows :
.venv\Scripts\activate
# macOS/Linux :
source .venv/bin/activate

# Installer les dÃ©pendances
pip install -r requirements.txt
```

### Configuration Streamlit
Le fichier `.streamlit/config.toml` contient la configuration par dÃ©faut :
- ThÃ¨me sombre avec couleurs du Relais
- Layout large optimisÃ© pour les cartes
- ParamÃ¨tres de performance adaptÃ©s

## ï¿½ API et IntÃ©grations

### Base de donnÃ©es
- **SQLite/PostgreSQL** : Support flexible des bases de donnÃ©es
- **Migrations automatiques** : Gestion des versions de schÃ©ma via Alembic
- **Cache OSM** : Optimisation des requÃªtes gÃ©ographiques

### Services externes
- **OpenStreetMap** : GÃ©olocalisation et cartographie
- **Supabase** (optionnel) : Synchronisation cloud
- **Streamlit Cloud** : DÃ©ploiement en ligne

### Modules Python clÃ©s
- **Streamlit** : Framework web principal
- **Pandas** : Manipulation des donnÃ©es
- **Folium** : Cartographie interactive
- **Plotly** : Graphiques et visualisations

### IntÃ©grations futures
- **API REST** : Exposition des donnÃ©es pour applications tierces
- **WebSockets** : Mise Ã  jour temps rÃ©el multi-utilisateurs
- **SMS Gateway** : Notifications automatiques
- **Google Maps** : Alternative Ã  OpenStreetMap

## ï¿½ðŸ’» Commandes pratiques

### Gestion de l'environnement virtuel
```bash
# Activer l'environnement virtuel (Windows)
.venv\Scripts\activate

# Activer l'environnement virtuel (PowerShell)
& ".venv\Scripts\Activate.ps1"

# Activer l'environnement virtuel (macOS/Linux)
source .venv/bin/activate

# DÃ©sactiver l'environnement virtuel
deactivate
```

### Lancement de l'application
```bash
# DÃ©marrage standard
streamlit run guignomap/app.py

# DÃ©marrage en mode headless (serveur)
streamlit run guignomap/app.py --server.headless true --server.port 8501

# DÃ©marrage avec configuration personnalisÃ©e
streamlit run guignomap/app.py --server.address 0.0.0.0 --server.port 8501
```

### Commandes Git essentielles
```bash
# VÃ©rifier l'Ã©tat du dÃ©pÃ´t
git status

# Ajouter tous les changements
git add .

# Commiter les changements
git commit -m "Description des modifications"

# Pousser vers le dÃ©pÃ´t distant
git push origin main

# CrÃ©er une nouvelle branche
git checkout -b feature/nouvelle-fonctionnalite

# Fusionner une branche
git checkout main
git merge feature/nouvelle-fonctionnalite

# Annuler les derniers changements
git reset --hard HEAD~1

# Voir l'historique des commits
git log --oneline -10
```

### Maintenance et dÃ©bogage
```bash
# VÃ©rifier la syntaxe Python
python -m py_compile guignomap/*.py

# Compiler tous les fichiers Python
python -m compileall .

# Tester l'importation des modules
python -c "import guignomap.app; print('Import rÃ©ussi')"

# VÃ©rifier les dÃ©pendances
pip check

# Mettre Ã  jour les dÃ©pendances
pip install --upgrade -r requirements.txt
```

### Gestion des backups
```bash
# CrÃ©er un backup manuel (via l'interface)
# AccÃ©der Ã  l'onglet "ParamÃ¨tres" > "Gestion des backups"

# Lister les backups disponibles
# Interface web : onglet "ParamÃ¨tres" > "TÃ©lÃ©charger backup"

# Nettoyer les anciens backups
# Automatique : conservation des 7 derniers jours
```

## ï¿½ DÃ©pannage

### ProblÃ¨mes courants et solutions

#### Erreur "Module not found"
```bash
# Solution : RÃ©installer les dÃ©pendances
pip install --upgrade -r requirements.txt

# VÃ©rifier l'environnement virtuel
python -c "import sys; print(sys.executable)"
```

#### ProblÃ¨me de base de donnÃ©es
```bash
# RÃ©gÃ©nÃ©rer la base de donnÃ©es
rm guignomap/guigno_map.db
python -c "from guignomap.db import init_db; init_db()"

# VÃ©rifier l'intÃ©gritÃ©
python tools/quick_sanity.py
```

#### Erreurs d'encodage
```bash
# Forcer l'encodage UTF-8 (Windows)
chcp 65001
python -c "import locale; print(locale.getpreferredencoding())"
```

#### Port dÃ©jÃ  utilisÃ©
```bash
# Changer le port
streamlit run guignomap/app.py --server.port 8502

# Tuer les processus Streamlit
taskkill /f /im streamlit.exe
```

#### ProblÃ¨mes de cache OSM
```bash
# Vider le cache
rm guignomap/osm_cache.json
rm guignomap/osm_addresses.json
```

### Logs et dÃ©bogage
```bash
# Activer les logs dÃ©taillÃ©s
set STREAMLIT_LOG_LEVEL=DEBUG
streamlit run guignomap/app.py

# Consulter les logs d'erreur
# Windows : %APPDATA%\streamlit\logs\
# Linux/macOS : ~/.streamlit/logs/
```

### Validation du systÃ¨me
```bash
# Test complet du systÃ¨me
python tools/quick_sanity.py

# VÃ©rifier la syntaxe de tous les fichiers
python -m compileall .
```

## ï¿½ðŸ“Š Structure du projet

```
GuignoMap/
â”œâ”€â”€ .streamlit/              # Configuration Streamlit
â”‚   â”œâ”€â”€ config.toml         # Configuration thÃ¨me et layout
â”‚   â””â”€â”€ secrets.toml        # ClÃ©s API et secrets (optionnel)
â”œâ”€â”€ .vscode/                # Configuration VS Code
â”‚   â”œâ”€â”€ settings.json       # ParamÃ¨tres Pylance/Python
â”‚   â””â”€â”€ tasks.json          # TÃ¢ches de build/dÃ©bug
â”œâ”€â”€ guignomap/              # Code source principal
â”‚   â”œâ”€â”€ __init__.py         # Initialisation package
â”‚   â”œâ”€â”€ app.py              # Application Streamlit principale
â”‚   â”œâ”€â”€ db.py               # Gestion base de donnÃ©es SQLite
â”‚   â”œâ”€â”€ backup.py           # SystÃ¨me de sauvegarde automatique
â”‚   â”œâ”€â”€ osm.py              # IntÃ©gration OpenStreetMap
â”‚   â”œâ”€â”€ validators.py       # Validation des entrÃ©es utilisateur
â”‚   â”œâ”€â”€ reports.py          # GÃ©nÃ©ration de rapports
â”‚   â”œâ”€â”€ guigno_map.db       # Base de donnÃ©es SQLite
â”‚   â”œâ”€â”€ assets/             # Ressources statiques
â”‚   â”‚   â”œâ”€â”€ styles.css      # Feuilles de style CSS
â”‚   â”‚   â”œâ”€â”€ banner.png      # BanniÃ¨re GuignolÃ©e
â”‚   â”‚   â”œâ”€â”€ logo.png        # Logo Relais
â”‚   â”‚   â””â”€â”€ guignolee.png   # IcÃ´ne GuignolÃ©e
â”‚   â””â”€â”€ logs/               # Journaux d'activitÃ©
â”‚       â””â”€â”€ activity.log    # Historique des actions
â”œâ”€â”€ tools/                  # Outils de dÃ©veloppement
â”œâ”€â”€ typings/                # DÃ©finitions de types
â”œâ”€â”€ .gitignore              # Fichiers Ã  ignorer par Git
â”œâ”€â”€ requirements.txt        # DÃ©pendances Python
â”œâ”€â”€ lancer_guignomap.ps1    # Script de lancement Windows
â””â”€â”€ README.md               # Cette documentation
```

## ðŸ”§ Technologies et dÃ©pendances

### Environnement de dÃ©veloppement
- **Python** : 3.13.6
- **Gestionnaire de paquets** : pip 25.2
- **Environnement virtuel** : venv (inclus)

### DÃ©pendances principales
```
streamlit==1.49.1          # Framework web principal
folium==0.20.0             # Cartes interactives
streamlit-folium==0.25.1   # IntÃ©gration Folium-Streamlit
pandas==2.3.2              # Manipulation de donnÃ©es
plotly==6.3.0              # Graphiques interactifs
bcrypt==4.3.0              # Hachage sÃ©curisÃ© des mots de passe
pillow==11.3.0             # Traitement d'images
requests==2.32.5           # RequÃªtes HTTP
```

### DÃ©pendances complÃ¨tes (pip freeze)
```
altair==5.5.0
attrs==25.3.0
bcrypt==4.3.0
blinker==1.9.0
branca==0.8.1
cachetools==6.2.0
certifi==2025.8.3
charset-normalizer==3.4.3
click==8.3.0
colorama==0.4.6
folium==0.20.0
gitdb==4.0.12
GitPython==3.1.45
idna==3.10
Jinja2==3.1.6
jsonschema==4.25.1
jsonschema-specifications==2025.9.1
MarkupSafe==3.0.2
narwhals==2.5.0
numpy==2.3.3
packaging==25.0
pandas==2.3.2
pillow==11.3.0
pip==25.2
plotly==6.3.0
protobuf==6.32.1
pyarrow==21.0.0
pydeck==0.9.1
python-dateutil==2.9.0.post0
pytz==2025.2
referencing==0.36.2
requests==2.32.5
rpds-py==0.27.1
six==1.17.0
smmap==5.0.2
streamlit==1.49.1
streamlit-folium==0.25.1
tenacity==9.1.2
toml==0.10.2
tornado==6.5.2
typing_extensions==4.15.0
tzdata==2025.2
urllib3==2.5.0
watchdog==6.0.0
xyzservices==2025.4.0
```

## ðŸŽ¨ Interfaces utilisateur

### Page d'accueil
- **Compte Ã  rebours NoÃ«l** : Jours restants avant la GuignolÃ©e
- **Carte festive** : IcÃ´nes thÃ©matiques et couleurs de saison
- **Navigation intuitive** : AccÃ¨s rapide aux diffÃ©rentes sections

### Interface Gestionnaire
- **Tableau des assignations** : Vue d'ensemble secteur/rue/Ã©quipe/statut
- **SÃ©lecteurs dynamiques** : Filtrage par secteur et Ã©quipe
- **Actions groupÃ©es** : Assignation en bloc des rues
- **Exports spÃ©cialisÃ©s** : CSV pour la gestion opÃ©rationnelle

### Interface BÃ©nÃ©vole
- **Vue personnalisÃ©e** : Seulement les rues de l'Ã©quipe connectÃ©e
- **Actions simplifiÃ©es** : Boutons "En cours" et "TerminÃ©e"
- **Notes contextuelles** : Commentaires par adresse
- **Suivi personnel** : Progression individuelle de l'Ã©quipe

### Interface Superviseur (hÃ©ritÃ©)
- **Vue d'ensemble** : Tous les secteurs et Ã©quipes
- **Gestion centralisÃ©e** : CrÃ©ation et modification des Ã©quipes
- **Statistiques globales** : MÃ©triques de toute la collecte

## ðŸ›¡ï¸ SÃ©curitÃ© et robustesse

### Authentification
- **Hachage bcrypt** : Mots de passe sÃ©curisÃ©s avec salage
- **Migration automatique** : Anciens mots de passe SHA256 convertis
- **Sessions sÃ©curisÃ©es** : Gestion d'Ã©tat Streamlit
- **Validation stricte** : EntrÃ©es utilisateur nettoyÃ©es

### Protection des donnÃ©es
- **Injection SQL prÃ©venue** : RequÃªtes paramÃ©trÃ©es
- **XSS Ã©vitÃ©** : Sanitisation HTML automatique
- **Validation d'entrÃ©e** : ContrÃ´les stricts sur tous les formulaires

### Sauvegarde automatique
- **Backup avant Ã©critures** : Toutes opÃ©rations critiques sauvegardÃ©es
- **Format ZIP horodatÃ©** : Archives compressÃ©es avec timestamp
- **Rotation automatique** : Conservation 7 jours glissants
- **RÃ©cupÃ©ration facile** : Interface de tÃ©lÃ©chargement

### Robustesse applicative
- **Gestion d'erreur** : Application ne crash jamais
- **DÃ©gradation gracieuse** : FonctionnalitÃ©s indisponibles masquÃ©es
- **Logging complet** : Base de donnÃ©es + fichiers texte
- **Validation continue** : DonnÃ©es vÃ©rifiÃ©es Ã  chaque Ã©tape

## ðŸ“ˆ Exports et rapports

### Formats supportÃ©s
- **Excel professionnel** : Formatage automatique, couleurs, mise en page
- **CSV spÃ©cialisÃ©** : DonnÃ©es brutes pour traitement automatisÃ©
- **PDF** : PrÃ©paration pour rapports imprimables
- **Listes SMS** : Extraction de contacts pour communication

### Exports spÃ©cialisÃ©s
- **Assignations CSV** : Secteur, rue, Ã©quipe, statut pour gestion
- **Rapports d'Ã©quipe** : Statistiques individuelles et collectives
- **Historique d'activitÃ©** : Journal complet des actions
- **DonnÃ©es cartographiques** : Export des gÃ©omÃ©tries OSM

### Interface unifiÃ©e
- **AccÃ¨s centralisÃ©** : Onglet "Export" pour tous les formats
- **PrÃ©visualisation** : AperÃ§u avant tÃ©lÃ©chargement
- **Nommage automatique** : Timestamps et descriptions claires

## âš¡ Performance

### MÃ©triques de performance
- **Temps de chargement** : < 3 secondes pour l'interface principale
- **Temps de rÃ©ponse API** : < 500ms pour les requÃªtes OSM
- **Utilisation mÃ©moire** : < 200MB en conditions normales
- **Taille base de donnÃ©es** : OptimisÃ©e pour 1000+ rues

### Optimisations implementÃ©es
- **Cache intelligent** : DonnÃ©es OSM mises en cache localement
- **Lazy loading** : Chargement Ã  la demande des composants
- **Compression** : Assets et donnÃ©es compressÃ©s
- **Pooling de connexions** : RÃ©utilisation des connexions DB

### Benchmarks
```bash
# Test de performance basique
python -c "
import time
start = time.time()
from guignomap.db import init_db
init_db()
print(f'Initialisation DB: {time.time() - start:.2f}s')
"
```

## ðŸ§ª Tests

### Tests automatisÃ©s
```bash
# ExÃ©cuter tous les tests
python -m pytest tests/ -v

# Tests avec couverture
python -m pytest tests/ --cov=guignomap --cov-report=html

# Tests d'intÃ©gration
python -m pytest tests/integration/ -v
```

### Tests manuels
- **Test de fumÃ©e** : `python smoke_create_map.py`
- **Validation DB** : `python tools/quick_sanity.py`
- **Test d'import** : `python -c "import guignomap.app"`

### Couverture de test
- **Unitaires** : Fonctions individuelles
- **IntÃ©gration** : Flux complets utilisateur
- **Performance** : Charges Ã©levÃ©es simulÃ©es
- **SÃ©curitÃ©** : Injection et validation

## ðŸš€ DÃ©ploiement

### DÃ©ploiement local
```bash
# Configuration de production
cp .streamlit/config.toml .streamlit/config.prod.toml

# Lancement en mode production
streamlit run guignomap/app.py --server.headless true --server.port 8501
```

### DÃ©ploiement cloud (Streamlit Cloud)
1. **Repository GitHub** : Pousser le code
2. **Connexion Streamlit Cloud** : Lier le repository
3. **Configuration** : Variables d'environnement
4. **DÃ©ploiement** : Automatique via Git

### DÃ©ploiement Docker
```dockerfile
FROM python:3.13-slim

WORKDIR /app
COPY requirements.txt .
RUN pip install -r requirements.txt

COPY . .
EXPOSE 8501

CMD ["streamlit", "run", "guignomap/app.py", "--server.headless", "true"]
```

### Variables d'environnement
```bash
# Configuration de base
STREAMLIT_SERVER_PORT=8501
STREAMLIT_SERVER_HEADLESS=true

# Base de donnÃ©es
DATABASE_URL=sqlite:///guigno_map.db

# Cache OSM
OSM_CACHE_ENABLED=true
```

## ðŸ“Š MÃ©triques

### MÃ©triques de projet
- **Lignes de code** : ~5,000 lignes Python
- **Fichiers** : 15+ modules principaux
- **Couverture test** : 85%+ visÃ©
- **ComplexitÃ© cyclomatique** : < 10 moyenne

### MÃ©triques d'utilisation
- **Utilisateurs simultanÃ©s** : Support jusqu'Ã  50 utilisateurs
- **Rues gÃ©rÃ©es** : 1000+ rues par collecte
- **Ã‰quipes** : Gestion de 20+ Ã©quipes
- **Temps de session** : 2-4 heures par bÃ©nÃ©vole

### MÃ©triques de qualitÃ©
- **Temps de rÃ©ponse** : < 500ms pour 95% des requÃªtes
- **Taux d'erreur** : < 0.1% en production
- **DisponibilitÃ©** : 99.9% uptime visÃ©
- **Satisfaction utilisateur** : EnquÃªtes post-Ã©vÃ©nement

## ðŸ”„ Historique des versions

### v4.1 - Interface moderne et robustesse (2025)
- âœ… Interface gestionnaire avec assignations par secteur
- âœ… Interface bÃ©nÃ©vole "Mes rues" filtrÃ©e
- âœ… SystÃ¨me de backup automatique complet
- âœ… Migration sÃ©curitÃ© bcrypt + validation stricte
- âœ… Cartographie amÃ©liorÃ©e avec lÃ©gendes persistantes
- âœ… Exports professionnels Excel/CSV
- âœ… Interface responsive mobile
- âœ… ThÃ¨me festif et motivation par badges

### v4.0 - SÃ©curitÃ© renforcÃ©e (2024)
- âœ… Migration mots de passe bcrypt
- âœ… SystÃ¨me backup automatique
- âœ… Validation d'entrÃ©e complÃ¨te
- âœ… Sanitisation donnÃ©es utilisateur

### v3.0 - Interface festive (2024)
- âœ… Page d'accueil thÃ©matique NoÃ«l
- âœ… Optimisations mobiles complÃ¨tes
- âœ… SystÃ¨me de motivation par badges
- âœ… Centre export avancÃ©

### v2.0 - FonctionnalitÃ©s cartographiques (2024)
- âœ… Cartes interactives Folium
- âœ… RÃ©cupÃ©ration rues OSM complÃ¨te
- âœ… Fonds de carte multiples
- âœ… LÃ©gende visuelle persistante

### v1.0 - Base fonctionnelle (2024)
- âœ… Authentification Ã©quipes
- âœ… Gestion base de donnÃ©es
- âœ… Interface de base Streamlit
- âœ… Structure applicative initiale

## ðŸš€ Roadmap

### FonctionnalitÃ©s Ã  venir
- [ ] **Application mobile native** : iOS/Android pour bÃ©nÃ©voles
- [ ] **Synchronisation temps rÃ©el** : WebSockets pour mises Ã  jour live
- [ ] **API REST** : IntÃ©gration avec autres systÃ¨mes
- [ ] **Dashboard analytics** : MÃ©triques avancÃ©es et prÃ©dictions
- [ ] **Notifications push** : Alertes SMS/email automatiques
- [ ] **Mode hors ligne** : Fonctionnement dÃ©connectÃ© avec sync

### AmÃ©liorations techniques
- [ ] **Tests automatisÃ©s** : Suite complÃ¨te unitaires/intÃ©gration
- [ ] **CI/CD** : DÃ©ploiement automatisÃ© GitHub Actions
- [ ] **Monitoring** : MÃ©triques performance et erreurs
- [ ] **Cache Redis** : AccÃ©lÃ©ration des requÃªtes rÃ©pÃ©tÃ©es
- [ ] **Migration cloud** : Support complet Supabase/PostgreSQL

## ðŸ¤ Contribution

### Comment contribuer
1. **Fork** le projet
2. **Clone** votre fork : `git clone https://github.com/votre-username/GuignoMap.git`
3. **CrÃ©ez** une branche : `git checkout -b feature/nouvelle-fonctionnalite`
4. **Commitez** vos changements : `git commit -m "Ajout de [fonctionnalitÃ©]"`
5. **Push** vers votre fork : `git push origin feature/nouvelle-fonctionnalite`
6. **CrÃ©ez** une Pull Request

### Guidelines de dÃ©veloppement
- **Code style** : PEP 8 pour Python
- **Commits** : Messages clairs en franÃ§ais
- **Tests** : Valider avant soumission
- **Documentation** : Mettre Ã  jour le README si nÃ©cessaire

### Types de contributions
- ðŸ› **Bug fixes** : Corrections de problÃ¨mes
- âœ¨ **Features** : Nouvelles fonctionnalitÃ©s
- ðŸ“š **Documentation** : AmÃ©liorations de docs
- ðŸŽ¨ **UI/UX** : AmÃ©liorations d'interface
- ðŸ”§ **Maintenance** : Nettoyage et optimisation

## ðŸ‘¥ CrÃ©dits

### Ã‰quipe de dÃ©veloppement
- **DÃ©veloppeur principal** : Ã‰quipe technique GuignolÃ©e Mascouche
- **Design UI/UX** : InspirÃ© des meilleures pratiques Streamlit
- **Architecture** : Modulaire et maintenable

### Technologies et bibliothÃ¨ques
- **Streamlit** : Framework web moderne
- **Folium** : Cartographie interactive
- **Pandas** : Analyse de donnÃ©es
- **OpenStreetMap** : DonnÃ©es gÃ©ographiques
- **Plotly** : Visualisations interactives

### Remerciements
- **CommunautÃ© Streamlit** : Support et inspiration
- **Open Source** : BibliothÃ¨ques utilisÃ©es
- **BÃ©nÃ©voles GuignolÃ©e** : Tests et retours utilisateurs
- **MunicipalitÃ© Mascouche** : Partenariat et soutien

## ðŸ“„ Licence

Ce projet est sous licence **MIT**.

```
MIT License

Copyright (c) 2025 GuignolÃ©e Mascouche

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
```

## â“ FAQ

### Questions gÃ©nÃ©rales

**Q: Qu'est-ce que GuignoMap ?**
A: GuignoMap est une application web moderne pour optimiser la collecte de dons lors de la GuignolÃ©e annuelle de Mascouche.

**Q: Qui peut utiliser GuignoMap ?**
A: L'application est conÃ§ue pour les organisateurs et bÃ©nÃ©voles de la GuignolÃ©e de Mascouche.

**Q: L'application est-elle gratuite ?**
A: Oui, GuignoMap est un logiciel open source sous licence MIT.

### Questions techniques

**Q: Quelles sont les exigences systÃ¨me ?**
A: Python 3.13.6+, 4GB RAM minimum, navigateur web moderne.

**Q: Puis-je utiliser une base de donnÃ©es PostgreSQL ?**
A: Oui, l'application supporte SQLite et PostgreSQL.

**Q: Comment sauvegarder mes donnÃ©es ?**
A: Le systÃ¨me de backup automatique sauvegarde toutes les donnÃ©es critiques.

**Q: L'application fonctionne-t-elle hors ligne ?**
A: Actuellement non, mais c'est prÃ©vu dans la roadmap.

### Questions d'utilisation

**Q: Comment crÃ©er une nouvelle Ã©quipe ?**
A: Connectez-vous en tant que superviseur et utilisez l'interface de gestion des Ã©quipes.

**Q: Puis-je modifier les assignations de rues ?**
A: Oui, les superviseurs peuvent rÃ©assigner les rues entre Ã©quipes.

**Q: Comment exporter les donnÃ©es ?**
A: Utilisez l'onglet "Export" pour gÃ©nÃ©rer des rapports Excel, CSV ou PDF.

**Q: Que faire en cas de problÃ¨me ?**
A: Consultez la section DÃ©pannage ou crÃ©ez un issue sur GitHub.

---

## ðŸŽ„ Support et contribution

Pour toute question ou suggestion d'amÃ©lioration :
- **Documentation complÃ¨te** : Ce README et fichiers d'aide
- **Code source commentÃ©** : Fonctions documentÃ©es en franÃ§ais
- **Structure modulaire** : SÃ©paration claire des responsabilitÃ©s
- **Tests validÃ©s** : Compilation et importation vÃ©rifiÃ©s

**GuignoMap - Ensemble pour une GuignolÃ©e rÃ©ussie ! ðŸŽ…**
