================================================================================
                    GUIGNO-MAP - EXPORT CODE COMPLET POUR AUDIT
                           Le Relais de Mascouche - v3.5
================================================================================

================================================================================
FICHIER: .gitignore
================================================================================
# ===============================================
# GITIGNORE POUR GUIGNO-MAP
# ===============================================

# ----------------------------------------
# ENVIRONNEMENTS PYTHON
# ----------------------------------------
.venv/
venv/
env/
ENV/
__pycache__/
*.pyc
*.pyo
*.pyd
.Python
pip-log.txt
pip-delete-this-directory.txt

# ----------------------------------------
# BASES DE DONNÃ‰ES
# ----------------------------------------
*.db
*.sqlite
*.sqlite3
guigno_map.db

# ----------------------------------------
# CACHES & DONNÃ‰ES TEMPORAIRES
# ----------------------------------------
osm_cache.json
*.cache
*.tmp
.DS_Store
Thumbs.db

# ----------------------------------------
# LOGS & EXPORTS
# ----------------------------------------
*.log
export_*.txt
rapport_*.csv

# ----------------------------------------
# VS CODE & Ã‰DITEURS
# ----------------------------------------
.vscode/
*.swp
*.swo
*~

# ----------------------------------------
# SYSTÃˆME WINDOWS/LINUX
# ----------------------------------------
*.Zone.Identifier
.Trash-*
Desktop.ini

# ----------------------------------------
# DÃ‰PENDANCES NODE (si ajoutÃ©es plus tard)
# ----------------------------------------
node_modules/
npm-debug.log*

# ----------------------------------------
# STREAMLIT
# ----------------------------------------
.streamlit/secrets.toml

# ----------------------------------------
# DONNÃ‰ES SENSIBLES
# ----------------------------------------
*.key
*.pem
.env
config.ini

# ----------------------------------------
# FICHIERS DE SAUVEGARDE
# ----------------------------------------
*.bak
*.backup
*.save
*~

# ----------------------------------------
# KEEP THESE FILES (exceptions)
# ----------------------------------------
!.streamlit/config.toml
!guignomap/assets/
!requirements.txt
!README.md



================================================================================
FICHIER: README.md
================================================================================
# GuignoMap - SystÃ¨me de gestion pour la GuignolÃ©e 2025 ğŸ„

Une application web moderne conÃ§ue spÃ©cialement pour optimiser la collecte de dons lors de la GuignolÃ©e 2025 Ã  Mascouche.

## âœ¨ Nouvelles fonctionnalitÃ©s v3.0

### ğŸ„ Interface festive
- **Page d'accueil moderne** avec compte Ã  rebours vers NoÃ«l
- **En-tÃªte festif** aux couleurs de la GuignolÃ©e 2025
- **Carte de NoÃ«l thÃ©matique** avec icÃ´nes festives

### ğŸ“± Optimisations mobiles
- **Interface responsive** optimisÃ©e pour tous les appareils
- **Navigation tactile** adaptÃ©e aux smartphones
- **ContrÃ´les de carte** optimisÃ©s pour mobile

### ğŸ† SystÃ¨me de motivation
- **Badges d'Ã©quipe** : DÃ©butants, Actifs, Champions, LÃ©gendes
- **Notifications temps rÃ©el** pour les accomplissements
- **Tableaux de bord interactifs** avec graphiques Plotly

### ğŸ“Š Centre d'export avancÃ©
- **Export Excel professionnel** avec formatage automatique
- **GÃ©nÃ©ration de listes SMS** pour la communication d'Ã©quipe
- **Export PDF** (prÃ©paration)
- **Rapports dÃ©taillÃ©s** par Ã©quipe et secteur

### ğŸ—ºï¸ AmÃ©liorations cartographiques
- **Choix de fonds de carte** : OpenStreetMap France, CARTO Voyager, Esri
- **Zoom optimisÃ©** centrÃ© sur Mascouche
- **Zone d'affichage agrandie** : 90% de l'Ã©cran sur PC
- **Gestion d'erreur robuste** : secrets.toml optionnel
- **VisibilitÃ© amÃ©liorÃ©e** des rues avec lignes plus Ã©paisses
- **RÃ©cupÃ©ration complÃ¨te** de toutes les rues via OSM

### ğŸ‘¥ Gestion moderne
- **Terminologie unifiÃ©e** : "gestionnaire" au lieu de "superviseur"
- **Navigation sidebar** moderne et intuitive
- **Interface bÃ©nÃ©vole restreinte** aux rues assignÃ©es seulement
- **Authentification simplifiÃ©e** avec cartes de connexion

## ğŸš€ Installation et utilisation

### PrÃ©requis
- Python 3.8+
- AccÃ¨s internet pour OSM et les tuiles de carte

### Installation
```bash
git clone https://github.com/votre-repo/GuignoMap.git
cd GuignoMap
pip install -r requirements.txt
```

### Lancement
```bash
cd guignomap
streamlit run app.py
```

## ğŸ“¦ DÃ©pendances principales

- **streamlit** : Interface web moderne
- **folium** : Cartes interactives
- **pandas** : Manipulation des donnÃ©es
- **overpy** : API OpenStreetMap
- **plotly** : Graphiques interactifs
- **xlsxwriter** : Export Excel professionnel

## ğŸ¯ FonctionnalitÃ©s principales

### Pour les bÃ©nÃ©voles
- ğŸ—ºï¸ **Carte interactive** avec leurs rues assignÃ©es uniquement
- âœ… **SystÃ¨me de validation** rue par rue avec notes
- ğŸ† **Badges de progression** et encouragements
- ï¿½ **Interface mobile** optimisÃ©e

### Pour les gestionnaires
- ğŸ“Š **Tableau de bord complet** avec KPIs temps rÃ©el
- ï¿½ï¸ **Vue d'ensemble** de toutes les Ã©quipes
- ğŸ“ˆ **Graphiques de progression** par Plotly
- ï¿½ **Centre d'export** avec formats multiples
- ğŸ‘¥ **Gestion des Ã©quipes** et assignation
- ï¿½ **Notifications** d'activitÃ©

### DonnÃ©es et exports
- ğŸ“ **Base de donnÃ©es SQLite** intÃ©grÃ©e
- ğŸ“Š **Export Excel** avec formatage professionnel
- ğŸ“± **Listes SMS** pour communication
- ğŸ“„ **Rapports PDF** (en dÃ©veloppement)
source .venv/bin/activate

## ğŸ—ƒï¸ Structure du projet

```
GuignoMap/
â”œâ”€â”€ guignomap/
â”‚   â”œâ”€â”€ app.py              # Application principale Streamlit
â”‚   â”œâ”€â”€ db.py               # Gestion base de donnÃ©es
â”‚   â”œâ”€â”€ osm.py              # Interface OpenStreetMap
â”‚   â”œâ”€â”€ guigno_map.db       # Base de donnÃ©es SQLite
â”‚   â”œâ”€â”€ osm_cache.json      # Cache des donnÃ©es OSM
â”‚   â”œâ”€â”€ streets_mascouche.csv # DonnÃ©es des rues
â”‚   â””â”€â”€ assets/
â”‚       â”œâ”€â”€ banner.png      # BanniÃ¨re GuignolÃ©e
â”‚       â”œâ”€â”€ logo.png        # Logo officiel
â”‚       â””â”€â”€ styles.css      # Styles personnalisÃ©s
â”œâ”€â”€ requirements.txt        # DÃ©pendances Python
â””â”€â”€ README.md              # Documentation
```

## ğŸ„ ThÃ¨me GuignolÃ©e 2025

L'application adopte une identitÃ© visuelle festive pour l'Ã©dition 2025 :
- **Couleurs** : Rouge festif (#dc3545), vert sapin, or
- **Typographie** : Poppins pour une lecture moderne
- **IcÃ´nes** : ThÃ¨me de NoÃ«l et solidaritÃ©
- **Animations** : Compte Ã  rebours dynamique vers NoÃ«l

## ï¿½ Statistiques temps rÃ©el

Le systÃ¨me suit automatiquement :
- Progression globale de la collecte
- Performance par Ã©quipe et bÃ©nÃ©vole
- Couverture gÃ©ographique
- Tendances et objectifs

## ğŸ” SÃ©curitÃ© et accÃ¨s

- **Authentification** par nom d'Ã©quipe
- **Restriction d'accÃ¨s** : bÃ©nÃ©voles limitÃ©s Ã  leurs rues
- **DonnÃ©es locales** : pas de transmission externe
- **Sauvegarde automatique** des progressions

## ğŸ¤ Contribution

GuignoMap est dÃ©veloppÃ© pour la GuignolÃ©e de Mascouche. Pour toute suggestion ou amÃ©lioration, contactez l'Ã©quipe organisatrice.

---

**Joyeuses FÃªtes et bonne GuignolÃ©e 2025 ! ğŸ„ğŸ**
2. **Consultez votre liste** de rues assignÃ©es
3. **Commencez une rue** :
   - SÃ©lectionnez la rue dans la liste
   - Changez le statut de "Ã€ faire" Ã  "En cours"
4. **Pendant la collecte** :
   - Ajoutez des notes pour les adresses spÃ©ciales
   - Ex: "145 - Famille absente, denrÃ©es dÃ©posÃ©es"
5. **Terminez la rue** :
   - Une fois la rue complÃ¨te, changez le statut Ã  "TerminÃ©e"
6. **Passez Ã  la rue suivante**

### ğŸ†˜ Que faire si...

#### â“ **Je ne vois pas mes rues**
- VÃ©rifiez que vous Ãªtes connectÃ© comme bÃ©nÃ©vole
- Demandez au superviseur si des rues vous ont Ã©tÃ© assignÃ©es

#### â“ **Je ne peux pas me connecter**
- VÃ©rifiez votre code d'Ã©quipe et mot de passe
- Contactez le superviseur pour confirmation

#### â“ **La carte ne s'affiche pas**
- Actualisez la page (F5)
- Le superviseur peut reconstruire les donnÃ©es dans l'onglet Tech

#### â“ **Je veux voir toute la ville**
- Seuls les superviseurs voient toute la carte
- Les bÃ©nÃ©voles ne voient que leurs rues assignÃ©es

### ğŸ’¡ Conseils pratiques

#### Pour les **superviseurs** :
- CrÃ©ez les Ã©quipes AVANT d'assigner des rues
- Assignez des secteurs logiques (ex: mÃªme quartier)
- Consultez rÃ©guliÃ¨rement l'onglet "Vue d'ensemble" pour le suivi
- Exportez les donnÃ©es Ã  la fin pour les rapports

#### Pour les **bÃ©nÃ©voles** :
- Changez le statut dÃ¨s que vous commencez une rue
- Ajoutez des notes pour les situations particuliÃ¨res
- N'oubliez pas de marquer "TerminÃ©e" quand c'est fini
- Utilisez l'auto-refresh pour voir les mises Ã  jour des autres Ã©quipes

### ğŸ¨ Interface rapide
- **Menu gauche** : Navigation principale
- **Carte centrale** : Vue gÃ©ographique avec couleurs
- **LÃ©gende en bas Ã  droite** : Explication des couleurs et statistiques
- **Auto-refresh** : Active le rafraÃ®chissement automatique toutes les 15 secondes

## ğŸ” Connexion

### Superviseur
- **Portail** : ğŸ¯ Superviseur
- **Mot de passe** : `admin123`
- **Fonctions** : Gestion complÃ¨te + opÃ©rations techniques

### BÃ©nÃ©voles
- **Portail** : ğŸ‘¥ BÃ©nÃ©vole
- **Identifiants** : CrÃ©Ã©s par le superviseur

## ğŸ“ Structure du projet

```
GuignoMap/
â”œâ”€â”€ guignomap/
â”‚   â”œâ”€â”€ app.py              # Application principale
â”‚   â”œâ”€â”€ db.py               # Gestion base de donnÃ©es robuste
â”‚   â”œâ”€â”€ osm.py              # IntÃ©gration OpenStreetMap + adresses
â”‚   â”œâ”€â”€ guigno_map.db       # Base SQLite
â”‚   â”œâ”€â”€ osm_cache.json      # Cache gÃ©omÃ©tries
â”‚   â”œâ”€â”€ osm_addresses.json  # Cache adresses OSM
â”‚   â””â”€â”€ assets/
â”‚       â”œâ”€â”€ styles.css      # Styles personnalisÃ©s
â”‚       â”œâ”€â”€ logo.png        # Logo du Relais
â”‚       â””â”€â”€ banner.png      # BanniÃ¨re (optionnel)
â”œâ”€â”€ .streamlit/
â”‚   â””â”€â”€ config.toml         # Configuration Streamlit
â”œâ”€â”€ requirements.txt        # DÃ©pendances Python
â””â”€â”€ README.md              # Documentation
```

## ğŸ› ï¸ Technologies

- **Frontend** : Streamlit + CSS personnalisÃ©
- **Backend** : Python + SQLite avec gestion d'erreurs
- **Cartes** : Folium + OpenStreetMap + API Overpass
- **DonnÃ©es** : Pandas + Overpy avec validation robuste

## ğŸ“Š FonctionnalitÃ©s dÃ©taillÃ©es

### Pour les Superviseurs
- Vue d'ensemble avec carte complÃ¨te de Mascouche
- Gestion des Ã©quipes avec crÃ©ation/suppression
- Assignation intelligente des rues
- Export des rapports (rues + notes)
- **Onglet Tech** protÃ©gÃ© par PIN pour :
  - Reconstruction du cache gÃ©omÃ©trique OSM
  - Import/mise Ã  jour des adresses depuis OSM
  - Gestion d'erreurs avancÃ©e avec fallback
- Visualisation complÃ¨te : autoroutes, rues principales, voies privÃ©es
- Statistiques en temps rÃ©el avec compteurs dynamiques

### Pour les BÃ©nÃ©voles
- Interface dÃ©diÃ©e Ã  leur tournÃ©e assignÃ©e
- Ajout de notes par adresse civique
- Mise Ã  jour du statut des rues (Ã  faire â†’ en cours â†’ terminÃ©e)
- Consultation des notes existantes
- Carte centrÃ©e sur leur zone de travail
- Ajout de notes par adresse
- Mise Ã  jour du statut des rues
- Suivi en temps rÃ©el
- Carte centrÃ©e automatiquement sur la zone de travail
- Interface fluide avec rechargement intelligent des donnÃ©es
- **VisibilitÃ© totale** des voies de collecte (y compris voies privÃ©es)

## ğŸ¨ ThÃ¨me visuel

Interface moderne aux couleurs du **Relais de Mascouche** :
- Rouge bordeaux (#8B0000)
- Or (#FFD700)
- Design responsive
- Animations fluides

### LÃ©gende de la carte amÃ©liorÃ©e
- ğŸŸ¢ **Vert** : Rues terminÃ©es
- ï¿½ **Orange** : Rues en cours
- ğŸ”´ **Rouge** : Rues Ã  faire
- **Lignes pleines** : Rues assignÃ©es Ã  une Ã©quipe
- **Lignes pointillÃ©es** : Rues non assignÃ©es
- **Compteurs dynamiques** : Total, assignÃ©es, non assignÃ©es
- **Marqueur centre-ville** : Point de rÃ©fÃ©rence Mascouche

## ğŸš§ DÃ©veloppement

### Base de donnÃ©es renforcÃ©e
- Tables : `streets`, `teams`, `notes`, `activity_log`, `addresses`
- Import automatique depuis OpenStreetMap avec validation
- Gestion d'erreurs et crÃ©ation automatique des rues manquantes
- DonnÃ©es de test intÃ©grÃ©es et fallback robuste

### SystÃ¨me OSM rÃ©volutionnaire v3.1
- **Couverture maximale** : TOUTES les voies nommÃ©es + autoroutes (ref)
- **RequÃªte optimisÃ©e** : `highway+name OU highway+ref`
- **Cache multi-niveaux** : gÃ©omÃ©tries + adresses OSM
- **Fallback Ã©tendu** : 19 voies principales de Mascouche
- **Gestion d'erreurs** : validation, retry, rÃ©cupÃ©ration automatique
- **Import adresses** : numÃ©ros civiques avec tri intelligent
- **Performance** : cache Streamlit sensible aux modifications

### Couverture des voies complÃ¨te
- ğŸ›£ï¸ **Autoroutes** : A-25, A-640 (via ref)
- ğŸ˜ï¸ **Voies principales** : MontÃ©e Masson, Chemin Sainte-Marie
- ğŸš— **Voies rÃ©sidentielles** : toutes les rues nommÃ©es
- ğŸ  **Voies d'accÃ¨s** : service, private roads
- ğŸ”š **Impasses et allÃ©es** : couverture totale
- âœ… **Inclusions** : TOUT sauf limitation technique OSM

### AmÃ©liorations critiques v3.1
- **ğŸ› Fix create_map()** : Gestion robuste des colonnes DataFrame
- **ğŸ”§ Fix build_addresses_cache()** : Validation types et tri intelligent  
- **ğŸ›¡ï¸ Fix import_addresses_from_cache()** : CrÃ©ation automatique des rues
- **âš¡ Fix list_streets()** : COALESCE pour Ã©viter les NULL
- **ğŸ¯ UI amÃ©liorÃ©e** : Limites gÃ©ographiques et zoom adaptatif
- **ğŸ“Š Statistiques** : Compteurs en temps rÃ©el dans la lÃ©gende

### Architecture technique
- **Frontend** : Streamlit avec gestion d'erreur globale
- **GÃ©olocalisation** : API Overpass OSM avec requÃªte universelle
- **DonnÃ©es** : SQLite + cache JSON double (gÃ©o + adresses)
- **Couverture** : SystÃ¨me d'inclusion universelle (name + ref)
- **Robustesse** : Fallback Ã  tous les niveaux avec validation

## ğŸ“ Changelog v3.3

### ğŸ„ ThÃ¨me GuignolÃ©e festif
- **Header moderne** : Design spÃ©cial GuignolÃ©e 2025 avec dÃ©gradÃ© rouge/vert
- **Animations** : Flocons de neige CSS pour ambiance festive
- **Branding** : "ğŸ… GUIGNOLÃ‰E 2025 ğŸ" avec police Manrope
- **Stats temps rÃ©el** : Progression visible directement dans le header
- **Support logo** : DÃ©tection automatique du logo GuignolÃ©e

### ğŸ–¼ï¸ Sidebar avec logo intÃ©grÃ©
- **Logo professionnel** : Espace dÃ©diÃ© 200px en haut de sidebar
- **Positionnement optimal** : CollÃ© au bord supÃ©rieur sans espace vide
- **Fallback Ã©lÃ©gant** : Placeholder festif avec dÃ©gradÃ© GuignolÃ©e si logo absent
- **Navigation moderne** : Boutons stylisÃ©s Accueil/BÃ©nÃ©vole/Gestionnaire
- **Branding complet** : CohÃ©rence visuelle avec header festif

### ğŸ¨ Effets de connexion festifs
- **Connexion bÃ©nÃ©vole** : Effet neige (`st.snow()`) pour ambiance hivernale
- **Connexion gestionnaire** : Effet neige unifiÃ© pour cohÃ©rence thÃ©matique
- **Messages personnalisÃ©s** : Accueil par Ã©quipe avec design festif

## ğŸ“ Changelog v3.2

### ğŸ—ºï¸ AmÃ©liorations cartographiques majeures
- **Fonds multiples** : OSM France (dÃ©taillÃ©), CARTO Voyager (moderne), Esri WorldStreetMap (professionnel)
- **SÃ©lecteur de couches** : ContrÃ´le dynamique pour changer de fond Ã  la volÃ©e
- **Zoom optimisÃ©** : zoom_start=13 pour meilleur cadrage de Mascouche
- **Performances** : prefer_canvas=True pour rendu fluide + contrÃ´les complets
- **VisibilitÃ©** : weight 7/5 et opacity 0.9/0.7 pour meilleure lisibilitÃ©
- **Navigation** : zoom_control et scrollWheelZoom activÃ©s

### ğŸ¯ Interface utilisateur
- **Terminologie** : "Code" â†’ "Identifiant", "Nom" â†’ "Ã‰quipe" pour clartÃ©
- **UX** : AmÃ©lioration comprÃ©hension des champs par les utilisateurs

## ğŸ“ Changelog v3.1

### ğŸ”§ Corrections critiques
- **create_map()** : Gestion robuste colonnes pandas + limites gÃ©ographiques
- **build_addresses_cache()** : Tri numÃ©rique intelligent + gestion d'erreurs
- **import_addresses_from_cache()** : Validation + crÃ©ation automatique rues
- **list_streets()** : COALESCE pour colonnes NULL + structure garantie
- **RequÃªte OSM** : Inclusion autoroutes via ref + couverture maximale

### âœ¨ Nouvelles fonctionnalitÃ©s  
- **Carte centrÃ©e Mascouche** : Bounds gÃ©ographiques + zoom adaptatif
- **LÃ©gende avancÃ©e** : Statistiques temps rÃ©el + compteurs dynamiques
- **Marqueur centre-ville** : Point de rÃ©fÃ©rence visuel
- **Fallback Ã©tendu** : 19 voies principales + autoroutes
- **Gestion d'erreurs** : Messages informatifs + rÃ©cupÃ©ration automatique

## ğŸ“ Support

DÃ©veloppÃ© pour **Le Relais de Mascouche** - Collecte de denrÃ©es 2025

---
*Version 3.4 - Interface sidebar complÃ¨te avec logo intÃ©grÃ© et effets festifs*



================================================================================
FICHIER: requirements.txt
================================================================================
streamlit==1.36.0
pandas==2.2.2
folium==0.17.0
streamlit-folium==0.21.0
overpy==0.7
plotly==5.18.0


================================================================================
FICHIER: guignomap/__init__.py
================================================================================



================================================================================
FICHIER: guignomap/app.py
================================================================================
"""
Guigno-Map - Application de gestion de collecte de denrÃ©es
Le Relais de Mascouche
Version 3.0 - Production
"""

from pathlib import Path
import time
from datetime import datetime
import pandas as pd
import streamlit as st
import folium
from streamlit_folium import st_folium

# Import des modules locaux
import db
from osm import build_geometry_cache, load_geometry_cache, build_addresses_cache, load_addresses_cache, CACHE_FILE

# Configuration des chemins
DB_PATH = Path(__file__).parent / "guigno_map.db"
ASSETS = Path(__file__).parent / "assets"

# Configuration Streamlit
st.set_page_config(
    page_title="Guigno-Map | Relais de Mascouche",
    page_icon="ğŸ",
    layout="wide",
    initial_sidebar_state="expanded"
)

# Initialisation session
if "auth" not in st.session_state:
    st.session_state.auth = None

# ============================================
# COMPOSANTS UI
# ============================================

def inject_css():
    """Charge le CSS depuis le fichier externe"""
    css_file = ASSETS / "styles.css"
    if css_file.exists():
        css = css_file.read_text(encoding="utf-8")
        st.markdown(f"<style>{css}</style>", unsafe_allow_html=True)

def render_header():
    """Header moderne avec logo GuignolÃ©e et design festif"""
    
    # Container principal avec fond festif
    st.markdown("""
    <div style="
        background: linear-gradient(135deg, #c41e3a 0%, #165b33 100%);
        border-radius: 20px;
        padding: 2rem;
        margin-bottom: 2rem;
        position: relative;
        overflow: hidden;
        box-shadow: 0 10px 30px rgba(0,0,0,0.3);
    ">
        <!-- Flocons de neige animÃ©s en CSS -->
        <div style="position: absolute; width: 100%; height: 100%; opacity: 0.1;">
            <span style="position: absolute; top: 10%; left: 10%; font-size: 2rem;">â„ï¸</span>
            <span style="position: absolute; top: 20%; left: 80%; font-size: 1.5rem;">â„ï¸</span>
            <span style="position: absolute; top: 60%; left: 30%; font-size: 1.8rem;">â„ï¸</span>
        </div>
    """, unsafe_allow_html=True)
    
    col1, col2, col3 = st.columns([2, 5, 2])
    
    with col1:
        # Logo GuignolÃ©e
        if (ASSETS / "guignolee.png").exists():
            st.image(str(ASSETS / "guignolee.png"), width=150)
    
    with col2:
        st.markdown("""
        <div style="text-align: center;">
            <h1 style="
                color: white;
                font-family: 'Manrope', sans-serif;
                font-size: 2.5rem;
                margin: 0;
                text-shadow: 3px 3px 6px rgba(0,0,0,0.5);
                letter-spacing: 2px;
            ">ğŸ… GUIGNOLÃ‰E 2025 ğŸ</h1>
            <p style="
                color: #FFD700;
                font-size: 1.2rem;
                margin: 0.5rem 0 0 0;
                font-weight: 600;
            ">Le Relais de Mascouche - 1er dÃ©cembre</p>
            <p style="
                color: rgba(255,255,255,0.9);
                font-size: 1rem;
                margin-top: 0.5rem;
            ">SystÃ¨me de gestion de collecte</p>
        </div>
        """, unsafe_allow_html=True)
    
    with col3:
        # Stats en temps rÃ©el
        stats = db.extended_stats(st.session_state.get('conn'))
        progress = (stats['done'] / stats['total'] * 100) if stats['total'] > 0 else 0
        
        st.markdown(f"""
        <div style="
            background: rgba(255,255,255,0.2);
            border-radius: 15px;
            padding: 1rem;
            text-align: center;
        ">
            <div style="color: #FFD700; font-size: 2rem; font-weight: bold;">
                {progress:.0f}%
            </div>
            <div style="color: white; font-size: 0.9rem;">
                ComplÃ©tÃ©
            </div>
        </div>
        """, unsafe_allow_html=True)
    
    st.markdown("</div>", unsafe_allow_html=True)

def render_login_card(role="benevole", conn=None):
    """Carte de connexion moderne avec design festif"""
    
    # Container de connexion stylisÃ©
    st.markdown("""
    <div style="
        max-width: 400px;
        margin: 3rem auto;
        background: linear-gradient(135deg, rgba(255,255,255,0.1), rgba(255,255,255,0.05));
        backdrop-filter: blur(10px);
        border: 2px solid rgba(255,215,0,0.3);
        border-radius: 20px;
        padding: 2rem;
        box-shadow: 0 20px 40px rgba(0,0,0,0.3);
    ">
    """, unsafe_allow_html=True)
    
    # IcÃ´ne et titre
    if role == "superviseur" or role == "gestionnaire":
        st.markdown("""
        <div style="text-align: center; margin-bottom: 2rem;">
            <div style="font-size: 3rem;">ğŸ‘”</div>
            <h2 style="color: #FFD700; margin: 1rem 0;">Espace Gestionnaire</h2>
            <p style="color: #cbd5e1;">GÃ©rez la collecte et les Ã©quipes</p>
        </div>
        """, unsafe_allow_html=True)
        
        with st.form("login_gestionnaire", clear_on_submit=False):
            password = st.text_input(
                "ğŸ” Mot de passe",
                type="password",
                placeholder="Entrez le mot de passe gestionnaire"
            )
            
            col1, col2, col3 = st.columns([1,2,1])
            with col2:
                submit = st.form_submit_button(
                    "ğŸš€ Connexion",
                    use_container_width=True
                )
            
            if submit:
                if db.verify_team(conn, "ADMIN", password):
                    st.session_state.auth = {"role": "supervisor", "team_id": "ADMIN"}
                    st.success("âœ… Bienvenue dans l'espace gestionnaire!")
                    st.snow()
                    time.sleep(1)
                    st.rerun()
                else:
                    st.error("âŒ Mot de passe incorrect")
    
    else:  # BÃ©nÃ©vole
        st.markdown("""
        <div style="text-align: center; margin-bottom: 2rem;">
            <div style="font-size: 3rem;">ğŸ…</div>
            <h2 style="color: #FFD700; margin: 1rem 0;">Espace BÃ©nÃ©vole</h2>
            <p style="color: #cbd5e1;">AccÃ©dez Ã  vos rues assignÃ©es</p>
        </div>
        """, unsafe_allow_html=True)
        
        with st.form("login_benevole", clear_on_submit=False):
            col1, col2 = st.columns(2)
            
            with col1:
                team_id = st.text_input(
                    "ğŸ‘¥ Identifiant d'Ã©quipe",
                    placeholder="Ex: EQ001"
                )
            
            with col2:
                password = st.text_input(
                    "ğŸ” Mot de passe",
                    type="password",
                    placeholder="Mot de passe Ã©quipe"
                )
            
            col1, col2, col3 = st.columns([1,2,1])
            with col2:
                submit = st.form_submit_button(
                    "ğŸ„ Connexion",
                    use_container_width=True
                )
            
            if submit:
                if db.verify_team(conn, team_id, password):
                    st.session_state.auth = {"role": "volunteer", "team_id": team_id}
                    st.success(f"âœ… Bienvenue Ã©quipe {team_id}!")
                    st.snow()
                    time.sleep(1)
                    st.rerun()
                else:
                    st.error("âŒ Identifiants incorrects")
    
    st.markdown("</div>", unsafe_allow_html=True)
    
    # Aide en bas
    st.markdown("""
    <div style="text-align: center; margin-top: 2rem; color: #8b92a4;">
        <small>
        Besoin d'aide? Contactez votre gestionnaire<br>
        ğŸ“ 450-474-4133
        </small>
    </div>
    """, unsafe_allow_html=True)

def render_metrics(stats):
    """Affiche les mÃ©triques principales"""
    progress = (stats['done'] / stats['total'] * 100) if stats['total'] > 0 else 0
    
    col1, col2, col3, col4 = st.columns(4)
    
    with col1:
        st.metric("Total Rues", stats['total'])
    
    with col2:
        st.metric("Rues TerminÃ©es", stats['done'])
    
    with col3:
        st.metric("En Cours", stats.get('partial', 0))
    
    with col4:
        st.metric("Progression", f"{progress:.1f}%")

def render_dashboard_gestionnaire(conn, geo):
    """Dashboard moderne pour gestionnaires avec KPIs visuels"""
    
    # KPIs principaux en cartes colorÃ©es
    stats = db.extended_stats(conn)
    progress = (stats['done'] / stats['total'] * 100) if stats['total'] > 0 else 0
    
    st.markdown("### ğŸ“Š Tableau de bord en temps rÃ©el")
    
    # Ligne de KPIs avec icÃ´nes festives
    col1, col2, col3, col4, col5 = st.columns(5)
    
    with col1:
        st.markdown(f"""
        <div style="
            background: linear-gradient(135deg, #22c55e, #16a34a);
            padding: 1.5rem;
            border-radius: 15px;
            text-align: center;
            box-shadow: 0 4px 15px rgba(34,197,94,0.3);
        ">
            <div style="font-size: 2.5rem;">ğŸ˜ï¸</div>
            <div style="color: white; font-size: 2rem; font-weight: bold;">{stats['total']}</div>
            <div style="color: rgba(255,255,255,0.9); font-size: 0.9rem;">Total Rues</div>
        </div>
        """, unsafe_allow_html=True)
    
    with col2:
        st.markdown(f"""
        <div style="
            background: linear-gradient(135deg, #3b82f6, #2563eb);
            padding: 1.5rem;
            border-radius: 15px;
            text-align: center;
            box-shadow: 0 4px 15px rgba(59,130,246,0.3);
        ">
            <div style="font-size: 2.5rem;">âœ…</div>
            <div style="color: white; font-size: 2rem; font-weight: bold;">{stats['done']}</div>
            <div style="color: rgba(255,255,255,0.9); font-size: 0.9rem;">TerminÃ©es</div>
        </div>
        """, unsafe_allow_html=True)
    
    with col3:
        st.markdown(f"""
        <div style="
            background: linear-gradient(135deg, #f59e0b, #d97706);
            padding: 1.5rem;
            border-radius: 15px;
            text-align: center;
            box-shadow: 0 4px 15px rgba(245,158,11,0.3);
        ">
            <div style="font-size: 2.5rem;">ğŸš¶</div>
            <div style="color: white; font-size: 2rem; font-weight: bold;">{stats.get('partial', 0)}</div>
            <div style="color: rgba(255,255,255,0.9); font-size: 0.9rem;">En cours</div>
        </div>
        """, unsafe_allow_html=True)
    
    with col4:
        # Nombre d'Ã©quipes actives
        teams_count = len(db.teams(conn))
        st.markdown(f"""
        <div style="
            background: linear-gradient(135deg, #8b5cf6, #7c3aed);
            padding: 1.5rem;
            border-radius: 15px;
            text-align: center;
            box-shadow: 0 4px 15px rgba(139,92,246,0.3);
        ">
            <div style="font-size: 2.5rem;">ğŸ‘¥</div>
            <div style="color: white; font-size: 2rem; font-weight: bold;">{teams_count}</div>
            <div style="color: rgba(255,255,255,0.9); font-size: 0.9rem;">Ã‰quipes</div>
        </div>
        """, unsafe_allow_html=True)
    
    with col5:
        st.markdown(f"""
        <div style="
            background: linear-gradient(135deg, #c41e3a, #165b33);
            padding: 1.5rem;
            border-radius: 15px;
            text-align: center;
            box-shadow: 0 4px 15px rgba(196,30,58,0.3);
        ">
            <div style="font-size: 2.5rem;">ğŸ¯</div>
            <div style="color: white; font-size: 2rem; font-weight: bold;">{progress:.0f}%</div>
            <div style="color: rgba(255,255,255,0.9); font-size: 0.9rem;">Progression</div>
        </div>
        """, unsafe_allow_html=True)
    
    # Barre de progression visuelle
    st.markdown("### ğŸ„ Progression globale")
    st.progress(progress / 100)
    
    # Graphique par secteur (si disponible)
    st.markdown("### ğŸ“ˆ Performance par Ã©quipe")
    try:
        teams_stats = db.stats_by_team(conn)
        if not teams_stats.empty:
            # Graphique en barres colorÃ©es
            import plotly.express as px
            fig = px.bar(
                teams_stats, 
                x='team', 
                y='progress',
                color='progress',
                color_continuous_scale=['#ef4444', '#f59e0b', '#22c55e'],
                labels={'team': 'Ã‰quipe', 'progress': 'Progression (%)'},
                title="Performance des Ã©quipes"
            )
            fig.update_layout(
                plot_bgcolor='rgba(0,0,0,0)',
                paper_bgcolor='rgba(0,0,0,0)',
                font_color='white'
            )
            st.plotly_chart(fig, use_container_width=True)
        else:
            st.info("Aucune statistique d'Ã©quipe disponible")
    except Exception as e:
        st.warning("Graphiques non disponibles (module plotly manquant)")
        # Fallback vers un tableau simple
        try:
            teams_stats = db.stats_by_team(conn)
            if not teams_stats.empty:
                st.dataframe(teams_stats, use_container_width=True)
        except:
            st.info("Aucune statistique d'Ã©quipe disponible")

def create_map(df, geo):
    """CrÃ©e la carte Folium centrÃ©e sur Mascouche avec toutes les rues"""
    # Limites de Mascouche
    bounds = {
        "north": 45.78,
        "south": 45.70,
        "east": -73.55,
        "west": -73.70
    }
    center = [(bounds["north"] + bounds["south"]) / 2, 
              (bounds["east"] + bounds["west"]) / 2]
    
    # CrÃ©er la carte
    m = folium.Map(
        location=center,
        zoom_start=13,  # Zoom optimisÃ© pour voir toute la ville
        tiles="https://{s}.tile.openstreetmap.fr/osmfr/{z}/{x}/{y}.png",
        attr='Â© OpenStreetMap France',
        control_scale=True,
        max_bounds=True,
        min_zoom=11,
        max_zoom=18,
        prefer_canvas=True,
        zoom_control=True,
        scrollWheelZoom=True
    )
    
    # Ajouter plusieurs couches de fond
    folium.TileLayer(
        tiles='https://{s}.tile.openstreetmap.fr/osmfr/{z}/{x}/{y}.png',
        attr='Â© OpenStreetMap France',
        name='OSM France (DÃ©taillÃ©)',
        overlay=False,
        control=True
    ).add_to(m)

    folium.TileLayer(
        tiles='https://{s}.basemaps.cartocdn.com/rastertiles/voyager/{z}/{x}/{y}.png',
        attr='Â© CARTO',
        name='CARTO Voyager',
        overlay=False,
        control=True
    ).add_to(m)

    folium.TileLayer(
        tiles='https://server.arcgisonline.com/ArcGIS/rest/services/World_Street_Map/MapServer/tile/{z}/{y}/{x}',
        attr='Â© Esri',
        name='Esri WorldStreetMap',
        overlay=False,
        control=True
    ).add_to(m)

    # Ajouter le contrÃ´le des couches
    folium.LayerControl().add_to(m)
    
    # DÃ©finir les limites de la carte sur Mascouche
    m.fit_bounds([[bounds["south"], bounds["west"]], 
                  [bounds["north"], bounds["east"]]])
    
    if not geo:
        st.warning("Aucune donnÃ©e gÃ©omÃ©trique disponible")
        return m
    
    # Construire le lookup des infos DB
    street_info = {}
    if not df.empty:
        for idx, row in df.iterrows():
            name = str(row['name']) if 'name' in df.columns else ''
            status = row['status'] if 'status' in df.columns and pd.notna(row['status']) else 'a_faire'
            team = row['team'] if 'team' in df.columns and pd.notna(row['team']) else ''
            notes = str(row['notes']) if 'notes' in df.columns and pd.notna(row['notes']) else '0'
            
            street_info[name] = {
                'status': status,
                'team': str(team).strip() if team else '',
                'notes': notes
            }
    
    # Couleurs par statut
    status_colors = {
        'terminee': '#22c55e',  # Vert
        'en_cours': '#f59e0b',  # Orange
        'a_faire': '#ef4444'    # Rouge
    }
    
    # Compteurs pour stats
    stats = {"total": 0, "assigned": 0, "unassigned": 0}
    
    # Ajouter TOUTES les rues de la gÃ©omÃ©trie
    for name, paths in geo.items():
        stats["total"] += 1
        
        # Info depuis DB ou dÃ©faut (rouge pointillÃ©)
        info = street_info.get(name, {
            'status': 'a_faire',
            'team': '',
            'notes': '0'
        })
        
        status = info['status']
        team = info['team']
        notes = info['notes']
        
        # Style: TOUJOURS pointillÃ© si pas d'Ã©quipe
        has_team = bool(team)
        color = status_colors.get(status, '#ef4444')  # Rouge par dÃ©faut
        opacity = 0.9 if has_team else 0.7
        dash = None if has_team else '8,12'  # PointillÃ©s si non assignÃ©
        weight = 7 if has_team else 5
        
        if has_team:
            stats["assigned"] += 1
        else:
            stats["unassigned"] += 1
        
        # Tooltip informatif
        tooltip_html = f"""
        <div style='font-family: sans-serif'>
            <strong style='font-size: 14px'>{name}</strong><br>
            <span style='color: {color}'>â— Statut: {status.replace('_', ' ').title()}</span><br>
            <span>ğŸ“‹ Ã‰quipe: {team if team else 'âš ï¸ NON ASSIGNÃ‰E'}</span><br>
            <span>ğŸ“ Notes: {notes}</span>
        </div>
        """
        
        # Ajouter chaque segment de la rue
        for path in paths:
            if path and len(path) >= 2:
                folium.PolyLine(
                    path,
                    color=color,
                    weight=weight,
                    opacity=opacity,
                    dash_array=dash,
                    tooltip=folium.Tooltip(tooltip_html, sticky=True)
                ).add_to(m)
    
    # Ajouter un marqueur au centre-ville
    folium.Marker(
        [45.7475, -73.6005],
        popup="Centre-ville de Mascouche",
        tooltip="Centre-ville",
        icon=folium.Icon(color='red', icon='info-sign')
    ).add_to(m)
    
    # LÃ©gende amÃ©liorÃ©e
    legend_html = f'''
    <div style="position: fixed; bottom: 50px; right: 50px; width: 220px;
                background: white; z-index:9999; font-size:14px;
                border: 2px solid #8B0000; border-radius: 10px; padding: 15px;
                box-shadow: 0 0 15px rgba(0,0,0,0.2)">
        <h4 style="margin: 0 0 10px 0; color: #8B0000;">LÃ©gende</h4>
        <div><span style="background:#22c55e; width:30px; height:3px; display:inline-block;"></span> TerminÃ©e</div>
        <div><span style="background:#f59e0b; width:30px; height:3px; display:inline-block;"></span> En cours</div>
        <div><span style="background:#ef4444; width:30px; height:3px; display:inline-block;"></span> Ã€ faire</div>
        <hr style="margin: 8px 0;">
        <div><span style="border-bottom: 3px dashed #666; width:30px; display:inline-block;"></span> Non assignÃ©e</div>
        <div><span style="border-bottom: 3px solid #666; width:30px; display:inline-block;"></span> AssignÃ©e</div>
        <hr style="margin: 8px 0;">
        <small>
            <strong>Total:</strong> {stats["total"]} voies<br>
            <strong>AssignÃ©es:</strong> {stats["assigned"]}<br>
            <strong>Non assignÃ©es:</strong> {stats["unassigned"]}
        </small>
    </div>
    '''
    m.get_root().html.add_child(folium.Element(legend_html))
    
    return m


# ============================================
# UTILITAIRES EXPORT
# ============================================

def export_excel_professionnel(conn):
    """Export Excel avec mise en forme professionnelle"""
    try:
        import xlsxwriter
        from io import BytesIO
        
        output = BytesIO()
        workbook = xlsxwriter.Workbook(output)
        
        # Feuille 1 : RÃ©sumÃ©
        summary = workbook.add_worksheet('RÃ©sumÃ© GuignolÃ©e 2025')
        
        # Styles
        header_format = workbook.add_format({
            'bold': True,
            'bg_color': '#c41e3a',
            'font_color': 'white',
            'align': 'center',
            'border': 1
        })
        
        data_format = workbook.add_format({
            'align': 'center',
            'border': 1
        })
        
        # En-tÃªtes
        summary.merge_range(0, 0, 0, 4, 'GUIGNOLÃ‰E 2025 - LE RELAIS DE MASCOUCHE', header_format)
        
        # Stats
        stats = db.extended_stats(conn)
        summary.write(2, 0, 'Total Rues:', header_format)
        summary.write(2, 1, stats['total'], data_format)
        summary.write(3, 0, 'TerminÃ©es:', header_format)
        summary.write(3, 1, stats['done'], data_format)
        summary.write(4, 0, 'Progression:', header_format)
        summary.write(4, 1, f"{(stats['done']/stats['total']*100) if stats['total'] > 0 else 0:.1f}%", data_format)
        
        # Feuille 2 : DÃ©tails par rue
        details = workbook.add_worksheet('DÃ©tails par rue')
        df = db.list_streets(conn)
        
        # Headers
        headers = ['Rue', 'Secteur', 'Ã‰quipe', 'Statut', 'Notes']
        for col, header in enumerate(headers):
            details.write(0, col, header, header_format)
        
        # Data
        for row, (_, data) in enumerate(df.iterrows(), 1):
            details.write(row, 0, data.get('name', ''), data_format)
            details.write(row, 1, data.get('sector', ''), data_format)
            details.write(row, 2, data.get('team', ''), data_format)
            details.write(row, 3, data.get('status', ''), data_format)
            details.write(row, 4, str(data.get('notes', 0)), data_format)
        
        workbook.close()
        output.seek(0)
        return output.getvalue()
        
    except ImportError:
        # Fallback si xlsxwriter n'est pas disponible
        return db.export_to_csv(conn)


# ============================================
# FONCTIONNALITÃ‰S AVANCÃ‰ES
# ============================================

def detect_mobile():
    """DÃ©tecte si l'utilisateur est sur mobile"""
    try:
        # RÃ©cupÃ©rer les paramÃ¨tres de l'URL pour forcer le mode mobile
        query_params = st.experimental_get_query_params()
        if 'mobile' in query_params:
            return True
        
        # Mobile-first approach pour l'instant
        return True
    except:
        return False

def show_notification(message, type="success"):
    """Affiche une notification stylisÃ©e"""
    icons = {
        "success": "âœ…",
        "error": "âŒ",
        "warning": "âš ï¸",
        "info": "â„¹ï¸"
    }
    colors = {
        "success": "#22c55e",
        "error": "#ef4444", 
        "warning": "#f59e0b",
        "info": "#3b82f6"
    }
    
    st.markdown(f"""
    <div style="
        position: fixed;
        top: 20px;
        right: 20px;
        background: {colors[type]};
        color: white;
        padding: 1rem 1.5rem;
        border-radius: 10px;
        box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        z-index: 9999;
        animation: slideIn 0.3s ease-out;
    ">
        <strong>{icons[type]} {message}</strong>
    </div>
    <style>
    @keyframes slideIn {{
        from {{ transform: translateX(100%); opacity: 0; }}
        to {{ transform: translateX(0); opacity: 1; }}
    }}
    </style>
    """, unsafe_allow_html=True)

def show_team_badges(conn, team_id):
    """Affiche les badges de rÃ©ussite de l'Ã©quipe"""
    try:
        df = db.list_streets(conn, team=team_id)
        done = len(df[df['status'] == 'terminee'])
        total = len(df)
        
        badges = []
        if done >= 1:
            badges.append("ğŸ† PremiÃ¨re rue!")
        if done >= total * 0.25:
            badges.append("ğŸ¥‰ 25% complÃ©tÃ©")
        if done >= total * 0.5:
            badges.append("ğŸ¥ˆ 50% complÃ©tÃ©")
        if done >= total * 0.75:
            badges.append("ğŸ¥‡ 75% complÃ©tÃ©")
        if done == total:
            badges.append("ğŸŒŸ CHAMPION!")
        
        if badges:
            st.markdown(f"""
            <div style="
                background: linear-gradient(135deg, #FFD700, #FFA500);
                padding: 1rem;
                border-radius: 10px;
                text-align: center;
                margin: 1rem 0;
            ">
                <strong>Vos badges:</strong><br>
                <div style="font-size: 2rem; margin-top: 0.5rem;">
                    {' '.join(badges)}
                </div>
            </div>
            """, unsafe_allow_html=True)
    except:
        pass

def generate_sms_list(conn):
    """GÃ©nÃ¨re une liste de tÃ©lÃ©phones pour SMS de groupe"""
    try:
        # Cette fonction nÃ©cessiterait une table de tÃ©lÃ©phones
        # Pour l'instant, retourne un exemple
        return "# Liste des tÃ©lÃ©phones bÃ©nÃ©voles\n# 450-XXX-XXXX\n# 438-XXX-XXXX"
    except:
        return "Liste non disponible"

def create_festive_map(df, geo):
    """Carte avec thÃ¨me festif de NoÃ«l"""
    center = [45.7475, -73.6005]
    
    m = folium.Map(
        location=center,
        zoom_start=13,
        tiles='https://server.arcgisonline.com/ArcGIS/rest/services/World_Street_Map/MapServer/tile/{z}/{y}/{x}',
        attr='Â© Esri',
        control_scale=True
    )
    
    # Marqueur spÃ©cial pour le Relais
    folium.Marker(
        [45.7475, -73.6005],
        popup="ğŸ Le Relais de Mascouche",
        tooltip="Point de dÃ©part de la GuignolÃ©e",
        icon=folium.Icon(color='red', icon='gift', prefix='fa')
    ).add_to(m)
    
    # Construction du lookup
    street_info = {}
    if not df.empty:
        for _, row in df.iterrows():
            name = str(row['name']) if 'name' in df.columns else ''
            street_info[name] = {
                'status': row.get('status', 'a_faire'),
                'team': row.get('team', ''),
                'notes': str(row.get('notes', 0))
            }
    
    # Couleurs festives
    status_colors = {
        'terminee': '#165b33',  # Vert sapin
        'en_cours': '#FFD700',   # Or
        'a_faire': '#c41e3a'     # Rouge NoÃ«l
    }
    
    for name, paths in geo.items():
        info = street_info.get(name, {'status': 'a_faire', 'team': '', 'notes': '0'})
        
        color = status_colors.get(info['status'], '#c41e3a')
        team = info['team']
        opacity = 0.9 if team else 0.5
        dash = None if team else '10,10'
        weight = 8 if team else 5
        
        tooltip_html = f"""
        <div style='font-family: sans-serif; font-size: 14px;'>
            <strong>{name}</strong><br>
            <span style='color: {color};'>â— {info['status'].replace('_', ' ').title()}</span><br>
            ğŸ‘¥ {team if team else 'Non assignÃ©e'}<br>
            ğŸ“ {info['notes']} notes
        </div>
        """
        
        for path in paths:
            if path and len(path) >= 2:
                folium.PolyLine(
                    path,
                    color=color,
                    weight=weight,
                    opacity=opacity,
                    dash_array=dash,
                    tooltip=folium.Tooltip(tooltip_html, sticky=True)
                ).add_to(m)
    
    # LÃ©gende festive
    legend_html = '''
    <div style="position: fixed; bottom: 50px; right: 50px; width: 220px;
                background: linear-gradient(135deg, white, #f0f0f0);
                border: 3px solid #c41e3a; border-radius: 15px; padding: 15px;
                box-shadow: 0 5px 20px rgba(0,0,0,0.3);">
        <h4 style="margin: 0 0 10px 0; color: #c41e3a; text-align: center;">
            ğŸ„ LÃ©gende ğŸ„
        </h4>
        <div><span style="background:#165b33; width:30px; height:4px; display:inline-block;"></span> Collecte terminÃ©e</div>
        <div><span style="background:#FFD700; width:30px; height:4px; display:inline-block;"></span> En cours</div>
        <div><span style="background:#c41e3a; width:30px; height:4px; display:inline-block;"></span> Ã€ faire</div>
        <hr style="margin: 8px 0; border-color: #c41e3a;">
        <div><span style="border-bottom: 4px dashed #999; width:30px; display:inline-block;"></span> Non assignÃ©e</div>
    </div>
    '''
    m.get_root().html.add_child(folium.Element(legend_html))
    
    return m

def page_export_gestionnaire(conn):
    """Section export avec formats multiples"""
    
    st.markdown("### ğŸ“Š Centre d'export des donnÃ©es")
    
    col1, col2, col3 = st.columns(3)
    
    with col1:
        st.markdown("""
        <div style="text-align: center; padding: 1rem; border: 2px dashed #ccc; border-radius: 10px;">
            <h4>ğŸ“‘ Rapport PDF</h4>
            <p><small>Format professionnel pour prÃ©sentation</small></p>
        </div>
        """, unsafe_allow_html=True)
        
        if st.button("GÃ©nÃ©rer PDF", use_container_width=True):
            # Pour l'instant, gÃ©nÃ¨re un fichier texte
            report = f"""
RAPPORT GUIGNOLÃ‰E 2025 - LE RELAIS DE MASCOUCHE
===============================================

Date: {datetime.now().strftime('%d/%m/%Y %H:%M')}

STATISTIQUES GLOBALES:
{db.extended_stats(conn)}

GÃ©nÃ©rÃ© par Guigno-Map v4.0
"""
            st.download_button(
                "ğŸ“¥ TÃ©lÃ©charger rapport",
                report,
                "rapport_guignolee_2025.txt",
                "text/plain",
                use_container_width=True
            )
    
    with col2:
        st.markdown("""
        <div style="text-align: center; padding: 1rem; border: 2px dashed #ccc; border-radius: 10px;">
            <h4>ğŸ“Š Excel dÃ©taillÃ©</h4>
            <p><small>Avec graphiques et mise en forme</small></p>
        </div>
        """, unsafe_allow_html=True)
        
        try:
            excel_data = export_excel_professionnel(conn)
            st.download_button(
                "ğŸ“¥ TÃ©lÃ©charger Excel",
                excel_data,
                "guignolee_2025.xlsx",
                "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
                use_container_width=True
            )
        except:
            st.button("Excel (Non disponible)", disabled=True, use_container_width=True)
    
    with col3:
        st.markdown("""
        <div style="text-align: center; padding: 1rem; border: 2px dashed #ccc; border-radius: 10px;">
            <h4>ğŸ“± Liste SMS</h4>
            <p><small>TÃ©lÃ©phones des bÃ©nÃ©voles</small></p>
        </div>
        """, unsafe_allow_html=True)
        
        sms_list = generate_sms_list(conn)
        st.download_button(
            "ğŸ“¥ Liste tÃ©lÃ©phones",
            sms_list,
            "telephones_benevoles.txt",
            "text/plain",
            use_container_width=True
        )


# ============================================
# PAGES
# ============================================

def page_accueil(conn, geo):
    """Page d'accueil"""
    st.markdown("### ğŸ Bienvenue sur Guigno-Map!")
    st.info("SÃ©lectionnez votre mode dans le menu de gauche pour commencer.")
    
    st.markdown("---")
    st.markdown("#### ğŸ“Š AperÃ§u de la collecte")
    
    stats = db.extended_stats(conn)
    render_metrics(stats)
    
    df_all = db.list_streets(conn)
    if not df_all.empty:
        m = create_map(df_all, geo)
        st_folium(m, height=800, width=None, returned_objects=[])

def page_accueil_v2(conn, geo):
    """Page d'accueil festive avec compte Ã  rebours"""
    
    # Compte Ã  rebours jusqu'au 1er dÃ©cembre
    from datetime import datetime, timedelta
    target = datetime(2025, 12, 1, 8, 0, 0)
    now = datetime.now()
    diff = target - now
    
    if diff.days > 0:
        st.markdown(f"""
        <div style="
            background: linear-gradient(135deg, #c41e3a, #165b33);
            padding: 2rem;
            border-radius: 20px;
            text-align: center;
            margin-bottom: 2rem;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        ">
            <h2 style="color: #FFD700; margin: 0;">â° Compte Ã  rebours GuignolÃ©e</h2>
            <div style="font-size: 3rem; color: white; margin: 1rem 0;">
                {diff.days} jours {diff.seconds//3600} heures
            </div>
            <p style="color: rgba(255,255,255,0.9);">avant le grand jour!</p>
        </div>
        """, unsafe_allow_html=True)
    else:
        st.markdown("""
        <div style="
            background: linear-gradient(135deg, #FFD700, #FFA500);
            padding: 2rem;
            border-radius: 20px;
            text-align: center;
            margin-bottom: 2rem;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        ">
            <h2 style="color: #c41e3a; margin: 0;">ğŸ‰ C'EST AUJOURD'HUI!</h2>
            <div style="font-size: 2rem; color: #165b33; margin: 1rem 0;">
                Bonne GuignolÃ©e 2025!
            </div>
        </div>
        """, unsafe_allow_html=True)
    
    # Hero section festif
    st.markdown("""
    <div style="
        text-align: center;
        padding: 3rem 1rem;
        background: linear-gradient(135deg, rgba(196,30,58,0.1), rgba(22,91,51,0.1));
        border-radius: 20px;
        margin-bottom: 2rem;
    ">
        <h1 style="font-size: 3rem; margin: 0;">ğŸ„ Bienvenue sur Guigno-Map ğŸ„</h1>
        <p style="font-size: 1.3rem; color: #666; margin: 1rem 0;">
            Votre plateforme digitale pour la GuignolÃ©e 2025
        </p>
        <p style="color: #888;">
            GÃ©rez efficacement votre collecte de denrÃ©es avec une interface moderne
        </p>
    </div>
    """, unsafe_allow_html=True)
    
    # Stats visuelles amÃ©liorÃ©es
    stats = db.extended_stats(conn)
    progress = (stats['done'] / stats['total'] * 100) if stats['total'] > 0 else 0
    
    st.markdown("### ğŸ“Š Ã‰tat de la collecte en temps rÃ©el")
    
    col1, col2, col3, col4 = st.columns(4)
    
    with col1:
        st.markdown(f"""
        <div style="
            text-align: center;
            padding: 2rem;
            background: linear-gradient(135deg, #22c55e, #16a34a);
            border-radius: 15px;
            color: white;
            box-shadow: 0 4px 15px rgba(34,197,94,0.3);
        ">
            <div style="font-size: 3rem;">ğŸ˜ï¸</div>
            <div style="font-size: 2.5rem; font-weight: bold;">{stats['total']}</div>
            <div>Total Rues</div>
        </div>
        """, unsafe_allow_html=True)
    
    with col2:
        st.markdown(f"""
        <div style="
            text-align: center;
            padding: 2rem;
            background: linear-gradient(135deg, #3b82f6, #2563eb);
            border-radius: 15px;
            color: white;
            box-shadow: 0 4px 15px rgba(59,130,246,0.3);
        ">
            <div style="font-size: 3rem;">âœ…</div>
            <div style="font-size: 2.5rem; font-weight: bold;">{stats['done']}</div>
            <div>ComplÃ©tÃ©es</div>
        </div>
        """, unsafe_allow_html=True)
    
    with col3:
        st.markdown(f"""
        <div style="
            text-align: center;
            padding: 2rem;
            background: linear-gradient(135deg, #f59e0b, #d97706);
            border-radius: 15px;
            color: white;
            box-shadow: 0 4px 15px rgba(245,158,11,0.3);
        ">
            <div style="font-size: 3rem;">ğŸš¶</div>
            <div style="font-size: 2.5rem; font-weight: bold;">{stats.get('partial', 0)}</div>
            <div>En Cours</div>
        </div>
        """, unsafe_allow_html=True)
    
    with col4:
        st.markdown(f"""
        <div style="
            text-align: center;
            padding: 2rem;
            background: linear-gradient(135deg, #c41e3a, #165b33);
            border-radius: 15px;
            color: white;
            box-shadow: 0 4px 15px rgba(196,30,58,0.3);
        ">
            <div style="font-size: 3rem;">ğŸ¯</div>
            <div style="font-size: 2.5rem; font-weight: bold;">{progress:.0f}%</div>
            <div>Progression</div>
        </div>
        """, unsafe_allow_html=True)
    
    # Barre de progression globale
    st.markdown("### ğŸ„ Progression globale de la collecte")
    st.progress(progress / 100)
    
    # Carte festive
    st.markdown("### ğŸ—ºï¸ Vue d'ensemble de Mascouche")
    df_all = db.list_streets(conn)
    if not df_all.empty:
        m = create_festive_map(df_all, geo)
        st_folium(m, height=750, width=None, returned_objects=[])
    
    # CSS pour rÃ©duire l'espace aprÃ¨s la carte
    st.markdown("""
    <style>
    div[data-testid="stVerticalBlock"] > div:has(iframe) {
        margin-bottom: 0 !important;
    }
    </style>
    """, unsafe_allow_html=True)
    
    # Call to action
    st.markdown("""
    <div style="
        text-align: center;
        padding: 2rem;
        background: linear-gradient(135deg, rgba(255,215,0,0.1), rgba(255,215,0,0.05));
        border: 2px solid rgba(255,215,0,0.3);
        border-radius: 15px;
        margin-top: 1rem;
    ">
        <h3>ğŸ… PrÃªt Ã  participer ?</h3>
        <p>Choisissez votre rÃ´le dans le menu de gauche pour commencer</p>
        <p style="font-size: 0.9rem; color: #666;">
            BÃ©nÃ©voles : AccÃ©dez Ã  vos rues assignÃ©es<br>
            Gestionnaires : Supervisez toute la collecte
        </p>
    </div>
    """, unsafe_allow_html=True)

def page_benevole(conn, geo):
    """Interface bÃ©nÃ©vole moderne avec vue limitÃ©e"""
    
    if not st.session_state.auth or st.session_state.auth.get("role") != "volunteer":
        render_login_card("benevole", conn)
        return
    
    team_id = st.session_state.auth["team_id"]
    
    # Header d'Ã©quipe personnalisÃ©
    st.markdown(f"""
    <div style="
        background: linear-gradient(135deg, #165b33, #c41e3a);
        padding: 1.5rem;
        border-radius: 15px;
        margin-bottom: 2rem;
        text-align: center;
    ">
        <h2 style="color: white; margin: 0;">ğŸ… Ã‰quipe {team_id}</h2>
        <p style="color: #FFD700; margin: 0.5rem 0 0 0;">Bonne collecte!</p>
    </div>
    """, unsafe_allow_html=True)
    
    # Stats de l'Ã©quipe
    df_team = db.list_streets(conn, team=team_id)
    if df_team.empty:
        st.warning("Aucune rue assignÃ©e. Contactez votre superviseur.")
        return
    
    done = len(df_team[df_team['status'] == 'terminee'])
    total = len(df_team)
    progress = (done / total * 100) if total > 0 else 0
    
    # Mini dashboard Ã©quipe
    col1, col2, col3 = st.columns(3)
    with col1:
        st.metric("ğŸ“ Vos rues", total)
    with col2:
        st.metric("âœ… ComplÃ©tÃ©es", done)
    with col3:
        st.metric("ğŸ¯ Progression", f"{progress:.0f}%")
    
    # SystÃ¨me de badges
    show_team_badges(conn, team_id)
    
    # Barre de progression
    st.progress(progress / 100)
    
    # Tabs modernisÃ©s
    tab1, tab2, tab3 = st.tabs(["ğŸ—ºï¸ Ma carte", "ğŸ“ Collecte", "ğŸ“Š Historique"])
    
    with tab1:
        # CARTE LIMITÃ‰E AUX RUES DE L'Ã‰QUIPE
        st.markdown("### Vos rues assignÃ©es")
        
        # CrÃ©er une carte avec SEULEMENT les rues de l'Ã©quipe
        m = folium.Map(
            location=[45.7475, -73.6005],
            zoom_start=14,
            tiles='https://{s}.basemaps.cartocdn.com/rastertiles/voyager/{z}/{x}/{y}.png',
            attr='Â© CARTO'
        )
        
        # Filtrer geo pour n'afficher QUE les rues de l'Ã©quipe
        team_streets = df_team['name'].tolist()
        
        for street_name in team_streets:
            if street_name in geo:
                status = df_team[df_team['name'] == street_name]['status'].iloc[0]
                
                # Couleurs selon statut
                colors = {
                    'terminee': '#22c55e',
                    'en_cours': '#f59e0b',
                    'a_faire': '#ef4444'
                }
                color = colors.get(status, '#ef4444')
                
                # Ajouter les segments de cette rue
                for path in geo[street_name]:
                    if path and len(path) >= 2:
                        folium.PolyLine(
                            path,
                            color=color,
                            weight=8,  # Plus Ã©pais pour mobile
                            opacity=0.9,
                            tooltip=f"{street_name} - {status.replace('_', ' ').title()}"
                        ).add_to(m)
        
        # Centrer sur les rues de l'Ã©quipe
        if team_streets and team_streets[0] in geo:
            first_street = geo[team_streets[0]][0]
            if first_street:
                m.location = first_street[0]
        
        st_folium(m, height=650, width=None, returned_objects=[])
    
    with tab2:
        st.markdown("### ğŸ“‹ Checklist de collecte")
        
        # Liste interactive des rues
        for _, row in df_team.iterrows():
            street = row['name']
            status = row['status']
            notes_count = row.get('notes', 0)
            
            # Carte de rue stylisÃ©e
            status_emoji = {'terminee': 'âœ…', 'en_cours': 'ğŸš¶', 'a_faire': 'â­•'}
            status_color = {'terminee': '#22c55e', 'en_cours': '#f59e0b', 'a_faire': '#ef4444'}
            
            with st.expander(f"{status_emoji.get(status, 'â­•')} **{street}** ({notes_count} notes)"):
                
                # Changement rapide de statut
                col1, col2, col3 = st.columns(3)
                with col1:
                    if st.button("â­• Ã€ faire", key=f"todo_{street}", use_container_width=True):
                        db.set_status(conn, street, 'a_faire')
                        st.rerun()
                with col2:
                    if st.button("ğŸš¶ En cours", key=f"progress_{street}", use_container_width=True):
                        db.set_status(conn, street, 'en_cours')
                        st.rerun()
                with col3:
                    if st.button("âœ… TerminÃ©e", key=f"done_{street}", use_container_width=True):
                        db.set_status(conn, street, 'terminee')
                        st.rerun()
                
                st.markdown("---")
                
                # Ajout de note rapide
                st.markdown("**Ajouter une note:**")
                with st.form(f"note_{street}", clear_on_submit=True):
                    col1, col2 = st.columns([1, 3])
                    with col1:
                        num = st.text_input("NÂ°", placeholder="123")
                    with col2:
                        note = st.text_input("Note", placeholder="Personne absente")
                    
                    if st.form_submit_button("â• Ajouter"):
                        if num and note:
                            db.add_note_for_address(conn, street, team_id, num, note)
                            st.success("Note ajoutÃ©e!")
                            st.rerun()
                
                # Notes existantes
                notes = db.get_street_addresses_with_notes(conn, street)
                if not notes.empty:
                    st.markdown("**Notes existantes:**")
                    for _, n in notes.iterrows():
                        st.markdown(f"â€¢ **{n['address_number']}** : {n['comment']}")
    
    with tab3:
        st.markdown("### ğŸ“Š Votre historique")
        try:
            notes = db.get_team_notes(conn, team_id)
            if not notes.empty:
                st.dataframe(notes, use_container_width=True)
            else:
                st.info("Aucune note encore")
        except:
            st.info("Historique non disponible")

def page_benevole_v2(conn, geo):
    """Interface bÃ©nÃ©vole moderne v2 - Alias pour compatibilitÃ©"""
    return page_benevole(conn, geo)

def page_gestionnaire_v2(conn, geo):
    """Interface gestionnaire moderne (ancien superviseur)"""
    st.header("ğŸ‘” Tableau de Bord Gestionnaire")
    
    # VÃ©rifier l'authentification
    if not st.session_state.auth or st.session_state.auth.get("role") != "supervisor":
        render_login_card("gestionnaire", conn)
        return
    
    # Dashboard moderne
    render_dashboard_gestionnaire(conn, geo)
    
    # Tabs
    tabs = st.tabs([
        "ğŸ“Š Vue d'ensemble",
        "ğŸ‘¥ Ã‰quipes",
        "ğŸ—ºï¸ Assignation",
        "ğŸ“¥ Export",
        "ğŸ›  Tech"
    ])
    
    with tabs[0]:
        # Carte gÃ©nÃ©rale
        st.markdown("### Carte gÃ©nÃ©rale")
        df_all = db.list_streets(conn)
        if not df_all.empty:
            m = create_map(df_all, geo)
            st_folium(m, height=800, width=None, returned_objects=[])
        
        # ActivitÃ© rÃ©cente
        st.markdown("### ActivitÃ© rÃ©cente")
        try:
            recent = db.recent_activity(conn, limit=10)
            if not recent.empty:
                st.dataframe(recent, use_container_width=True)
            else:
                st.info("Aucune activitÃ© rÃ©cente")
        except:
            st.info("Historique d'activitÃ© non disponible")
    
    with tabs[1]:
        # Gestion des Ã©quipes
        st.markdown("### Gestion des Ã©quipes")
        
        with st.expander("CrÃ©er une Ã©quipe"):
            with st.form("new_team", clear_on_submit=True):
                new_id = st.text_input("Identifiant")
                new_name = st.text_input("Ã‰quipe")
                new_pass = st.text_input("Mot de passe", type="password")
                
                if st.form_submit_button("CrÃ©er"):
                    if all([new_id, new_name, new_pass]):
                        if db.create_team(conn, new_id, new_name, new_pass):
                            st.success(f"Ã‰quipe {new_id} crÃ©Ã©e")
                            st.rerun()
        
        # Liste des Ã©quipes
        try:
            teams_df = db.get_all_teams(conn)
            if not teams_df.empty:
                st.dataframe(teams_df, use_container_width=True)
            else:
                st.info("Aucune Ã©quipe crÃ©Ã©e")
        except:
            st.info("Liste des Ã©quipes non disponible")
    
    with tabs[2]:
        # Assignation
        st.markdown("### Assignation des rues")
        
        try:
            unassigned = db.get_unassigned_streets(conn)
            
            if not unassigned.empty:
                with st.form("assign"):
                    team = st.selectbox("Ã‰quipe", db.teams(conn))
                    streets = st.multiselect("Rues", unassigned['name'].tolist())
                    
                    if st.form_submit_button("Assigner"):
                        if team and streets:
                            db.assign_streets_to_team(conn, streets, team)
                            st.success("Rues assignÃ©es!")
                            st.rerun()
            else:
                st.success("Toutes les rues sont assignÃ©es!")
        except:
            st.warning("Fonction d'assignation non disponible")
        
        # Tableau des assignations
        df_all = db.list_streets(conn)
        if not df_all.empty:
            st.dataframe(
                df_all[['name', 'sector', 'team', 'status']],
                use_container_width=True
            )
    
    with tabs[3]:
        # Export amÃ©liorÃ©
        st.markdown("### Export des donnÃ©es")
        
        col1, col2, col3 = st.columns(3)
        
        with col1:
            st.download_button(
                "ğŸ“¥ Export CSV Standard",
                db.export_to_csv(conn),
                "rapport_rues.csv",
                "text/csv",
                use_container_width=True
            )
        
        with col2:
            try:
                excel_data = export_excel_professionnel(conn)
                st.download_button(
                    "ğŸ“Š Export Excel Pro",
                    excel_data,
                    "guignolee_2025_rapport.xlsx",
                    "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
                    use_container_width=True
                )
            except:
                st.button("ğŸ“Š Excel (Non disponible)", disabled=True, use_container_width=True)
        
        with col3:
            try:
                st.download_button(
                    "ğŸ“ Export Notes",
                    db.export_notes_csv(conn),
                    "rapport_notes.csv",
                    "text/csv",
                    use_container_width=True
                )
            except:
                st.button("ğŸ“ Notes (Non disponible)", disabled=True, use_container_width=True)

    with tabs[4]:
        st.markdown("### ğŸ›  OpÃ©rations techniques (protÃ©gÃ©es)")

        # -- PIN stockÃ© dans secrets (config.toml -> [secrets] TECH_PIN="xxxx")
        try:
            TECH_PIN = st.secrets.get("TECH_PIN", "")
        except:
            TECH_PIN = ""  # Pas de fichier secrets.toml

        if "tech_ok" not in st.session_state:
            st.session_state.tech_ok = False

        if not st.session_state.tech_ok:
            pin = st.text_input("Entrer le PIN technique", type="password")
            if st.button("DÃ©verrouiller"):
                if TECH_PIN and pin == TECH_PIN:
                    st.session_state.tech_ok = True
                    st.success("AccÃ¨s technique dÃ©verrouillÃ©.")
                    st.rerun()
                else:
                    st.error("PIN invalide.")
            st.stop()

        st.info("âš ï¸ Ces actions sont lourdes et n'affectent pas les statuts/notes. Elles rÃ©gÃ©nÃ¨rent les caches OSM.")

        # --- Reconstruire le cache gÃ©omÃ©trique (lourd)
        with st.expander("ğŸ”„ Reconstruire cache OSM (gÃ©omÃ©tries)", expanded=False):
            col1, col2 = st.columns([1,2])
            with col1:
                confirm = st.checkbox("Je comprends les implications")
            with col2:
                safety = st.text_input('Ã‰crire "REBUILD" pour confirmer')

            if st.button("Lancer la reconstruction"):
                if confirm and safety.strip().upper() == "REBUILD":
                    with st.spinner("Construction du cacheâ€¦"):
                        build_geometry_cache()       # reconstruit le fichier osm_cache.json
                        st.cache_data.clear()        # purge cache Streamlit
                    st.success("âœ… Cache OSM mis Ã  jour (gÃ©omÃ©tries).")
                    st.rerun()
                else:
                    st.warning("Confirmation incomplÃ¨te.")

        # --- Reconstruire/Importer le cache des adresses
        with st.expander("ğŸ“ Mettre Ã  jour les adresses (OSM)", expanded=False):
            col1, col2 = st.columns([1,2])
            with col1:
                confirmA = st.checkbox("Je confirme")
            with col2:
                safetyA = st.text_input('Ã‰crire "IMPORT" pour confirmer')

            if st.button("Lancer la mise Ã  jour des adresses"):
                if confirmA and safetyA.strip().upper() == "IMPORT":
                    with st.spinner("TÃ©lÃ©chargement des adresses OSMâ€¦"):
                        build_addresses_cache()
                        addr_cache = load_addresses_cache()
                        count = db.import_addresses_from_cache(conn, addr_cache)
                    st.success(f"âœ… {count} adresses importÃ©es depuis OSM.")
                    st.rerun()
                else:
                    st.warning("Confirmation incomplÃ¨te.")

def page_superviseur(conn, geo):
    """Interface superviseur"""
    st.header("ğŸ¯ Tableau de Bord Superviseur")
    
    # VÃ©rifier l'authentification
    if not st.session_state.auth or st.session_state.auth.get("role") != "supervisor":
        render_login_card("superviseur", conn)
        return
    
    # Dashboard moderne
    render_dashboard_gestionnaire(conn, geo)
    
    # Tabs
    tabs = st.tabs([
        "ğŸ“Š Vue d'ensemble",
        "ğŸ‘¥ Ã‰quipes",
        "ğŸ—ºï¸ Assignation",
        "ğŸ“¥ Export",
        "ğŸ›  Tech"
    ])
    
    with tabs[0]:
        # Carte gÃ©nÃ©rale
        st.markdown("### Carte gÃ©nÃ©rale")
        df_all = db.list_streets(conn)
        if not df_all.empty:
            m = create_map(df_all, geo)
            st_folium(m, height=800, width=None, returned_objects=[])
        
        # ActivitÃ© rÃ©cente
        st.markdown("### ActivitÃ© rÃ©cente")
        recent = db.recent_activity(conn, limit=10)
        if not recent.empty:
            st.dataframe(recent, use_container_width=True)
    
    with tabs[1]:
        # Gestion des Ã©quipes
        st.markdown("### Gestion des Ã©quipes")
        
        with st.expander("CrÃ©er une Ã©quipe"):
            with st.form("new_team", clear_on_submit=True):
                new_id = st.text_input("Identifiant")
                new_name = st.text_input("Ã‰quipe")
                new_pass = st.text_input("Mot de passe", type="password")
                
                if st.form_submit_button("CrÃ©er"):
                    if all([new_id, new_name, new_pass]):
                        if db.create_team(conn, new_id, new_name, new_pass):
                            st.success(f"Ã‰quipe {new_id} crÃ©Ã©e")
                            st.rerun()
        
        # Liste des Ã©quipes
        teams_df = db.get_all_teams(conn)
        if not teams_df.empty:
            st.dataframe(teams_df, use_container_width=True)
    
    with tabs[2]:
        # Assignation
        st.markdown("### Assignation des rues")
        
        unassigned = db.get_unassigned_streets(conn)
        
        if not unassigned.empty:
            with st.form("assign"):
                team = st.selectbox("Ã‰quipe", db.teams(conn))
                streets = st.multiselect("Rues", unassigned['name'].tolist())
                
                if st.form_submit_button("Assigner"):
                    if team and streets:
                        db.assign_streets_to_team(conn, streets, team)
                        st.success("Rues assignÃ©es!")
                        st.rerun()
        else:
            st.success("Toutes les rues sont assignÃ©es!")
        
        # Tableau des assignations
        df_all = db.list_streets(conn)
        if not df_all.empty:
            st.dataframe(
                df_all[['name', 'sector', 'team', 'status']],
                use_container_width=True
            )
    
    with tabs[3]:
        # Export
        st.markdown("### Export des donnÃ©es")
        
        col1, col2 = st.columns(2)
        
        with col1:
            st.download_button(
                "ğŸ“¥ Export rues (CSV)",
                db.export_to_csv(conn),
                "rapport_rues.csv",
                "text/csv",
                use_container_width=True
            )
        
        with col2:
            st.download_button(
                "ğŸ“¥ Export notes (CSV)",
                db.export_notes_csv(conn),
                "rapport_notes.csv",
                "text/csv",
                use_container_width=True
            )

    with tabs[4]:
        st.markdown("### ğŸ›  OpÃ©rations techniques (protÃ©gÃ©es)")

        # -- PIN stockÃ© dans secrets (config.toml -> [secrets] TECH_PIN="xxxx")  
        try:
            TECH_PIN = st.secrets.get("TECH_PIN", "")
        except:
            TECH_PIN = ""  # Pas de fichier secrets.toml

        if "tech_ok" not in st.session_state:
            st.session_state.tech_ok = False

        if not st.session_state.tech_ok:
            pin = st.text_input("Entrer le PIN technique", type="password")
            if st.button("DÃ©verrouiller"):
                if TECH_PIN and pin == TECH_PIN:
                    st.session_state.tech_ok = True
                    st.success("AccÃ¨s technique dÃ©verrouillÃ©.")
                    st.rerun()
                else:
                    st.error("PIN invalide.")
            st.stop()

        st.info("âš ï¸ Ces actions sont lourdes et n'affectent pas les statuts/notes. Elles rÃ©gÃ©nÃ¨rent les caches OSM.")

        # --- Reconstruire le cache gÃ©omÃ©trique (lourd)
        with st.expander("ğŸ”„ Reconstruire cache OSM (gÃ©omÃ©tries)", expanded=False):
            col1, col2 = st.columns([1,2])
            with col1:
                confirm = st.checkbox("Je comprends les implications")
            with col2:
                safety = st.text_input('Ã‰crire "REBUILD" pour confirmer')

            if st.button("Lancer la reconstruction"):
                if confirm and safety.strip().upper() == "REBUILD":
                    with st.spinner("Construction du cacheâ€¦"):
                        build_geometry_cache()       # reconstruit le fichier osm_cache.json
                        st.cache_data.clear()        # purge cache Streamlit
                    st.success("âœ… Cache OSM mis Ã  jour (gÃ©omÃ©tries).")
                    st.rerun()
                else:
                    st.warning("Confirmation incomplÃ¨te.")

        # --- Reconstruire/Importer le cache des adresses
        with st.expander("ğŸ“ Mettre Ã  jour les adresses (OSM)", expanded=False):
            col1, col2 = st.columns([1,2])
            with col1:
                confirmA = st.checkbox("Je confirme")
            with col2:
                safetyA = st.text_input('Ã‰crire "IMPORT" pour confirmer')

            if st.button("Lancer la mise Ã  jour des adresses"):
                if confirmA and safetyA.strip().upper() == "IMPORT":
                    with st.spinner("TÃ©lÃ©chargement des adresses OSMâ€¦"):
                        build_addresses_cache()
                        addr_cache = load_addresses_cache()
                        count = db.import_addresses_from_cache(conn, addr_cache)
                    st.success(f"âœ… {count} adresses importÃ©es depuis OSM.")
                    st.rerun()
                else:
                    st.warning("Confirmation incomplÃ¨te.")

# ============================================
# MAIN
# ============================================

def main():
    """Point d'entrÃ©e principal - Version 2.0 GuignolÃ©e"""
    
    # CSS moderne
    inject_css()
    
    # Connexion DB
    conn = db.get_conn(DB_PATH)
    db.init_db(conn)
    st.session_state['conn'] = conn
    
    # Cache gÃ©omÃ©trique
    @st.cache_data(ttl=None)
    def get_geo(_sig):
        data = load_geometry_cache()
        return data if data else {}
    
    sig = int(CACHE_FILE.stat().st_mtime_ns) if CACHE_FILE.exists() else 0
    geo = get_geo(sig)
    
    # Header festif
    render_header()
    
    # Navigation modernisÃ©e dans la sidebar
    with st.sidebar:
        # CSS pour la sidebar sans position absolue
        st.markdown("""
        <style>
        .css-1d391kg { padding-top: 1rem !important; }
        .stSidebar > div:first-child { padding-top: 1rem !important; }
        </style>
        """, unsafe_allow_html=True)
        
        # Logo en haut de la sidebar (position normale)
        logo_path = ASSETS / "logo.png"
        if logo_path.exists():
            col1, col2, col3 = st.columns([1, 2, 1])
            with col2:
                st.image(str(logo_path), width=150)
            st.markdown("<div style='height: 20px;'></div>", unsafe_allow_html=True)
        else:
            # Placeholder centrÃ©
            st.markdown("""
            <div style="
                background: linear-gradient(135deg, #c41e3a, #165b33);
                border-radius: 15px;
                padding: 2rem;
                color: white;
                text-align: center;
                margin: 1rem 0;
                box-shadow: 0 4px 15px rgba(0,0,0,0.3);
            ">
                <div style="font-size: 2.5rem;">ğŸ</div>
                <div style="font-weight: bold; font-size: 1.2rem;">LOGO</div>
                <small>Espace rÃ©servÃ©</small>
            </div>
            """, unsafe_allow_html=True)
            st.markdown("<div style='height: 20px;'></div>", unsafe_allow_html=True)
        
        # Navigation
        st.markdown("### ğŸ„ Navigation")
        
        # Boutons de navigation stylisÃ©s
        if st.button("ğŸ  Accueil", use_container_width=True):
            st.session_state.page = "accueil"
            st.rerun()
        
        if st.button("ğŸ… BÃ©nÃ©vole", use_container_width=True):
            st.session_state.page = "benevole"
            st.rerun()
            
        if st.button("ğŸ‘” Gestionnaire", use_container_width=True):
            st.session_state.page = "gestionnaire"  
            st.rerun()
        
        # DÃ©connexion si connectÃ©
        if st.session_state.auth:
            st.markdown("---")
            if st.button("ğŸšª DÃ©connexion", use_container_width=True):
                st.session_state.auth = None
                st.rerun()
        
        # Compteur temps rÃ©el
        st.markdown("---")
        stats = db.extended_stats(conn)
        st.markdown(f"""
        <div style="text-align: center;">
            <h4>Ã‰tat de la collecte</h4>
            <div style="font-size: 2rem; color: #FFD700;">
                {stats['done']}/{stats['total']}
            </div>
            <small>Rues complÃ©tÃ©es</small>
        </div>
        """, unsafe_allow_html=True)
    
    # Routing pages
    page = st.session_state.get('page', 'accueil')
    
    if page == "accueil":
        page_accueil_v2(conn, geo)
    elif page == "benevole":
        page_benevole_v2(conn, geo)
    elif page == "gestionnaire":
        page_gestionnaire_v2(conn, geo)
    
    # Footer festif
    st.markdown("""
    <div style="
        text-align: center;
        padding: 2rem;
        margin-top: 3rem;
        border-top: 2px solid rgba(255,215,0,0.3);
        color: #8b92a4;
    ">
        <p>
            ğŸ„ GuignolÃ©e 2025 - Le Relais de Mascouche ğŸ„<br>
            <small>Ensemble, redonnons espoir | ğŸ“ 450-474-4133</small>
        </p>
    </div>
    """, unsafe_allow_html=True)
    
    # BanniÃ¨re en bas de page
    if (ASSETS / "banner.png").exists():
        st.image(str(ASSETS / "banner.png"), use_column_width=True)

if __name__ == "__main__":
    main()



================================================================================
FICHIER: guignomap/db.py
================================================================================
import sqlite3
import pandas as pd
import hashlib
from datetime import datetime
import json
from pathlib import Path
import os
import secrets
import string

# SchÃ©ma amÃ©liorÃ© de la base de donnÃ©es
SCHEMA = """
-- Table des rues
CREATE TABLE IF NOT EXISTS streets (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT NOT NULL UNIQUE,
    sector TEXT,
    team TEXT,
    status TEXT NOT NULL DEFAULT 'a_faire' 
        CHECK (status IN ('a_faire', 'en_cours', 'terminee'))
);

-- Table des Ã©quipes
CREATE TABLE IF NOT EXISTS teams (
    id TEXT PRIMARY KEY,
    name TEXT NOT NULL,
    password_hash TEXT NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    active BOOLEAN DEFAULT 1
);

-- Table des notes/commentaires PAR ADRESSE
CREATE TABLE IF NOT EXISTS notes (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    street_name TEXT NOT NULL,
    team_id TEXT NOT NULL,
    address_number TEXT,
    comment TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (street_name) REFERENCES streets(name),
    FOREIGN KEY (team_id) REFERENCES teams(id)
);

-- Table d'activitÃ© (log)
CREATE TABLE IF NOT EXISTS activity_log (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    team_id TEXT,
    action TEXT NOT NULL,
    details TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Table des adresses OSM
CREATE TABLE IF NOT EXISTS addresses (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    street_name TEXT NOT NULL,
    house_number TEXT NOT NULL,
    latitude REAL,
    longitude REAL,
    osm_type TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (street_name) REFERENCES streets(name)
);

-- Index pour amÃ©liorer les performances
CREATE INDEX IF NOT EXISTS idx_streets_team ON streets(team);
CREATE INDEX IF NOT EXISTS idx_streets_status ON streets(status);
CREATE INDEX IF NOT EXISTS idx_notes_street ON notes(street_name);
CREATE INDEX IF NOT EXISTS idx_activity_created ON activity_log(created_at DESC);
CREATE INDEX IF NOT EXISTS idx_addresses_street ON addresses(street_name);
CREATE INDEX IF NOT EXISTS idx_addresses_number ON addresses(house_number);
"""

def get_conn(db_path):
    """CrÃ©e une connexion Ã  la base de donnÃ©es"""
    conn = sqlite3.connect(db_path, check_same_thread=False)
    conn.row_factory = sqlite3.Row
    return conn

def init_db(conn):
    """Initialise la base de donnÃ©es avec le schÃ©ma et les donnÃ©es initiales"""
    try:
        # CrÃ©er les tables si elles n'existent pas
        conn.executescript(SCHEMA)
        conn.commit()
        
        # CrÃ©er un compte admin par dÃ©faut s'il n'existe pas
        cursor = conn.execute("SELECT COUNT(*) FROM teams WHERE id = 'ADMIN'")
        if cursor.fetchone()[0] == 0:
            pwd = os.getenv("GM_ADMIN_PWD", "RELAIS2025")  # Par dÃ©faut RELAIS2025
            create_team(conn, 'ADMIN', 'Superviseur', pwd)
        
        # AUTO-IMPORT : Si aucune rue n'existe, importer automatiquement depuis OSM
        cursor = conn.execute("SELECT COUNT(*) FROM streets")
        if cursor.fetchone()[0] == 0:
            print("ğŸ”„ Aucune rue trouvÃ©e. Import automatique depuis OpenStreetMap...")
            auto_import_streets(conn)
            
    except Exception as e:
        print(f"Erreur lors de l'initialisation de la DB: {e}")
        raise

def auto_import_streets(conn):
    """Import automatique des rues de Mascouche"""
    try:
        # Essayer d'abord avec OSM
        from osm import generate_streets_csv
        csv_data = generate_streets_csv("Mascouche")
        
        if csv_data:
            import io
            df = pd.read_csv(io.StringIO(csv_data.decode('utf-8')))
            
            if not df.empty:
                for _, row in df.iterrows():
                    conn.execute(
                        "INSERT OR IGNORE INTO streets(name, sector, team, status) VALUES (?, ?, ?, 'a_faire')",
                        (row.get("name", ""), row.get("sector", ""), row.get("team", ""))
                    )
                conn.commit()
                print(f"âœ… {len(df)} rues importÃ©es automatiquement")
                log_activity(conn, None, "AUTO_IMPORT", f"Import automatique de {len(df)} rues")
                return
    except Exception as e:
        print(f"âš ï¸ Erreur lors de l'import OSM: {e}")
    
    # Fallback : DonnÃ©es de test si OSM Ã©choue
    print("ğŸ“¦ Import de donnÃ©es de test...")
    test_streets = [
        ("MontÃ©e Masson", "Centre", ""),
        ("Chemin Sainte-Marie", "Centre", ""),
        ("Boulevard de Mascouche", "Centre", ""),
        ("Rue Dupras", "Centre", ""),
        ("Rue Saint-Pierre", "Centre", ""),
        ("Rue de l'Ã‰glise", "Centre", ""),
        ("Avenue des Ã‰rables", "Nord", ""),
        ("Rue des Pins", "Nord", ""),
        ("Rue Gravel", "Sud", ""),
        ("Rue Forget", "Sud", ""),
    ]
    
    for name, sector, team in test_streets:
        conn.execute(
            "INSERT OR IGNORE INTO streets(name, sector, team, status) VALUES (?, ?, ?, 'a_faire')",
            (name, sector, team)
        )
    conn.commit()
    print(f"âœ… {len(test_streets)} rues de test importÃ©es")

# ---------- Fonctions pour les Ã©quipes ----------
def hash_password(password):
    """Hash un mot de passe"""
    return hashlib.sha256(password.encode()).hexdigest()

def create_team(conn, team_id, name, password):
    """CrÃ©e une nouvelle Ã©quipe"""
    try:
        conn.execute(
            "INSERT INTO teams (id, name, password_hash) VALUES (?, ?, ?)",
            (team_id, name, hash_password(password))
        )
        conn.commit()
        log_activity(conn, team_id, "TEAM_CREATED", f"Ã‰quipe {name} crÃ©Ã©e")
        return True
    except sqlite3.IntegrityError:
        return False

def verify_team(conn, team_id, password):
    """VÃ©rifie les identifiants d'une Ã©quipe"""
    cursor = conn.execute(
        "SELECT password_hash FROM teams WHERE id = ? AND active = 1",
        (team_id,)
    )
    row = cursor.fetchone()
    if row:
        return row[0] == hash_password(password)
    return False

def get_all_teams(conn):
    """RÃ©cupÃ¨re toutes les Ã©quipes avec leurs statistiques"""
    query = """
    SELECT 
        t.id,
        t.name,
        t.created_at,
        COUNT(DISTINCT s.name) as streets_count,
        SUM(CASE WHEN s.status = 'terminee' THEN 1 ELSE 0 END) as done_count,
        CASE 
            WHEN COUNT(s.name) > 0 
            THEN (SUM(CASE WHEN s.status = 'terminee' THEN 1.0 ELSE 0 END) / COUNT(s.name)) * 100
            ELSE 0 
        END as progress
    FROM teams t
    LEFT JOIN streets s ON t.id = s.team
    WHERE t.active = 1 AND t.id != 'ADMIN'
    GROUP BY t.id, t.name, t.created_at
    ORDER BY t.id
    """
    return pd.read_sql_query(query, conn)

def delete_team(conn, team_id):
    """DÃ©sactive une Ã©quipe"""
    conn.execute("UPDATE teams SET active = 0 WHERE id = ?", (team_id,))
    conn.execute("UPDATE streets SET team = NULL WHERE team = ?", (team_id,))
    conn.commit()
    log_activity(conn, None, "TEAM_DELETED", f"Ã‰quipe {team_id} supprimÃ©e")

def teams(conn):
    """Liste des IDs d'Ã©quipes actives"""
    cursor = conn.execute(
        "SELECT id FROM teams WHERE active = 1 AND id != 'ADMIN' ORDER BY id"
    )
    return [row[0] for row in cursor.fetchall()]

# ---------- Fonctions pour les rues ----------
def list_streets(conn, team=None):
    """Liste les rues, optionnellement filtrÃ©es par Ã©quipe"""
    try:
        if team:
            query = """
                SELECT 
                    s.name, 
                    COALESCE(s.sector, '') as sector, 
                    COALESCE(s.team, '') as team, 
                    COALESCE(s.status, 'a_faire') as status,
                    COUNT(n.id) as notes,
                    COUNT(DISTINCT n.address_number) as addresses_with_notes
                FROM streets s
                LEFT JOIN notes n ON s.name = n.street_name
                WHERE s.team = ?
                GROUP BY s.name, s.sector, s.team, s.status
                ORDER BY 
                    CASE s.status 
                        WHEN 'a_faire' THEN 1 
                        WHEN 'en_cours' THEN 2 
                        WHEN 'terminee' THEN 3 
                    END, 
                    s.name
            """
            df = pd.read_sql_query(query, conn, params=(team,))
        else:
            query = """
                SELECT 
                    s.name, 
                    COALESCE(s.sector, '') as sector, 
                    COALESCE(s.team, '') as team, 
                    COALESCE(s.status, 'a_faire') as status,
                    COUNT(n.id) as notes,
                    COUNT(DISTINCT n.address_number) as addresses_with_notes
                FROM streets s
                LEFT JOIN notes n ON s.name = n.street_name
                GROUP BY s.name, s.sector, s.team, s.status
                ORDER BY 
                    s.team, 
                    CASE s.status 
                        WHEN 'a_faire' THEN 1 
                        WHEN 'en_cours' THEN 2 
                        WHEN 'terminee' THEN 3 
                    END, 
                    s.name
            """
            df = pd.read_sql_query(query, conn)
        
        # S'assurer que toutes les colonnes existent
        for col in ['name', 'sector', 'team', 'status', 'notes', 'addresses_with_notes']:
            if col not in df.columns:
                df[col] = '' if col in ['sector', 'team'] else ('a_faire' if col == 'status' else 0)
        
        return df
        
    except Exception as e:
        print(f"Erreur list_streets: {e}")
        # Retourner un DataFrame vide avec la structure attendue
        return pd.DataFrame(columns=['name', 'sector', 'team', 'status', 'notes', 'addresses_with_notes'])

def get_unassigned_streets(conn):
    """RÃ©cupÃ¨re les rues non assignÃ©es"""
    query = """
        SELECT name, sector 
        FROM streets 
        WHERE team IS NULL OR team = ''
        ORDER BY sector, name
    """
    return pd.read_sql_query(query, conn)

def assign_streets_to_team(conn, street_names, team_id):
    """Assigne plusieurs rues Ã  une Ã©quipe en une transaction"""
    try:
        for street_name in street_names:
            conn.execute(
                "UPDATE streets SET team = ? WHERE name = ?",
                (team_id, street_name)
            )
        conn.commit()
        log_activity(conn, team_id, "STREETS_ASSIGNED", f"{len(street_names)} rues assignÃ©es")
        return True
    except Exception as e:
        conn.rollback()
        print(f"Erreur lors de l'assignation: {e}")
        return False

def set_status(conn, name, status):
    """Met Ã  jour le statut d'une rue"""
    conn.execute(
        "UPDATE streets SET status = ? WHERE name = ?",
        (status, name)
    )
    conn.commit()
    
    cursor = conn.execute("SELECT team FROM streets WHERE name = ?", (name,))
    row = cursor.fetchone()
    if row:
        log_activity(conn, row[0], f"STATUS_{status.upper()}", f"Rue {name}")

# ---------- Fonctions pour les notes PAR ADRESSE ----------
def add_note_for_address(conn, street_name, team_id, address_number, comment):
    """Ajoute une note pour une adresse spÃ©cifique"""
    conn.execute(
        """INSERT INTO notes (street_name, team_id, address_number, comment) 
           VALUES (?, ?, ?, ?)""",
        (street_name, team_id, address_number, comment)
    )
    
    # Met automatiquement le statut Ã  "en_cours" si c'Ã©tait "a_faire"
    conn.execute(
        """UPDATE streets 
           SET status = CASE 
               WHEN status = 'a_faire' THEN 'en_cours' 
               ELSE status 
           END
           WHERE name = ?""",
        (street_name,)
    )
    
    conn.commit()
    log_activity(conn, team_id, "NOTE_ADDED", f"Note ajoutÃ©e pour {address_number} {street_name}")

def get_street_addresses_with_notes(conn, street_name):
    """RÃ©cupÃ¨re toutes les adresses avec notes pour une rue"""
    query = """
        SELECT 
            n.address_number,
            n.comment,
            n.created_at,
            t.name as team_name
        FROM notes n
        JOIN teams t ON n.team_id = t.id
        WHERE n.street_name = ?
        ORDER BY 
            CAST(n.address_number AS INTEGER),
            n.created_at DESC
    """
    return pd.read_sql_query(query, conn, params=(street_name,))

def get_team_notes(conn, team_id):
    """RÃ©cupÃ¨re toutes les notes d'une Ã©quipe"""
    query = """
        SELECT 
            street_name, 
            address_number, 
            comment, 
            created_at
        FROM notes
        WHERE team_id = ?
        ORDER BY created_at DESC
        LIMIT 50
    """
    return pd.read_sql_query(query, conn, params=(team_id,))

# ---------- Fonctions de statistiques ----------
def extended_stats(conn):
    """Statistiques Ã©tendues avec dÃ©tails par adresse"""
    cursor = conn.execute("""
        SELECT 
            COUNT(DISTINCT s.name) as total,
            SUM(CASE WHEN s.status = 'terminee' THEN 1 ELSE 0 END) as done,
            SUM(CASE WHEN s.status = 'en_cours' THEN 1 ELSE 0 END) as partial,
            SUM(CASE WHEN s.status = 'a_faire' THEN 1 ELSE 0 END) as todo,
            COUNT(DISTINCT n.id) as total_notes,
            COUNT(DISTINCT n.address_number || n.street_name) as addresses_with_notes
        FROM streets s
        LEFT JOIN notes n ON s.name = n.street_name
    """)
    row = cursor.fetchone()
    return {
        "total": row[0] or 0,
        "done": row[1] or 0,
        "partial": row[2] or 0,
        "todo": row[3] or 0,
        "total_notes": row[4] or 0,
        "addresses_with_notes": row[5] or 0
    }

def stats_by_team(conn):
    """Statistiques par Ã©quipe"""
    query = """
        SELECT 
            s.team,
            COUNT(DISTINCT s.name) as total,
            SUM(CASE WHEN s.status = 'terminee' THEN 1 ELSE 0 END) as done,
            SUM(CASE WHEN s.status = 'en_cours' THEN 1 ELSE 0 END) as partial,
            COUNT(DISTINCT n.id) as notes,
            ROUND(
                (SUM(CASE WHEN s.status = 'terminee' THEN 1.0 ELSE 0 END) / COUNT(*)) * 100, 
                1
            ) as progress
        FROM streets s
        LEFT JOIN notes n ON s.name = n.street_name AND n.team_id = s.team
        WHERE s.team IS NOT NULL AND s.team != ''
        GROUP BY s.team
        ORDER BY progress DESC
    """
    return pd.read_sql_query(query, conn)

# ---------- Fonctions d'activitÃ© ----------
def log_activity(conn, team_id, action, details=None):
    """Enregistre une activitÃ© dans le log"""
    try:
        conn.execute(
            "INSERT INTO activity_log (team_id, action, details) VALUES (?, ?, ?)",
            (team_id, action, details)
        )
        conn.commit()
    except:
        pass

def recent_activity(conn, limit=10):
    """RÃ©cupÃ¨re l'activitÃ© rÃ©cente"""
    query = """
        SELECT 
            datetime(created_at, 'localtime') as timestamp,
            COALESCE(team_id, 'SYSTEM') as team,
            action,
            details
        FROM activity_log
        ORDER BY created_at DESC
        LIMIT ?
    """
    return pd.read_sql_query(query, conn, params=(limit,))

# ---------- Fonctions d'export ----------
def export_to_csv(conn):
    """Exporte toutes les donnÃ©es en CSV"""
    query = """
        SELECT 
            s.name as rue,
            s.sector as secteur,
            s.team as equipe,
            s.status as statut,
            COUNT(DISTINCT n.id) as nombre_notes,
            COUNT(DISTINCT n.address_number) as adresses_avec_notes
        FROM streets s
        LEFT JOIN notes n ON s.name = n.street_name
        GROUP BY s.name, s.sector, s.team, s.status
        ORDER BY s.team, s.name
    """
    df = pd.read_sql_query(query, conn)
    return df.to_csv(index=False).encode('utf-8')

def export_notes_csv(conn):
    """Exporte toutes les notes en CSV avec adresses"""
    query = """
        SELECT 
            n.street_name as rue,
            n.address_number as numero,
            n.team_id as equipe,
            n.comment as commentaire,
            n.created_at as date_creation
        FROM notes n
        ORDER BY n.street_name, CAST(n.address_number AS INTEGER), n.created_at DESC
    """
    df = pd.read_sql_query(query, conn)
    return df.to_csv(index=False).encode('utf-8')

# ========================================
# NOUVELLES FONCTIONS POUR LES ADRESSES
# ========================================

def import_addresses_from_cache(conn, cache):
    """
    Importe les adresses depuis le cache OSM vers la base de donnÃ©es
    """
    try:
        # Vider la table existante
        conn.execute("DELETE FROM addresses")
        
        imported_count = 0
        skipped_count = 0
        
        for street_name, addresses in cache.items():
            # VÃ©rifier que la rue existe dans la DB
            cursor = conn.execute("SELECT COUNT(*) FROM streets WHERE name = ?", (street_name,))
            if cursor.fetchone()[0] == 0:
                # Si la rue n'existe pas, la crÃ©er
                conn.execute(
                    "INSERT OR IGNORE INTO streets(name, sector, team, status) VALUES (?, '', '', 'a_faire')",
                    (street_name,)
                )
                print(f"â• Rue ajoutÃ©e: {street_name}")
            
            for addr in addresses:
                try:
                    # Validation des donnÃ©es
                    number = str(addr.get("number", "")).strip()
                    lat = addr.get("lat")
                    lon = addr.get("lon")
                    osm_type = addr.get("type", "unknown")
                    
                    if not number or lat is None or lon is None:
                        skipped_count += 1
                        continue
                    
                    conn.execute(
                        """INSERT INTO addresses (street_name, house_number, latitude, longitude, osm_type) 
                           VALUES (?, ?, ?, ?, ?)""",
                        (street_name, number, float(lat), float(lon), osm_type)
                    )
                    imported_count += 1
                except Exception as e:
                    print(f"âš ï¸ Erreur import adresse {addr}: {e}")
                    skipped_count += 1
        
        conn.commit()
        log_activity(conn, None, "ADDRESSES_IMPORTED", f"{imported_count} adresses importÃ©es, {skipped_count} ignorÃ©es")
        print(f"âœ… {imported_count} adresses importÃ©es en base de donnÃ©es ({skipped_count} ignorÃ©es)")
        return imported_count
        
    except Exception as e:
        conn.rollback()
        print(f"âŒ Erreur import adresses: {e}")
        return 0

def get_addresses_for_street(conn, street_name):
    """
    RÃ©cupÃ¨re toutes les adresses d'une rue depuis la base de donnÃ©es
    """
    query = """
        SELECT 
            house_number,
            latitude,
            longitude,
            osm_type,
            created_at
        FROM addresses
        WHERE street_name = ?
        ORDER BY CAST(house_number AS INTEGER)
    """
    return pd.read_sql_query(query, conn, params=(street_name,))

def get_addresses_stats(conn):
    """
    RÃ©cupÃ¨re les statistiques des adresses
    """
    cursor = conn.execute("""
        SELECT 
            COUNT(DISTINCT street_name) as streets_with_addresses,
            COUNT(*) as total_addresses,
            COUNT(DISTINCT CASE WHEN osm_type = 'node' THEN id END) as node_addresses,
            COUNT(DISTINCT CASE WHEN osm_type = 'way' THEN id END) as way_addresses
        FROM addresses
    """)
    row = cursor.fetchone()
    return {
        "streets_with_addresses": row[0] or 0,
        "total_addresses": row[1] or 0,
        "node_addresses": row[2] or 0,
        "way_addresses": row[3] or 0
    }


================================================================================
FICHIER: guignomap/osm.py
================================================================================
"""
Module OSM pour Guigno-Map
GÃ¨re l'import et le cache des donnÃ©es OpenStreetMap pour Mascouche
"""

import io
import json
from pathlib import Path
import pandas as pd
import overpy

# Configuration
CACHE_FILE = Path(__file__).parent / "osm_cache.json"
ADDR_CACHE_FILE = Path(__file__).parent / "osm_addresses.json"

# Toutes les voies routiÃ¨res nommÃ©es de Mascouche
QUERY_STREETS_ALL = """
[out:json][timeout:300];
area["name"="Mascouche"]["boundary"="administrative"]->.a;
(
  way["highway"~"^(primary|secondary|tertiary|residential|service|unclassified|living_street|pedestrian|track|road|busway|footway|path)$"](area.a);
);
(._;>;);
out body;
"""
# Note: RÃ©cupÃ¨re TOUS les types de voies incluant petites rues, allÃ©es, chemins piÃ©tonniers

# RequÃªte pour les adresses
QUERY_ADDR_NODES = """
[out:json][timeout:180];
area["name"="Mascouche"]["boundary"="administrative"]->.a;
(
  node["addr:housenumber"]["addr:street"](area.a);
  way["addr:housenumber"]["addr:street"](area.a);
);
out tags center;
"""

def generate_streets_csv(city="Mascouche"):
    """
    GÃ©nÃ¨re un CSV avec les noms des rues principales de la ville
    Filtre automatiquement les rues privÃ©es et les petites ruelles
    """
    try:
        api = overpy.Overpass()
        result = api.query(QUERY_STREETS_ALL)
        
        streets = []
        for way in result.ways:
            name = way.tags.get("name")
            if not name:
                continue
            g = getattr(way, "geometry", None)
            # garder si on a une vraie gÃ©omÃ©trie (>= 2 points)
            if isinstance(g, list) and len(g) >= 2:
                streets.append(name)

        streets = sorted(set(streets))
        
        # Assigner automatiquement des secteurs basÃ©s sur les patterns de noms
        sectors = []
        for street in streets:
            if any(word in street.lower() for word in ["montÃ©e", "chemin", "boulevard"]):
                sectors.append("Principal")
            elif any(word in street.lower() for word in ["avenue", "place", "croissant"]):
                sectors.append("RÃ©sidentiel")
            elif "rue" in street.lower():
                sectors.append("Centre")
            else:
                sectors.append("")
        
        df = pd.DataFrame({
            "name": streets,
            "sector": sectors,
            "team": [""] * len(streets)
        })
        
        buf = io.StringIO()
        df.to_csv(buf, index=False)
        print(f"âœ… CSV gÃ©nÃ©rÃ© avec {len(streets)} rues principales")
        return buf.getvalue().encode("utf-8")
        
    except Exception as e:
        print(f"âŒ Erreur OSM: {e}")
        # Retourner des donnÃ©es de test en cas d'erreur
        return create_fallback_csv()

def build_geometry_cache():
    """
    Construit le cache des gÃ©omÃ©tries pour TOUTES les voies de Mascouche
    Force la rÃ©solution complÃ¨te des nodes
    """
    try:
        print("ğŸ”„ RÃ©cupÃ©ration complÃ¨te de toutes les voies de Mascouche...")
        
        # IMPORTANT: Configurer l'API pour rÃ©soudre automatiquement les nodes manquants
        api = overpy.Overpass()
        
        # RequÃªte amÃ©liorÃ©e qui force le retour des coordonnÃ©es
        query = """
        [out:json][timeout:300];
        area["name"="Mascouche"]["boundary"="administrative"]->.a;
        (
          way["highway"]["name"](area.a);
          way["highway"]["ref"](area.a);
        );
        (._;>;);
        out body;
        """
        
        print("ğŸ“¡ Connexion Ã  OpenStreetMap (cela peut prendre 30-60 secondes)...")
        result = api.query(query)
        
        geo = {}
        stats = {"total": 0, "avec_geo": 0, "sans_geo": 0}
        
        # Construire un dictionnaire des nodes pour accÃ¨s rapide
        nodes_dict = {}
        if hasattr(result, 'nodes'):
            for node in result.nodes:
                if hasattr(node, 'id') and hasattr(node, 'lat') and hasattr(node, 'lon'):
                    nodes_dict[node.id] = (float(node.lat), float(node.lon))
        
        print(f"ğŸ“ {len(nodes_dict)} nodes rÃ©cupÃ©rÃ©s")
        
        ways = result.ways if hasattr(result, 'ways') else []
        print(f"ğŸ“Š {len(ways)} voies trouvÃ©es dans OpenStreetMap")
        
        for way in ways:
            try:
                # RÃ©cupÃ©rer le nom ou ref
                if not hasattr(way, 'tags'):
                    continue
                    
                name = way.tags.get("name")
                if not name:
                    ref = way.tags.get("ref")
                    if ref:
                        name = f"Autoroute {ref}"
                    else:
                        continue
                
                stats["total"] += 1
                coords = []
                
                # RÃ©cupÃ©rer les IDs des nodes
                if hasattr(way, 'nd_ids'):
                    # Si on a les IDs des nodes, les rÃ©soudre
                    for node_id in way.nd_ids:
                        if node_id in nodes_dict:
                            lat, lon = nodes_dict[node_id]
                            coords.append([lat, lon])
                elif hasattr(way, 'nodes'):
                    # Si on a directement les nodes
                    for node in way.nodes:
                        if hasattr(node, 'lat') and hasattr(node, 'lon'):
                            coords.append([float(node.lat), float(node.lon)])
                        elif hasattr(node, 'id') and node.id in nodes_dict:
                            lat, lon = nodes_dict[node.id]
                            coords.append([lat, lon])
                
                if len(coords) >= 2:
                    if name not in geo:
                        geo[name] = []
                    geo[name].append(coords)
                    stats["avec_geo"] += 1
                else:
                    stats["sans_geo"] += 1
                    
            except Exception as e:
                continue
        
        print(f"âœ… RÃ©sultat: {stats['avec_geo']} voies avec gÃ©omÃ©trie sur {stats['total']} trouvÃ©es")
        
        # Si on a rÃ©cupÃ©rÃ© des donnÃ©es, sauvegarder
        if geo:
            CACHE_FILE.write_text(json.dumps(geo, indent=2), encoding="utf-8")
            print(f"ğŸ’¾ Cache crÃ©Ã©: {len(geo)} voies sauvegardÃ©es dans osm_cache.json")
            
            # Importer aussi automatiquement dans la DB
            try:
                from pathlib import Path
                import sys
                sys.path.append(str(Path(__file__).parent))
                import db
                
                db_path = Path(__file__).parent / "guigno_map.db"
                conn = db.get_conn(db_path)
                
                # Ajouter les rues manquantes Ã  la DB
                for street_name in geo.keys():
                    cursor = conn.execute("SELECT COUNT(*) FROM streets WHERE name = ?", (street_name,))
                    if cursor.fetchone()[0] == 0:
                        conn.execute(
                            "INSERT INTO streets(name, sector, team, status) VALUES (?, '', '', 'a_faire')",
                            (street_name,)
                        )
                conn.commit()
                print(f"âœ… Rues importÃ©es dans la base de donnÃ©es")
            except Exception as e:
                print(f"âš ï¸ Import DB: {e}")
            
            return geo
        
        # Si aucune donnÃ©e, utiliser un fallback Ã©tendu
        print("âš ï¸ Aucune donnÃ©e OSM, utilisation du fallback local")
        return get_extended_fallback()
            
    except Exception as e:
        print(f"âŒ Erreur: {e}")
        return get_extended_fallback()

def get_fallback_geometry():
    """Fallback avec les principales voies de Mascouche"""
    return {
        "Autoroute 25": [[[45.70, -73.65], [45.78, -73.58]]],
        "Autoroute 640": [[[45.76, -73.70], [45.76, -73.55]]],
        "MontÃ©e Masson": [[[45.730, -73.620], [45.765, -73.580]]],
        "Chemin Sainte-Marie": [[[45.735, -73.615], [45.755, -73.595]]],
        "Boulevard de Mascouche": [[[45.740, -73.610], [45.752, -73.590]]],
        "Chemin des Anglais": [[[45.74, -73.65], [45.75, -73.64]]],
        "Chemin Gascon": [[[45.75, -73.62], [45.76, -73.60]]],
        "Chemin Pincourt": [[[45.72, -73.64], [45.73, -73.63]]],
        "Chemin Newton": [[[45.73, -73.58], [45.74, -73.57]]],
        "Chemin Saint-Henri": [[[45.71, -73.61], [45.72, -73.60]]],
        "Chemin Saint-Pierre": [[[45.74, -73.59], [45.75, -73.58]]],
        "Avenue de la Gare": [[[45.745, -73.601], [45.748, -73.598]]],
        "Rue Dupras": [[[45.745, -73.602], [45.748, -73.599]]],
        "Rue Saint-Pierre": [[[45.746, -73.604], [45.749, -73.600]]],
        "Rue de l'Ã‰glise": [[[45.747, -73.601], [45.750, -73.599]]],
        "Avenue des Ã‰rables": [[[45.755, -73.605], [45.758, -73.600]]],
        "Rue des Pins": [[[45.756, -73.603], [45.759, -73.598]]],
        "Rue Brien": [[[45.738, -73.605], [45.741, -73.600]]],
        "Rue BohÃ©mier": [[[45.742, -73.607], [45.745, -73.604]]]
    }

def get_extended_fallback():
    """Fallback Ã©tendu avec les principales voies de Mascouche"""
    fallback = {
        # Autoroutes
        "Autoroute 25": [[[45.70, -73.65], [45.72, -73.63], [45.74, -73.61], [45.76, -73.59], [45.78, -73.58]]],
        "Autoroute 640": [[[45.76, -73.70], [45.76, -73.65], [45.76, -73.60], [45.76, -73.55]]],
        
        # Chemins principaux
        "MontÃ©e Masson": [[[45.730, -73.620], [45.740, -73.610], [45.750, -73.600], [45.765, -73.580]]],
        "Chemin Sainte-Marie": [[[45.735, -73.615], [45.745, -73.605], [45.755, -73.595]]],
        "Boulevard de Mascouche": [[[45.740, -73.610], [45.747, -73.600], [45.752, -73.590]]],
        "Chemin des Anglais": [[[45.74, -73.65], [45.745, -73.645], [45.75, -73.64]]],
        "Chemin Gascon": [[[45.75, -73.62], [45.755, -73.615], [45.76, -73.60]]],
        "Chemin Pincourt": [[[45.72, -73.64], [45.725, -73.635], [45.73, -73.63]]],
        "Chemin Newton": [[[45.73, -73.58], [45.735, -73.575], [45.74, -73.57]]],
        "Chemin Saint-Henri": [[[45.71, -73.61], [45.715, -73.605], [45.72, -73.60]]],
        "Chemin Saint-Pierre": [[[45.74, -73.59], [45.745, -73.585], [45.75, -73.58]]],
        
        # Avenues
        "Avenue de la Gare": [[[45.745, -73.601], [45.747, -73.599], [45.748, -73.598]]],
        "Avenue Bourque": [[[45.742, -73.603], [45.744, -73.601], [45.746, -73.599]]],
        "Avenue CrÃ©peau": [[[45.743, -73.602], [45.745, -73.600], [45.747, -73.598]]],
        "Avenue Garden": [[[45.751, -73.606], [45.753, -73.604], [45.755, -73.602]]],
        "Avenue de l'Esplanade": [[[45.748, -73.605], [45.750, -73.603], [45.752, -73.601]]],
        
        # Rues du centre
        "Rue Dupras": [[[45.745, -73.602], [45.747, -73.600], [45.748, -73.599]]],
        "Rue Saint-Pierre": [[[45.746, -73.604], [45.748, -73.602], [45.749, -73.600]]],
        "Rue de l'Ã‰glise": [[[45.747, -73.601], [45.749, -73.599], [45.750, -73.598]]],
        "Rue Brien": [[[45.738, -73.605], [45.740, -73.603], [45.741, -73.600]]],
        "Rue BohÃ©mier": [[[45.742, -73.607], [45.744, -73.605], [45.745, -73.604]]],
        
        # Rues rÃ©sidentielles
        "Rue des Pins": [[[45.756, -73.603], [45.758, -73.601], [45.759, -73.598]]],
        "Avenue des Ã‰rables": [[[45.755, -73.605], [45.757, -73.603], [45.758, -73.600]]],
        "Rue Gravel": [[[45.738, -73.605], [45.740, -73.603], [45.741, -73.600]]]
    }
    
    # Sauvegarder le fallback
    CACHE_FILE.write_text(json.dumps(fallback, indent=2), encoding="utf-8")
    print(f"ğŸ’¾ Fallback sauvegardÃ© avec {len(fallback)} voies principales")
    
    return fallback

def load_geometry_cache():
    """
    Charge le cache de gÃ©omÃ©tries depuis le fichier JSON
    CrÃ©e un cache de base si le fichier n'existe pas
    """
    if not CACHE_FILE.exists():
        print("âš ï¸ Cache non trouvÃ©, construction en cours...")
        return build_geometry_cache()  # build_geometry_cache() gÃ¨re dÃ©jÃ  le fallback en mÃ©moire
    
    try:
        with open(CACHE_FILE, 'r', encoding='utf-8') as f:
            cache = json.load(f)
            print(f"âœ… Cache chargÃ©: {len(cache)} rues")
            return cache
    except Exception as e:
        print(f"âŒ Erreur chargement cache: {e}")
        # Ne pas Ã©crire de fallback sur disque ! Utiliser build_geometry_cache() qui gÃ¨re le fallback en mÃ©moire
        return build_geometry_cache()

def create_fallback_csv():
    """
    CrÃ©e un CSV de fallback avec quelques rues principales de Mascouche
    UtilisÃ© si l'API OSM est indisponible
    """
    fallback_streets = [
        ("MontÃ©e Masson", "Principal"),
        ("Chemin Sainte-Marie", "Principal"),
        ("Boulevard de Mascouche", "Principal"),
        ("Chemin des Anglais", "Principal"),
        ("Rue Dupras", "Centre"),
        ("Rue Saint-Pierre", "Centre"),
        ("Rue de l'Ã‰glise", "Centre"),
        ("Avenue des Ã‰rables", "RÃ©sidentiel"),
        ("Rue des Pins", "RÃ©sidentiel"),
        ("Avenue Garden", "RÃ©sidentiel"),
    ]
    
    df = pd.DataFrame(fallback_streets, columns=["name", "sector"])
    df["team"] = ""
    
    buf = io.StringIO()
    df.to_csv(buf, index=False)
    print("âš ï¸ Mode fallback: 10 rues de test")
    return buf.getvalue().encode("utf-8")

def create_fallback_cache():
    """
    CrÃ©e un cache minimal pour tests
    """
    fallback_geo = {
        "MontÃ©e Masson": [[[45.730, -73.620], [45.750, -73.600], [45.765, -73.580]]],
        "Chemin Sainte-Marie": [[[45.735, -73.615], [45.748, -73.602], [45.755, -73.595]]],
        "Boulevard de Mascouche": [[[45.740, -73.610], [45.747, -73.600], [45.752, -73.590]]],
        "Rue Dupras": [[[45.745, -73.602], [45.748, -73.599]]],
        "Rue Saint-Pierre": [[[45.746, -73.604], [45.749, -73.600]]],
        "Rue de l'Ã‰glise": [[[45.747, -73.601], [45.750, -73.599]]],
        "Avenue des Ã‰rables": [[[45.755, -73.605], [45.758, -73.600]]],
        "Rue des Pins": [[[45.756, -73.603], [45.759, -73.598]]],
        "Avenue Garden": [[[45.753, -73.606], [45.756, -73.601]]],
        "Rue Gravel": [[[45.738, -73.605], [45.741, -73.600]]]
    }
    
    CACHE_FILE.write_text(json.dumps(fallback_geo, indent=2), encoding="utf-8")
    print("âš ï¸ Cache fallback crÃ©Ã© avec 10 rues")

# Fonction utilitaire pour tests
def test_osm_connection():
    """
    Teste la connexion Ã  l'API Overpass
    """
    try:
        api = overpy.Overpass()
        # RequÃªte minimale pour tester
        result = api.query('[out:json];node(45.7475,-73.6005,45.7476,-73.6004);out;')
        print("âœ… Connexion OSM OK")
        return True
    except:
        print("âŒ Connexion OSM Ã©chouÃ©e")
        return False

# ========================================
# NOUVELLES FONCTIONS POUR LES ADRESSES
# ========================================

def build_addresses_cache():
    """
    Construit le cache des adresses OSM pour Mascouche
    RÃ©cupÃ¨re addr:housenumber + addr:street depuis OSM
    """
    try:
        api = overpy.Overpass()
        result = api.query(QUERY_ADDR_NODES)
        
        addresses = {}
        
        # Traiter les nodes avec adresses
        for node in result.nodes:
            house_number = node.tags.get("addr:housenumber")
            street_name = node.tags.get("addr:street")
            
            if house_number and street_name:
                if street_name not in addresses:
                    addresses[street_name] = []
                addresses[street_name].append({
                    "number": str(house_number),  # Forcer en string
                    "lat": float(node.lat),
                    "lon": float(node.lon),
                    "type": "node"
                })
        
        # Traiter les ways avec adresses
        for way in result.ways:
            num = way.tags.get("addr:housenumber")
            street = way.tags.get("addr:street")
            if not num or not street:
                continue
            
            # RÃ©cupÃ©rer le centre du way
            lat = getattr(way, "center_lat", None)
            lon = getattr(way, "center_lon", None)
            
            # Fallback si center_lat/lon non disponibles
            if lat is None or lon is None:
                nodes = getattr(way, "nodes", []) or []
                if nodes:
                    try:
                        valid_lats = []
                        valid_lons = []
                        for n in nodes:
                            if hasattr(n, 'lat') and hasattr(n, 'lon'):
                                if n.lat is not None and n.lon is not None:
                                    valid_lats.append(float(n.lat))
                                    valid_lons.append(float(n.lon))
                        if valid_lats and valid_lons:
                            lat = sum(valid_lats) / len(valid_lats)
                            lon = sum(valid_lons) / len(valid_lons)
                    except Exception as e:
                        print(f"Erreur calcul centre pour way: {e}")
                        continue
            
            if lat is not None and lon is not None:
                addresses.setdefault(street, []).append({
                    "number": str(num),
                    "lat": float(lat),
                    "lon": float(lon),
                    "type": "way"
                })
        
        # Trier les adresses par numÃ©ro pour chaque rue
        for street_name in addresses:
            try:
                # Tri numÃ©rique intelligent
                addresses[street_name].sort(
                    key=lambda x: (
                        int(''.join(filter(str.isdigit, x["number"]))) 
                        if any(c.isdigit() for c in x["number"]) 
                        else float('inf')
                    )
                )
            except:
                # Si le tri Ã©choue, garder l'ordre original
                pass
        
        # Sauvegarder le cache
        ADDR_CACHE_FILE.write_text(json.dumps(addresses, indent=2), encoding="utf-8")
        total_addresses = sum(len(addrs) for addrs in addresses.values())
        print(f"âœ… Cache adresses crÃ©Ã©: {len(addresses)} rues, {total_addresses} adresses")
        return addresses
        
    except Exception as e:
        print(f"âŒ Erreur construction cache adresses: {e}")
        # CrÃ©er un cache vide en cas d'erreur
        ADDR_CACHE_FILE.write_text(json.dumps({}), encoding="utf-8")
        return {}

def load_addresses_cache():
    """
    Charge le cache d'adresses depuis le fichier JSON
    """
    if not ADDR_CACHE_FILE.exists():
        print("âš ï¸ Cache adresses non trouvÃ©")
        return {}
    
    try:
        with open(ADDR_CACHE_FILE, 'r', encoding='utf-8') as f:
            cache = json.load(f)
            total_addresses = sum(len(addrs) for addrs in cache.values())
            print(f"âœ… Cache adresses chargÃ©: {len(cache)} rues, {total_addresses} adresses")
            return cache
    except Exception as e:
        print(f"âŒ Erreur chargement cache adresses: {e}")
        return {}


================================================================================
FICHIER: guignomap/assets/styles.css
================================================================================
/* ========================================
   GUIGNO-MAP - STYLES PERSONNALISÃ‰S
   Le Relais de Mascouche
   ======================================== */

/* Import Google Fonts */
@import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&family=Manrope:wght@700;800&display=swap');

/* ========================================
   VARIABLES CSS & THÃˆME
   ======================================== */
:root {
    /* Couleurs principales du Relais */
    --relais-rouge: #8B0000;
    --relais-rouge-light: #a52a2a;
    --relais-or: #FFD700;
    --relais-or-light: #FFE44D;
    
    /* Couleurs de statut */
    --status-green: #22c55e;
    --status-orange: #f59e0b;
    --status-red: #ef4444;
    --status-gray: #9ca3af;
    
    /* Couleurs de base */
    --bg-dark: #0e1117;
    --bg-secondary: #151b22;
    --bg-card: #1a1f2e;
    --border-color: #222a33;
    --text-primary: #fafafa;
    --text-secondary: #cbd5e1;
    --text-muted: #8b92a4;
    
    /* Espacements */
    --spacing-xs: 0.25rem;
    --spacing-sm: 0.5rem;
    --spacing-md: 1rem;
    --spacing-lg: 1.5rem;
    --spacing-xl: 2rem;
    
    /* Border radius */
    --radius-sm: 8px;
    --radius-md: 12px;
    --radius-lg: 16px;
    --radius-xl: 20px;
}

/* ========================================
   RESET & BASE STREAMLIT
   ======================================== */

/* Cache les Ã©lÃ©ments Streamlit non dÃ©sirÃ©s */
header[data-testid="stHeader"] { 
    visibility: hidden; 
    height: 0; 
}

#MainMenu {visibility: hidden;}
footer {visibility: hidden;}

.block-container { 
    padding-top: 1rem;
    max-width: 100%;
}

/* Police globale */
* {
    font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif !important;
}

/* ========================================
   HEADER PRINCIPAL AMÃ‰LIORÃ‰
   ======================================== */
.brand-header {
    border-radius: var(--radius-lg);
    padding: 1.5rem 2rem;
    margin: 0 0 2rem 0;
    background: linear-gradient(135deg, 
        var(--relais-rouge) 0%, 
        var(--relais-rouge-light) 100%);
    border: 1px solid rgba(255, 255, 255, 0.1);
    position: relative;
    overflow: hidden;
    box-shadow: 0 10px 40px rgba(139, 0, 0, 0.3);
}

.brand-header::before {
    content: '';
    position: absolute;
    top: -50%;
    right: -10%;
    width: 60%;
    height: 200%;
    background: linear-gradient(90deg, 
        transparent, 
        rgba(255, 215, 0, 0.1));
    transform: rotate(35deg);
    pointer-events: none;
}

.brand-header::after {
    content: 'ğŸ';
    position: absolute;
    right: 2rem;
    top: 50%;
    transform: translateY(-50%);
    font-size: 3rem;
    opacity: 0.2;
}

.brand-title {
    font-family: 'Manrope', sans-serif !important;
    font-size: 2rem;
    font-weight: 800;
    margin: 0 0 0.25rem;
    color: white;
    text-shadow: 2px 2px 8px rgba(0, 0, 0, 0.3);
    letter-spacing: -0.5px;
}

.brand-sub {
    color: rgba(255, 255, 255, 0.9);
    margin: 0;
    font-size: 1rem;
    font-weight: 400;
}

/* ========================================
   CARTES & CONTENEURS
   ======================================== */
.modern-card {
    background: var(--bg-card);
    border-radius: var(--radius-md);
    padding: var(--spacing-lg);
    margin-bottom: var(--spacing-md);
    border: 1px solid var(--border-color);
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
}

.modern-card:hover {
    transform: translateY(-2px);
    box-shadow: 0 8px 16px rgba(0, 0, 0, 0.4);
    border-color: var(--relais-rouge);
}

.stat-card {
    background: linear-gradient(135deg, var(--bg-card) 0%, var(--bg-secondary) 100%);
    border-radius: var(--radius-md);
    padding: var(--spacing-md) var(--spacing-lg);
    border-left: 4px solid var(--relais-rouge);
    position: relative;
    overflow: hidden;
}

.stat-card::after {
    content: '';
    position: absolute;
    top: 0;
    right: 0;
    width: 100px;
    height: 100%;
    background: linear-gradient(90deg, transparent, rgba(139, 0, 0, 0.1));
    transform: skewX(-20deg);
}

/* ========================================
   MÃ‰TRIQUES STREAMLIT
   ======================================== */
[data-testid="stMetric"] {
    background: linear-gradient(135deg, var(--bg-card) 0%, var(--bg-secondary) 100%);
    border-radius: var(--radius-md);
    padding: var(--spacing-md) var(--spacing-lg);
    border: 1px solid var(--border-color);
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
    transition: all 0.3s ease;
}

[data-testid="stMetric"]:hover {
    transform: scale(1.02);
    border-color: var(--relais-rouge);
}

[data-testid="metric-container"] > div:first-child {
    color: var(--text-secondary);
    font-size: 0.875rem;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.5px;
}

[data-testid="metric-container"] > div:nth-child(2) {
    font-size: 2rem;
    font-weight: 700;
    color: var(--relais-rouge);
    margin-top: 0.25rem;
}

/* ========================================
   BOUTONS
   ======================================== */
.stButton > button,
.stDownloadButton > button {
    background: linear-gradient(135deg, var(--relais-rouge) 0%, var(--relais-rouge-light) 100%);
    color: white;
    border: none;
    border-radius: var(--radius-sm);
    padding: 0.625rem 1.25rem;
    font-weight: 600;
    font-size: 0.95rem;
    letter-spacing: 0.3px;
    box-shadow: 0 4px 12px rgba(139, 0, 0, 0.3);
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    position: relative;
    overflow: hidden;
}

.stButton > button::before {
    content: '';
    position: absolute;
    top: 0;
    left: -100%;
    width: 100%;
    height: 100%;
    background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
    transition: left 0.5s;
}

.stButton > button:hover {
    transform: translateY(-2px);
    box-shadow: 0 6px 20px rgba(139, 0, 0, 0.4);
}

.stButton > button:hover::before {
    left: 100%;
}

.stButton > button:active {
    transform: translateY(0);
}

/* Bouton secondaire */
.secondary-btn > button {
    background: transparent !important;
    color: var(--relais-rouge) !important;
    border: 2px solid var(--relais-rouge) !important;
}

.secondary-btn > button:hover {
    background: var(--relais-rouge) !important;
    color: white !important;
}

/* ========================================
   INPUTS & FORMULAIRES
   ======================================== */
.stTextInput > div > div > input,
.stSelectbox > div > div > select,
.stTextArea > div > div > textarea {
    background: var(--bg-secondary);
    border: 2px solid var(--border-color);
    border-radius: var(--radius-sm);
    color: var(--text-primary);
    padding: 0.75rem 1rem;
    font-size: 0.95rem;
    transition: all 0.3s ease;
}

.stTextInput > div > div > input:focus,
.stSelectbox > div > div > select:focus,
.stTextArea > div > div > textarea:focus {
    border-color: var(--relais-rouge);
    box-shadow: 0 0 0 3px rgba(139, 0, 0, 0.1);
    outline: none;
}

/* Labels */
.stTextInput > label,
.stSelectbox > label,
.stTextArea > label {
    color: var(--text-secondary);
    font-weight: 600;
    font-size: 0.875rem;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    margin-bottom: 0.5rem;
}

/* ========================================
   TABLEAUX
   ======================================== */
.stDataFrame {
    border-radius: var(--radius-md);
    overflow: hidden;
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
    border: 1px solid var(--border-color);
}

.dataframe {
    background: var(--bg-card) !important;
}

.dataframe thead tr th {
    background: linear-gradient(135deg, var(--relais-rouge) 0%, var(--relais-rouge-light) 100%) !important;
    color: white !important;
    font-weight: 600;
    text-transform: uppercase;
    font-size: 0.8rem;
    letter-spacing: 0.5px;
    padding: 0.75rem !important;
    border: none !important;
}

.dataframe tbody tr {
    border-bottom: 1px solid var(--border-color);
    transition: background 0.2s ease;
}

.dataframe tbody tr:hover {
    background: rgba(139, 0, 0, 0.1) !important;
}

.dataframe tbody tr td {
    color: var(--text-primary) !important;
    padding: 0.75rem !important;
    border: none !important;
}

/* ========================================
   TABS
   ======================================== */
.stTabs [data-baseweb="tab-list"] {
    background: var(--bg-secondary);
    border-radius: var(--radius-md);
    padding: 0.5rem;
    gap: 0.5rem;
    border: 1px solid var(--border-color);
}

.stTabs [data-baseweb="tab"] {
    background: transparent;
    color: var(--text-secondary);
    border-radius: var(--radius-sm);
    padding: 0.625rem 1.25rem;
    font-weight: 600;
    transition: all 0.3s ease;
}

.stTabs [data-baseweb="tab"]:hover {
    background: rgba(139, 0, 0, 0.1);
    color: var(--text-primary);
}

.stTabs [aria-selected="true"] {
    background: linear-gradient(135deg, var(--relais-rouge) 0%, var(--relais-rouge-light) 100%) !important;
    color: white !important;
    box-shadow: 0 2px 8px rgba(139, 0, 0, 0.3);
}

/* ========================================
   EXPANDEURS
   ======================================== */
.streamlit-expanderHeader {
    background: var(--bg-card);
    border-radius: var(--radius-sm);
    border: 1px solid var(--border-color);
    font-weight: 600;
    color: var(--text-primary);
    transition: all 0.3s ease;
}

.streamlit-expanderHeader:hover {
    background: var(--bg-secondary);
    border-color: var(--relais-rouge);
}

/* ========================================
   SIDEBAR
   ======================================== */
section[data-testid="stSidebar"] {
    background: var(--bg-secondary);
    border-right: 1px solid var(--border-color);
}

section[data-testid="stSidebar"] .block-container {
    padding: var(--spacing-lg);
}

/* ========================================
   BADGES DE STATUT
   ======================================== */
.status-badge {
    display: inline-block;
    padding: 0.25rem 0.75rem;
    border-radius: var(--radius-xl);
    font-size: 0.75rem;
    font-weight: 700;
    text-transform: uppercase;
    letter-spacing: 0.5px;
}

.status-terminee {
    background: rgba(34, 197, 94, 0.2);
    color: var(--status-green);
    border: 1px solid var(--status-green);
}

.status-en-cours {
    background: rgba(245, 158, 11, 0.2);
    color: var(--status-orange);
    border: 1px solid var(--status-orange);
}

.status-a-faire {
    background: rgba(239, 68, 68, 0.2);
    color: var(--status-red);
    border: 1px solid var(--status-red);
}

/* ========================================
   ALERTES & MESSAGES
   ======================================== */
.stAlert {
    border-radius: var(--radius-md);
    border-left-width: 4px;
    padding: var(--spacing-md) var(--spacing-lg);
}

.stSuccess {
    background: rgba(34, 197, 94, 0.1);
    border-left-color: var(--status-green);
    color: var(--status-green);
}

.stError {
    background: rgba(239, 68, 68, 0.1);
    border-left-color: var(--status-red);
    color: var(--status-red);
}

.stWarning {
    background: rgba(245, 158, 11, 0.1);
    border-left-color: var(--status-orange);
    color: var(--status-orange);
}

.stInfo {
    background: rgba(139, 0, 0, 0.1);
    border-left-color: var(--relais-rouge);
    color: var(--text-primary);
}

/* ========================================
   PROGRESS BAR
   ======================================== */
.custom-progress {
    background: var(--bg-card);
    border-radius: var(--radius-md);
    padding: var(--spacing-lg);
    border: 1px solid var(--border-color);
    margin: var(--spacing-md) 0;
}

.progress-bar {
    background: var(--bg-secondary);
    height: 12px;
    border-radius: 6px;
    overflow: hidden;
    position: relative;
}

.progress-fill {
    height: 100%;
    background: linear-gradient(90deg, 
        var(--status-green) 0%, 
        var(--status-orange) 50%, 
        var(--status-red) 100%);
    border-radius: 6px;
    transition: width 0.5s cubic-bezier(0.4, 0, 0.2, 1);
    position: relative;
}

.progress-fill::after {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: linear-gradient(90deg, 
        transparent 0%, 
        rgba(255, 255, 255, 0.3) 50%, 
        transparent 100%);
    animation: shimmer 2s infinite;
}

/* ========================================
   ANIMATIONS
   ======================================== */
@keyframes shimmer {
    0% { transform: translateX(-100%); }
    100% { transform: translateX(100%); }
}

@keyframes pulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.7; }
}

@keyframes slideIn {
    from {
        opacity: 0;
        transform: translateY(-10px);
    }
    to {
        opacity: 1;
        transform: translateY(0);
    }
}

.loading {
    animation: pulse 2s infinite;
}

.slide-in {
    animation: slideIn 0.3s ease-out;
}

/* ========================================
   CARTE FOLIUM
   ======================================== */
iframe {
    border-radius: var(--radius-md);
    border: 1px solid var(--border-color);
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
}

/* ========================================
   FOOTER
   ======================================== */
.footer {
    text-align: center;
    padding: var(--spacing-xl);
    color: var(--text-secondary);
    border-top: 1px solid var(--border-color);
    margin-top: 3rem;
    font-size: 0.875rem;
}

.footer a {
    color: var(--relais-rouge);
    text-decoration: none;
    font-weight: 600;
    transition: color 0.3s ease;
}

.footer a:hover {
    color: var(--relais-or);
}

/* ========================================
   RESPONSIVE
   ======================================== */
@media (max-width: 768px) {
    .brand-title {
        font-size: 1.5rem;
    }
    
    .brand-sub {
        font-size: 0.875rem;
    }
    
    .modern-card {
        padding: var(--spacing-md);
    }
    
    .stButton > button {
        width: 100%;
    }
    
    [data-testid="metric-container"] > div:nth-child(2) {
        font-size: 1.5rem;
    }
}

@media (max-width: 480px) {
    .brand-header {
        padding: var(--spacing-md);
    }
    
    .brand-title {
        font-size: 1.25rem;
    }
    
    .brand-header::after {
        display: none;
    }
}

/* ========================================
   UTILITIES
   ======================================== */
.text-center { text-align: center; }
.text-right { text-align: right; }
.mt-1 { margin-top: var(--spacing-sm); }
.mt-2 { margin-top: var(--spacing-md); }
.mt-3 { margin-top: var(--spacing-lg); }
.mb-1 { margin-bottom: var(--spacing-sm); }
.mb-2 { margin-bottom: var(--spacing-md); }
.mb-3 { margin-bottom: var(--spacing-lg); }
.p-1 { padding: var(--spacing-sm); }
.p-2 { padding: var(--spacing-md); }
.p-3 { padding: var(--spacing-lg); }

/* ========================================
   DARK MODE OPTIMIZATIONS
   ======================================== */
@media (prefers-color-scheme: light) {
    :root {
        --bg-dark: #ffffff;
        --bg-secondary: #f8f9fa;
        --bg-card: #ffffff;
        --border-color: #e5e7eb;
        --text-primary: #111827;
        --text-secondary: #6b7280;
        --text-muted: #9ca3af;
    }
    
    .modern-card,
    [data-testid="stMetric"] {
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
    }
}


================================================================================
FICHIER: .streamlit/config.toml
================================================================================
[theme]
# ThÃ¨me sombre avec les couleurs du Relais
base = "dark"
primaryColor = "#A9CF3B"              # Vert du Relais
backgroundColor = "#0F1318"           # Fond trÃ¨s sombre
secondaryBackgroundColor = "#1A1F26"  # Fond secondaire
textColor = "#F2F3F5"                 # Texte clair
font = "sans serif"

[client]
# Configuration minimale de la toolbar
toolbarMode = "minimal"
showErrorDetails = false

[runner]
# Optimisations de performance
magicEnabled = true
installTracer = false
fixMatplotlib = true

[server]
# Configuration serveur
headless = true
runOnSave = true
maxUploadSize = 10
enableCORS = false
enableXsrfProtection = true

[browser]
# Collecte des stats d'usage (dÃ©sactivÃ© pour confidentialitÃ©)
gatherUsageStats = false

[deprecation]
# DÃ©sactiver les avertissements de dÃ©prÃ©ciation
showImageFormat = false
showPyplotGlobalUse = false


================================================================================
FICHIER: .streamlit/secrets.toml
================================================================================
# Secrets pour Guigno-Map
# Ce fichier ne doit PAS Ãªtre commitÃ© dans Git

TECH_PIN = "RELAIS2025"
