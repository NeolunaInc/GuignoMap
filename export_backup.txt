# GuignoMap - Export de code complet
# Date : 15 septembre 2025 - 13:30:00
# Version : 4.1 finale avec am√©liorations UI/UX
# Auteur : GitHub Copilot & d√©veloppeur
# Projet : Syst√®me de gestion pour la Guignol√©e 2025
# Encodage : UTF-8 (sans BOM)

## R√âSUM√â DES AM√âLIORATIONS R√âCENTES

### Corrections UI/UX finalis√©es :
1. **Assignations** : Suppression overlay texte au-dessus s√©lecteur secteur, layout propre container/colonnes
2. **√âquipes** : Suppression doublon markdown causant superposition, formulaire robuste avec confirmation mot de passe
3. **Validation** : Politique mot de passe assouplie (min 4 chars, aucune autre contrainte)
4. **Interface** : Toggle "Afficher mots de passe", rendu uniforme sans styles sp√©ciaux
5. **Exports** : Correction API XlsxWriter (indices entiers), plus d'erreurs Pylance
6. **Base donn√©es** : D√©duplication log_activity, fonction create_team robuste

### Architecture technique :
- Python 3.13.6, Streamlit, pandas, folium, xlsxwriter, bcrypt
- Base SQLite avec validation compl√®te
- Syst√®me de backup automatique
- Exports professionnels (Excel, PDF, CSV)
- Authentification bcrypt s√©curis√©e

### Commits r√©cents :
- 46b2213: equipes: remove summary/markdown duplication (no overlay); relax password policy to min 4 chars; docs
- 1ee36fe: equipes: add password confirmation; policy = min 4 chars; show/hide toggle; docs
- 6a2c728: ui(assignations): remove stray overlay above sector select; clean layout; uniform table rendering
- 23959b2: UI/UX finalis√© : suppression overlay + colonne Statut uniforme + corrections Pylance

================================================================================

## FICHIER 1: guignomap/app.py (Application principale Streamlit)

```python"""
Guigno-Map - Application de gestion de collecte de denr√©es
Le Relais de Mascouche
Version 3.0 - Production
"""

from pathlib import Path
import time
from datetime import datetime
import pandas as pd
import streamlit as st
import folium
from streamlit_folium import st_folium

# Import des modules locaux
import db
from validators import validate_and_clean_input
from osm import build_geometry_cache, load_geometry_cache, build_addresses_cache, load_addresses_cache, CACHE_FILE

# Configuration des chemins
DB_PATH = Path(__file__).parent / "guigno_map.db"

# --- Utilitaire de compatibilit√© pandas Styler ---
from typing import Callable, Any

def style_map_compat(df: pd.DataFrame, fn: Callable[[Any], str], subset: Any = None):
    """Applique un style cellule-√†-cellule en utilisant Styler.map si disponible,
    sinon fallback dynamique vers applymap sans exposer l'attribut (OK pour Pylance).
    
    Args:
        df: DataFrame √† styliser
        fn: Fonction qui prend une valeur cellule et retourne une string CSS
        subset: Colonnes √† cibler (ex: ['status'] ou None pour toutes)
    """
    styler = df.style
    if hasattr(styler, "map"):
        # Pandas 2.4+ : utilise la nouvelle API map()
        return styler.map(fn, subset=subset)
    # Pandas < 2.4 : fallback vers applymap (sans r√©f√©rence statique)
    return getattr(styler, "applymap")(fn, subset=subset)

# --- Mapping des statuts pour l'affichage ---
STATUS_TO_LABEL = {"a_faire": "√Ä faire", "en_cours": "En cours", "terminee": "Termin√©e"}
LABEL_TO_STATUS = {v: k for k, v in STATUS_TO_LABEL.items()}

ASSETS = Path(__file__).parent / "assets"

# Configuration Streamlit
st.set_page_config(
    page_title="Guigno-Map | Relais de Mascouche",
    page_icon="üéÅ",
    layout="wide",
    initial_sidebar_state="expanded"
)

# Initialisation session
if "auth" not in st.session_state:
    st.session_state.auth = None

# ============================================
# COMPOSANTS UI
# ============================================

def inject_css():
    """Charge le CSS depuis le fichier externe"""
    css_file = ASSETS / "styles.css"
    if css_file.exists():
        css = css_file.read_text(encoding="utf-8")
        st.markdown(f"<style>{css}</style>", unsafe_allow_html=True)

def render_header():
    """Header moderne avec logo Guignol√©e et design festif"""
    
    # Container principal avec fond festif
    st.markdown("""
    <div style="
        background: linear-gradient(135deg, #c41e3a 0%, #165b33 100%);
        border-radius: 20px;
        padding: 2rem;
        margin-bottom: 2rem;
        position: relative;
        overflow: hidden;
        box-shadow: 0 10px 30px rgba(0,0,0,0.3);
    ">
        <!-- Flocons de neige anim√©s en CSS -->
        <div style="position: absolute; width: 100%; height: 100%; opacity: 0.1;">
            <span style="position: absolute; top: 10%; left: 10%; font-size: 2rem;">‚ùÑÔ∏è</span>
            <span style="position: absolute; top: 20%; left: 80%; font-size: 1.5rem;">‚ùÑÔ∏è</span>
            <span style="position: absolute; top: 60%; left: 30%; font-size: 1.8rem;">‚ùÑÔ∏è</span>
        </div>
    """, unsafe_allow_html=True)
    
    col1, col2, col3 = st.columns([2, 5, 2])
    
    with col1:
        # Logo Guignol√©e
        if (ASSETS / "guignolee.png").exists():
            st.image(str(ASSETS / "guignolee.png"), width=150)
    
    with col2:
        st.markdown("""
        <div style="text-align: center;">
            <h1 style="
                color: white;
                font-family: 'Manrope', sans-serif;
                font-size: 2.5rem;
                margin: 0;
                text-shadow: 3px 3px 6px rgba(0,0,0,0.5);
                letter-spacing: 2px;
            ">üéÖ GUIGNOL√âE 2025 üéÅ</h1>
            <p style="
                color: #FFD700;
                font-size: 1.2rem;
                margin: 0.5rem 0 0 0;
                font-weight: 600;
            ">Le Relais de Mascouche - 1er d√©cembre</p>
            <p style="
                color: rgba(255,255,255,0.9);
                font-size: 1rem;
                margin-top: 0.5rem;
            ">Syst√®me de gestion de collecte</p>
        </div>
        """, unsafe_allow_html=True)
    
    with col3:
        # Stats en temps r√©el
        stats = db.extended_stats(st.session_state.get('conn'))
        progress = (stats['done'] / stats['total'] * 100) if stats['total'] > 0 else 0
        
        st.markdown(f"""
        <div style="
            background: rgba(255,255,255,0.2);
            border-radius: 15px;
            padding: 1rem;
            text-align: center;
        ">
            <div style="color: #FFD700; font-size: 2rem; font-weight: bold;">
                {progress:.0f}%
            </div>
            <div style="color: white; font-size: 0.9rem;">
                Compl√©t√©
            </div>
        </div>
        """, unsafe_allow_html=True)
    
    st.markdown("</div>", unsafe_allow_html=True)

def render_login_card(role="benevole", conn=None):
    """Carte de connexion moderne avec design festif"""
    
    # Container de connexion stylis√©
    st.markdown("""
    <div style="
        max-width: 400px;
        margin: 3rem auto;
        background: linear-gradient(135deg, rgba(255,255,255,0.1), rgba(255,255,255,0.05));
        backdrop-filter: blur(10px);
        border: 2px solid rgba(255,215,0,0.3);
        border-radius: 20px;
        padding: 2rem;
        box-shadow: 0 20px 40px rgba(0,0,0,0.3);
    ">
    """, unsafe_allow_html=True)
    
    # Ic√¥ne et titre
    if role == "superviseur" or role == "gestionnaire":
        st.markdown("""
        <div style="text-align: center; margin-bottom: 2rem;">
            <div style="font-size: 3rem;">üëî</div>
            <h2 style="color: #FFD700; margin: 1rem 0;">Espace Gestionnaire</h2>
            <p style="color: #cbd5e1;">G√©rez la collecte et les √©quipes</p>
        </div>
        """, unsafe_allow_html=True)
        
        with st.form("login_gestionnaire", clear_on_submit=False):
            password = st.text_input(
                "üîê Mot de passe",
                type="password",
                placeholder="Entrez le mot de passe gestionnaire"
            )
            
            col1, col2, col3 = st.columns([1,2,1])
            with col2:
                submit = st.form_submit_button(
                    "üöÄ Connexion",
                    width="stretch"
                )
            
            if submit:
                if db.verify_team(conn, "ADMIN", password):
                    st.session_state.auth = {"role": "supervisor", "team_id": "ADMIN"}
                    st.success("‚úÖ Bienvenue dans l'espace gestionnaire!")
                    st.snow()
                    time.sleep(1)
                    st.rerun()
                else:
                    st.error("‚ùå Mot de passe incorrect")
    
    else:  # B√©n√©vole
        st.markdown("""
        <div style="text-align: center; margin-bottom: 2rem;">
            <div style="font-size: 3rem;">üéÖ</div>
            <h2 style="color: #FFD700; margin: 1rem 0;">Espace B√©n√©vole</h2>
            <p style="color: #cbd5e1;">Acc√©dez √† vos rues assign√©es</p>
        </div>
        """, unsafe_allow_html=True)
        
        with st.form("login_benevole", clear_on_submit=False):
            col1, col2 = st.columns(2)
            
            with col1:
                team_id = st.text_input(
                    "üë• Identifiant d'√©quipe",
                    placeholder="Ex: EQ001"
                )
            
            with col2:
                password = st.text_input(
                    "üîê Mot de passe",
                    type="password",
                    placeholder="Mot de passe √©quipe"
                )
            
            col1, col2, col3 = st.columns([1,2,1])
            with col2:
                submit = st.form_submit_button(
                    "üéÑ Connexion",
                    width="stretch"
                )
            
            if submit:
                if db.verify_team(conn, team_id, password):
                    st.session_state.auth = {"role": "volunteer", "team_id": team_id}
                    st.success(f"‚úÖ Bienvenue √©quipe {team_id}!")
                    st.snow()
                    time.sleep(1)
                    st.rerun()
                else:
                    st.error("‚ùå Identifiants incorrects")
    
    st.markdown("</div>", unsafe_allow_html=True)
    
    # Aide en bas
    st.markdown("""
    <div style="text-align: center; margin-top: 2rem; color: #8b92a4;">
        <small>
        Besoin d'aide? Contactez votre gestionnaire<br>
        üìû 450-474-4133
        </small>
    </div>
    """, unsafe_allow_html=True)

def render_metrics(stats):
    """Affiche les m√©triques principales"""
    progress = (stats['done'] / stats['total'] * 100) if stats['total'] > 0 else 0
    
    col1, col2, col3, col4 = st.columns(4)
    
    with col1:
        st.metric("Total Rues", stats['total'])
    
    with col2:
        st.metric("Rues Termin√©es", stats['done'])
    
    with col3:
        st.metric("En Cours", stats.get('partial', 0))
    
    with col4:
        st.metric("Progression", f"{progress:.1f}%")

def render_dashboard_gestionnaire(conn, geo):
    """Dashboard moderne pour gestionnaires avec KPIs visuels"""
    
    # KPIs principaux en cartes color√©es
    stats = db.extended_stats(conn)
    progress = (stats['done'] / stats['total'] * 100) if stats['total'] > 0 else 0
    
    st.markdown("### üìä Tableau de bord en temps r√©el")
    
    # Ligne de KPIs avec ic√¥nes festives
    col1, col2, col3, col4, col5 = st.columns(5)
    
    with col1:
        st.markdown(f"""
        <div style="
            background: linear-gradient(135deg, #22c55e, #16a34a);
            padding: 1.5rem;
            border-radius: 15px;
            text-align: center;
            box-shadow: 0 4px 15px rgba(34,197,94,0.3);
        ">
            <div style="font-size: 2.5rem;">üèòÔ∏è</div>
            <div style="color: white; font-size: 2rem; font-weight: bold;">{stats['total']}</div>
            <div style="color: rgba(255,255,255,0.9); font-size: 0.9rem;">Total Rues</div>
        </div>
        """, unsafe_allow_html=True)
    
    with col2:
        st.markdown(f"""
        <div style="
            background: linear-gradient(135deg, #3b82f6, #2563eb);
            padding: 1.5rem;
            border-radius: 15px;
            text-align: center;
            box-shadow: 0 4px 15px rgba(59,130,246,0.3);
        ">
            <div style="font-size: 2.5rem;">‚úÖ</div>
            <div style="color: white; font-size: 2rem; font-weight: bold;">{stats['done']}</div>
            <div style="color: rgba(255,255,255,0.9); font-size: 0.9rem;">Termin√©es</div>
        </div>
        """, unsafe_allow_html=True)
    
    with col3:
        st.markdown(f"""
        <div style="
            background: linear-gradient(135deg, #f59e0b, #d97706);
            padding: 1.5rem;
            border-radius: 15px;
            text-align: center;
            box-shadow: 0 4px 15px rgba(245,158,11,0.3);
        ">
            <div style="font-size: 2.5rem;">üö∂</div>
            <div style="color: white; font-size: 2rem; font-weight: bold;">{stats.get('partial', 0)}</div>
            <div style="color: rgba(255,255,255,0.9); font-size: 0.9rem;">En cours</div>
        </div>
        """, unsafe_allow_html=True)
    
    with col4:
        # Nombre d'√©quipes actives
        teams_count = len(db.teams(conn))
        st.markdown(f"""
        <div style="
            background: linear-gradient(135deg, #8b5cf6, #7c3aed);
            padding: 1.5rem;
            border-radius: 15px;
            text-align: center;
            box-shadow: 0 4px 15px rgba(139,92,246,0.3);
        ">
            <div style="font-size: 2.5rem;">üë•</div>
            <div style="color: white; font-size: 2rem; font-weight: bold;">{teams_count}</div>
            <div style="color: rgba(255,255,255,0.9); font-size: 0.9rem;">√âquipes</div>
        </div>
        """, unsafe_allow_html=True)
    
    with col5:
        st.markdown(f"""
        <div style="
            background: linear-gradient(135deg, #c41e3a, #165b33);
            padding: 1.5rem;
            border-radius: 15px;
            text-align: center;
            box-shadow: 0 4px 15px rgba(196,30,58,0.3);
        ">
            <div style="font-size: 2.5rem;">üéØ</div>
            <div style="color: white; font-size: 2rem; font-weight: bold;">{progress:.0f}%</div>
            <div style="color: rgba(255,255,255,0.9); font-size: 0.9rem;">Progression</div>
        </div>
        """, unsafe_allow_html=True)
    
    # Barre de progression visuelle
    st.markdown("### üéÑ Progression globale")
    st.progress(progress / 100)
    
    # Graphique par secteur (si disponible)
    st.markdown("### üìà Performance par √©quipe")
    try:
        teams_stats = db.stats_by_team(conn)
        if not teams_stats.empty:
            # Graphique en barres color√©es
            import plotly.express as px
            fig = px.bar(
                teams_stats, 
                x='team', 
                y='progress',
                color='progress',
                color_continuous_scale=['#ef4444', '#f59e0b', '#22c55e'],
                labels={'team': '√âquipe', 'progress': 'Progression (%)'},
                title="Performance des √©quipes"
            )
            fig.update_layout(
                plot_bgcolor='rgba(0,0,0,0)',
                paper_bgcolor='rgba(0,0,0,0)',
                font_color='white'
            )
            st.plotly_chart(fig, width="stretch")
        else:
            st.info("Aucune statistique d'√©quipe disponible")
    except Exception as e:
        st.warning("Graphiques non disponibles (module plotly manquant)")
        # Fallback vers un tableau simple
        try:
            teams_stats = db.stats_by_team(conn)
            if not teams_stats.empty:
                st.dataframe(teams_stats, width="stretch")
        except:
            st.info("Aucune statistique d'√©quipe disponible")

def add_persistent_legend(m):
    """Ajoute une l√©gende persistante pour les 4 √©tats des rues via contr√¥le HTML"""
    legend_html = """
    <div id='gm-legend' class='leaflet-control-layers leaflet-control' 
         style='position: absolute; bottom: 10px; right: 10px; z-index: 1000;
                background: white; border: 2px solid rgba(0,0,0,0.2); 
                border-radius: 5px; padding: 10px; box-shadow: 0 1px 5px rgba(0,0,0,0.2);
                font-family: "Helvetica Neue", Arial, Helvetica, sans-serif; 
                font-size: 12px; line-height: 18px; color: #333;'>
        <strong style='margin-bottom: 8px; display: block;'>L√©gende</strong>
        <div style='margin: 4px 0; display: flex; align-items: center;'>
            <span style='width: 20px; height: 0; border-top: 3px solid #28a745; 
                         display: inline-block; margin-right: 8px;'></span>
            <span>Termin√©e</span>
        </div>
        <div style='margin: 4px 0; display: flex; align-items: center;'>
            <span style='width: 20px; height: 0; border-top: 3px solid #f1c40f; 
                         display: inline-block; margin-right: 8px;'></span>
            <span>En cours</span>
        </div>
        <div style='margin: 4px 0; display: flex; align-items: center;'>
            <span style='width: 20px; height: 0; border-top: 3px solid #ff4d4f; 
                         display: inline-block; margin-right: 8px;'></span>
            <span>Assign√©e (√† faire)</span>
        </div>
        <div style='margin: 4px 0; display: flex; align-items: center;'>
            <span style='width: 20px; height: 0; border-top: 3px dashed #ff4d4f; 
                         display: inline-block; margin-right: 8px;'></span>
            <span>Non assign√©e</span>
        </div>
    </div>
    """
    m.get_root().html.add_child(folium.Element(legend_html))

def create_map(df, geo):
    """Cr√©e la carte Folium centr√©e sur Mascouche avec toutes les rues"""
    # Limites de Mascouche
    bounds = {
        "north": 45.78,
        "south": 45.70,
        "east": -73.55,
        "west": -73.70
    }
    center = [(bounds["north"] + bounds["south"]) / 2, 
              (bounds["east"] + bounds["west"]) / 2]
    
    # Cr√©er la carte
    m = folium.Map(
        location=center,
        zoom_start=13,  # Zoom optimis√© pour voir toute la ville
        tiles="https://{s}.tile.openstreetmap.fr/osmfr/{z}/{x}/{y}.png",
        attr='¬© OpenStreetMap France',
        control_scale=True,
        max_bounds=True,
        min_zoom=11,
        max_zoom=18,
        prefer_canvas=True,
        zoom_control=True,
        scrollWheelZoom=True
    )
    
    # Ajouter plusieurs couches de fond
    folium.TileLayer(
        tiles='https://{s}.tile.openstreetmap.fr/osmfr/{z}/{x}/{y}.png',
        attr='¬© OpenStreetMap France',
        name='OSM France (D√©taill√©)',
        overlay=False,
        control=True
    ).add_to(m)

    folium.TileLayer(
        tiles='https://{s}.basemaps.cartocdn.com/rastertiles/voyager/{z}/{x}/{y}.png',
        attr='¬© CARTO',
        name='CARTO Voyager',
        overlay=False,
        control=True
    ).add_to(m)

    folium.TileLayer(
        tiles='https://server.arcgisonline.com/ArcGIS/rest/services/World_Street_Map/MapServer/tile/{z}/{y}/{x}',
        attr='¬© Esri',
        name='Esri WorldStreetMap',
        overlay=False,
        control=True
    ).add_to(m)

    # Ajouter le contr√¥le des couches
    folium.LayerControl().add_to(m)
    
    # D√©finir les limites de la carte sur Mascouche
    m.fit_bounds([[bounds["south"], bounds["west"]], 
                  [bounds["north"], bounds["east"]]])
    
    if not geo:
        st.warning("Aucune donn√©e g√©om√©trique disponible")
        return m
    
    # Construire le lookup des infos DB
    street_info = {}
    if not df.empty:
        for idx, row in df.iterrows():
            name = str(row['name']) if 'name' in df.columns else ''
            status = row['status'] if 'status' in df.columns and pd.notna(row['status']) else 'a_faire'
            team = row['team'] if 'team' in df.columns and pd.notna(row['team']) else ''
            notes = str(row['notes']) if 'notes' in df.columns and pd.notna(row['notes']) else '0'
            
            street_info[name] = {
                'status': status,
                'team': str(team).strip() if team else '',
                'notes': notes
            }
    
    # Couleurs par statut
    status_colors = {
        'terminee': '#22c55e',  # Vert
        'en_cours': '#f59e0b',  # Orange
        'a_faire': '#ef4444'    # Rouge
    }
    
    # Compteurs pour stats
    stats = {"total": 0, "assigned": 0, "unassigned": 0}
    
    # Ajouter TOUTES les rues de la g√©om√©trie
    for name, paths in geo.items():
        stats["total"] += 1
        
        # Info depuis DB ou d√©faut (rouge pointill√©)
        info = street_info.get(name, {
            'status': 'a_faire',
            'team': '',
            'notes': '0'
        })
        
        status = info['status']
        team = info['team']
        notes = info['notes']
        
        # Style: TOUJOURS pointill√© si pas d'√©quipe
        has_team = bool(team)
        color = status_colors.get(status, '#ef4444')  # Rouge par d√©faut
        opacity = 0.9 if has_team else 0.7
        dash = None if has_team else '8,12'  # Pointill√©s si non assign√©
        weight = 7 if has_team else 5
        
        if has_team:
            stats["assigned"] += 1
        else:
            stats["unassigned"] += 1
        
        # Tooltip informatif
        tooltip_html = f"""
        <div style='font-family: sans-serif'>
            <strong style='font-size: 14px'>{name}</strong><br>
            <span style='color: {color}'>‚óè Statut: {status.replace('_', ' ').title()}</span><br>
            <span>üìã √âquipe: {team if team else '‚ö†Ô∏è NON ASSIGN√âE'}</span><br>
            <span>üìù Notes: {notes}</span>
        </div>
        """
        
        # Ajouter chaque segment de la rue
        for path in paths:
            if path and len(path) >= 2:
                folium.PolyLine(
                    path,
                    color=color,
                    weight=weight,
                    opacity=opacity,
                    dash_array=dash,
                    tooltip=folium.Tooltip(tooltip_html, sticky=True)
                ).add_to(m)
    
    # Ajouter un marqueur au centre-ville
    folium.Marker(
        [45.7475, -73.6005],
        popup="Centre-ville de Mascouche",
        tooltip="Centre-ville",
        icon=folium.Icon(color='red', icon='info-sign')
    ).add_to(m)
    
    # Ajouter la l√©gende persistante
    add_persistent_legend(m)
    
    return m


# ============================================
# UTILITAIRES EXPORT
# ============================================

def export_excel_professionnel(conn):
    """Export Excel avec mise en forme professionnelle"""
    try:
        from reports import ReportGenerator
        generator = ReportGenerator(conn)
        return generator.generate_excel()
    except ImportError:
        # Fallback si les d√©pendances ne sont pas install√©es
        return db.export_to_csv(conn)


# ============================================
# FONCTIONNALIT√âS AVANC√âES
# ============================================

def detect_mobile():
    """D√©tecte si l'utilisateur est sur mobile"""
    try:
        # R√©cup√©rer les param√®tres de l'URL pour forcer le mode mobile
        query_params = st.experimental_get_query_params()
        if 'mobile' in query_params:
            return True
        
        # Mobile-first approach pour l'instant
        return True
    except:
        return False

def show_notification(message, type="success"):
    """Affiche une notification stylis√©e"""
    icons = {
        "success": "‚úÖ",
        "error": "‚ùå",
        "warning": "‚ö†Ô∏è",
        "info": "‚ÑπÔ∏è"
    }
    colors = {
        "success": "#22c55e",
        "error": "#ef4444", 
        "warning": "#f59e0b",
        "info": "#3b82f6"
    }
    
    st.markdown(f"""
    <div style="
        position: fixed;
        top: 20px;
        right: 20px;
        background: {colors[type]};
        color: white;
        padding: 1rem 1.5rem;
        border-radius: 10px;
        box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        z-index: 9999;
        animation: slideIn 0.3s ease-out;
    ">
        <strong>{icons[type]} {message}</strong>
    </div>
    <style>
    @keyframes slideIn {{
        from {{ transform: translateX(100%); opacity: 0; }}
        to {{ transform: translateX(0); opacity: 1; }}
    }}
    </style>
    """, unsafe_allow_html=True)

def show_team_badges(conn, team_id):
    """Affiche les badges de r√©ussite de l'√©quipe"""
    try:
        df = db.list_streets(conn, team=team_id)
        done = len(df[df['status'] == 'terminee'])
        total = len(df)
        
        badges = []
        if done >= 1:
            badges.append("üèÜ Premi√®re rue!")
        if done >= total * 0.25:
            badges.append("ü•â 25% compl√©t√©")
        if done >= total * 0.5:
            badges.append("ü•à 50% compl√©t√©")
        if done >= total * 0.75:
            badges.append("ü•á 75% compl√©t√©")
        if done == total:
            badges.append("üåü CHAMPION!")
        
        if badges:
            st.markdown(f"""
            <div style="
                background: linear-gradient(135deg, #FFD700, #FFA500);
                padding: 1rem;
                border-radius: 10px;
                text-align: center;
                margin: 1rem 0;
            ">
                <strong>Vos badges:</strong><br>
                <div style="font-size: 2rem; margin-top: 0.5rem;">
                    {' '.join(badges)}
                </div>
            </div>
            """, unsafe_allow_html=True)
    except:
        pass

def generate_sms_list(conn):
    """G√©n√®re une liste de t√©l√©phones pour SMS de groupe"""
    try:
        # Cette fonction n√©cessiterait une table de t√©l√©phones
        # Pour l'instant, retourne un exemple
        return "# Liste des t√©l√©phones b√©n√©voles\n# 450-XXX-XXXX\n# 438-XXX-XXXX"
    except:
        return "Liste non disponible"

def page_export_gestionnaire(conn):
    """Section export avec formats multiples"""
    
    st.markdown("### üìä Centre d'export des donn√©es")
    
    col1, col2, col3 = st.columns(3)
    
    with col1:
        st.markdown("""
        <div style="text-align: center; padding: 1rem; border: 2px dashed #ccc; border-radius: 10px;">
            <h4>  Rapport PDF</h4>
            <p><small>Format professionnel pour pr√©sentation</small></p>
        </div>
        """, unsafe_allow_html=True)
        
        try:
            from reports import ReportGenerator
            generator = ReportGenerator(conn)
            pdf_data = generator.generate_pdf()
            st.download_button(
                "üì• T√©l√©charger PDF",
                pdf_data,
                "rapport_guignolee_2025.pdf",
                "application/pdf",
                width="stretch"
            )
        except ImportError:
            st.button("PDF (Installer reportlab)", disabled=True, width="stretch")
    
    with col2:
        st.markdown("""
        <div style="text-align: center; padding: 1rem; border: 2px dashed #ccc; border-radius: 10px;">
            <h4>üìä Excel d√©taill√©</h4>
            <p><small>Avec graphiques et mise en forme</small></p>
        </div>
        """, unsafe_allow_html=True)
        
        try:
            excel_data = export_excel_professionnel(conn)
            st.download_button(
                "üì• T√©l√©charger Excel",
                excel_data,
                "guignolee_2025.xlsx",
                "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
                width="stretch"
            )
        except:
            st.button("Excel (Non disponible)", disabled=True, width="stretch")
    
    with col3:
        st.markdown("""
        <div style="text-align: center; padding: 1rem; border: 2px dashed #ccc; border-radius: 10px;">
            <h4>üì± Liste SMS</h4>
            <p><small>T√©l√©phones des b√©n√©voles</small></p>
        </div>
        """, unsafe_allow_html=True)
        
        sms_list = generate_sms_list(conn)
        st.download_button(
            "üì• Liste t√©l√©phones",
            sms_list,
            "telephones_benevoles.txt",
            "text/plain",
            width="stretch"
        )


# ============================================
# PAGES
# ============================================

def page_accueil(conn, geo):
    """Page d'accueil"""
    st.markdown("### üéÅ Bienvenue sur Guigno-Map!")
    st.info("S√©lectionnez votre mode dans le menu de gauche pour commencer.")
    
    st.markdown("---")
    st.markdown("#### üìä Aper√ßu de la collecte")
    
    stats = db.extended_stats(conn)
    render_metrics(stats)
    
    df_all = db.list_streets(conn)
    if not df_all.empty:
        m = create_map(df_all, geo)
        st_folium(m, height=800, width=None, returned_objects=[])

def page_accueil_v2(conn, geo):
    """Page d'accueil festive avec compte √† rebours"""
    
    # Compte √† rebours jusqu'au 1er d√©cembre
    from datetime import datetime, timedelta
    target = datetime(2025, 12, 1, 8, 0, 0)
    now = datetime.now()
    diff = target - now
    
    if diff.days > 0:
        st.markdown(f"""
        <div style="
            background: linear-gradient(135deg, #c41e3a, #165b33);
            padding: 2rem;
            border-radius: 20px;
            text-align: center;
            margin-bottom: 2rem;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        ">
            <h2 style="color: #FFD700; margin: 0;">‚è∞ Compte √† rebours Guignol√©e</h2>
            <div style="font-size: 3rem; color: white; margin: 1rem 0;">
                {diff.days} jours {diff.seconds//3600} heures
            </div>
            <p style="color: rgba(255,255,255,0.9);">avant le grand jour!</p>
        </div>
        """, unsafe_allow_html=True)
    else:
        st.markdown("""
        <div style="
            background: linear-gradient(135deg, #FFD700, #FFA500);
            padding: 2rem;
            border-radius: 20px;
            text-align: center;
            margin-bottom: 2rem;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        ">
            <h2 style="color: #c41e3a; margin: 0;">üéâ C'EST AUJOURD'HUI!</h2>
            <div style="font-size: 2rem; color: #165b33; margin: 1rem 0;">
                Bonne Guignol√©e 2025!
            </div>
        </div>
        """, unsafe_allow_html=True)
    
    # Hero section festif
    st.markdown("""
    <div style="
        text-align: center;
        padding: 3rem 1rem;
        background: linear-gradient(135deg, rgba(196,30,58,0.1), rgba(22,91,51,0.1));
        border-radius: 20px;
        margin-bottom: 2rem;
    ">
        <h1 style="font-size: 3rem; margin: 0;">üéÑ Bienvenue sur Guigno-Map üéÑ</h1>
        <p style="font-size: 1.3rem; color: #666; margin: 1rem 0;">
            Votre plateforme digitale pour la Guignol√©e 2025
        </p>
        <p style="color: #888;">
            G√©rez efficacement votre collecte de denr√©es avec une interface moderne
        </p>
    </div>
    """, unsafe_allow_html=True)
    
    # Stats visuelles am√©lior√©es
    stats = db.extended_stats(conn)
    progress = (stats['done'] / stats['total'] * 100) if stats['total'] > 0 else 0
    
    st.markdown("### üìä √âtat de la collecte en temps r√©el")
    
    col1, col2, col3, col4 = st.columns(4)
    
    with col1:
        st.markdown(f"""
        <div style="
            text-align: center;
            padding: 2rem;
            background: linear-gradient(135deg, #22c55e, #16a34a);
            border-radius: 15px;
            color: white;
            box-shadow: 0 4px 15px rgba(34,197,94,0.3);
        ">
            <div style="font-size: 3rem;">üèòÔ∏è</div>
            <div style="font-size: 2.5rem; font-weight: bold;">{stats['total']}</div>
            <div>Total Rues</div>
        </div>
        """, unsafe_allow_html=True)
    
    with col2:
        st.markdown(f"""
        <div style="
            text-align: center;
            padding: 2rem;
            background: linear-gradient(135deg, #3b82f6, #2563eb);
            border-radius: 15px;
            color: white;
            box-shadow: 0 4px 15px rgba(59,130,246,0.3);
        ">
            <div style="font-size: 3rem;">‚úÖ</div>
            <div style="font-size: 2.5rem; font-weight: bold;">{stats['done']}</div>
            <div>Compl√©t√©es</div>
        </div>
        """, unsafe_allow_html=True)
    
    with col3:
        st.markdown(f"""
        <div style="
            text-align: center;
            padding: 2rem;
            background: linear-gradient(135deg, #f59e0b, #d97706);
            border-radius: 15px;
            color: white;
            box-shadow: 0 4px 15px rgba(245,158,11,0.3);
        ">
            <div style="font-size: 3rem;">üö∂</div>
            <div style="font-size: 2.5rem; font-weight: bold;">{stats.get('partial', 0)}</div>
            <div>En Cours</div>
        </div>
        """, unsafe_allow_html=True)
    
    with col4:
        st.markdown(f"""
        <div style="
            text-align: center;
            padding: 2rem;
            background: linear-gradient(135deg, #c41e3a, #165b33);
            border-radius: 15px;
            color: white;
            box-shadow: 0 4px 15px rgba(196,30,58,0.3);
        ">
            <div style="font-size: 3rem;">üéØ</div>
            <div style="font-size: 2.5rem; font-weight: bold;">{progress:.0f}%</div>
            <div>Progression</div>
        </div>
        """, unsafe_allow_html=True)
    
    # Barre de progression globale
    st.markdown("### üéÑ Progression globale de la collecte")
    st.progress(progress / 100)
    
    # Carte festive
    st.markdown("### üó∫Ô∏è Vue d'ensemble de Mascouche")
    df_all = db.list_streets(conn)
    if not df_all.empty:
        m = create_map(df_all, geo)
        st_folium(m, height=750, width=None, returned_objects=[])
    
    # CSS pour r√©duire l'espace apr√®s la carte
    st.markdown("""
    <style>
    div[data-testid="stVerticalBlock"] > div:has(iframe) {
        margin-bottom: 0 !important;
    }
    </style>
    """, unsafe_allow_html=True)
    
    # Call to action
    st.markdown("""
    <div style="
        text-align: center;
        padding: 2rem;
        background: linear-gradient(135deg, rgba(255,215,0,0.1), rgba(255,215,0,0.05));
        border: 2px solid rgba(255,215,0,0.3);
        border-radius: 15px;
        margin-top: 1rem;
    ">
        <h3>üéÖ Pr√™t √† participer ?</h3>
        <p>Choisissez votre r√¥le dans le menu de gauche pour commencer</p>
        <p style="font-size: 0.9rem; color: #666;">
            B√©n√©voles : Acc√©dez √† vos rues assign√©es<br>
            Gestionnaires : Supervisez toute la collecte
        </p>
    </div>
    """, unsafe_allow_html=True)

def page_benevole(conn, geo):
    """Interface b√©n√©vole moderne avec vue limit√©e"""
    
    if not st.session_state.auth or st.session_state.auth.get("role") != "volunteer":
        render_login_card("benevole", conn)
        return
    
    team_id = st.session_state.auth["team_id"]
    
    # Header d'√©quipe personnalis√©
    st.markdown(f"""
    <div style="
        background: linear-gradient(135deg, #165b33, #c41e3a);
        padding: 1.5rem;
        border-radius: 15px;
        margin-bottom: 2rem;
        text-align: center;
    ">
        <h2 style="color: white; margin: 0;">üéÖ √âquipe {team_id}</h2>
        <p style="color: #FFD700; margin: 0.5rem 0 0 0;">Bonne collecte!</p>
    </div>
    """, unsafe_allow_html=True)
    
    # Stats de l'√©quipe
    df_team = db.list_streets(conn, team=team_id)
    if df_team.empty:
        st.warning("Aucune rue assign√©e. Contactez votre superviseur.")
        return
    
    done = len(df_team[df_team['status'] == 'terminee'])
    total = len(df_team)
    progress = (done / total * 100) if total > 0 else 0
    
    # Mini dashboard √©quipe
    col1, col2, col3 = st.columns(3)
    with col1:
        st.metric("üìç Vos rues", total)
    with col2:
        st.metric("‚úÖ Compl√©t√©es", done)
    with col3:
        st.metric("üéØ Progression", f"{progress:.0f}%")
    
    # Syst√®me de badges
    show_team_badges(conn, team_id)
    
    # Barre de progression
    st.progress(progress / 100)
    
    # Tabs modernis√©s
    tab1, tab2, tab3 = st.tabs(["üó∫Ô∏è Ma carte", "üìù Collecte", "üìä Historique"])
    
    with tab1:
        # CARTE LIMIT√âE AUX RUES DE L'√âQUIPE
        st.markdown("### Vos rues assign√©es")
        
        # Cr√©er une carte avec SEULEMENT les rues de l'√©quipe
        m = folium.Map(
            location=[45.7475, -73.6005],
            zoom_start=14,
            tiles='https://{s}.basemaps.cartocdn.com/rastertiles/voyager/{z}/{x}/{y}.png',
            attr='¬© CARTO'
        )
        
        # Filtrer geo pour n'afficher QUE les rues de l'√©quipe
        team_streets = df_team['name'].tolist()
        
        for street_name in team_streets:
            if street_name in geo:
                status = df_team[df_team['name'] == street_name]['status'].iloc[0]
                
                # Couleurs selon statut
                colors = {
                    'terminee': '#22c55e',
                    'en_cours': '#f59e0b',
                    'a_faire': '#ef4444'
                }
                color = colors.get(status, '#ef4444')
                
                # Ajouter les segments de cette rue
                for path in geo[street_name]:
                    if path and len(path) >= 2:
                        folium.PolyLine(
                            path,
                            color=color,
                            weight=8,  # Plus √©pais pour mobile
                            opacity=0.9,
                            tooltip=f"{street_name} - {status.replace('_', ' ').title()}"
                        ).add_to(m)
        
        # Centrer sur les rues de l'√©quipe
        if team_streets and team_streets[0] in geo:
            first_street = geo[team_streets[0]][0]
            if first_street:
                m.location = first_street[0]
        
        st_folium(m, height=650, width=None, returned_objects=[])
    
    with tab2:
        st.markdown("### üìã Checklist de collecte")
        
        # Liste interactive des rues
        for _, row in df_team.iterrows():
            street = row['name']
            status = row['status']
            notes_count = row.get('notes', 0)
            
            # Carte de rue stylis√©e
            status_emoji = {'terminee': '‚úÖ', 'en_cours': 'üö∂', 'a_faire': '‚≠ï'}
            status_color = {'terminee': '#22c55e', 'en_cours': '#f59e0b', 'a_faire': '#ef4444'}
            
            with st.expander(f"{status_emoji.get(status, '‚≠ï')} **{street}** ({notes_count} notes)"):
                
                # Changement rapide de statut
                col1, col2, col3 = st.columns(3)
                with col1:
                    if st.button("‚≠ï √Ä faire", key=f"todo_{street}", width="stretch"):
                        db.set_status(conn, street, 'a_faire')
                        st.rerun()
                with col2:
                    if st.button("üö∂ En cours", key=f"progress_{street}", width="stretch"):
                        db.set_status(conn, street, 'en_cours')
                        st.rerun()
                with col3:
                    if st.button("‚úÖ Termin√©e", key=f"done_{street}", width="stretch"):
                        db.set_status(conn, street, 'terminee')
                        st.rerun()
                
                st.markdown("---")
                
                # Ajout de note rapide
                st.markdown("**Ajouter une note:**")
                with st.form(f"note_{street}", clear_on_submit=True):
                    col1, col2 = st.columns([1, 3])
                    with col1:
                        num = st.text_input("N¬∞", placeholder="123")
                    with col2:
                        note = st.text_input("Note", placeholder="Personne absente")
                    
                    if st.form_submit_button("‚ûï Ajouter"):
                        if num and note:
                            db.add_note_for_address(conn, street, team_id, num, note)
                            st.success("Note ajout√©e!")
                            st.rerun()
                
                # Notes existantes
                notes = db.get_street_addresses_with_notes(conn, street)
                if not notes.empty:
                    st.markdown("**Notes existantes:**")
                    for _, n in notes.iterrows():
                        st.markdown(f"‚Ä¢ **{n['address_number']}** : {n['comment']}")
    
    with tab3:
        st.markdown("### üìä Votre historique")
        try:
            notes = db.get_team_notes(conn, team_id)
            if not notes.empty:
                st.dataframe(notes, width="stretch")
            else:
                st.info("Aucune note encore")
        except:
            st.info("Historique non disponible")

def page_benevole_v2(conn, geo):
    """Interface b√©n√©vole moderne v4.1 avec vue 'Mes rues'"""
    
    # V√©rifier l'authentification
    if not st.session_state.auth or st.session_state.auth.get("role") != "volunteer":
        # Afficher la page de connexion b√©n√©vole
        return page_benevole(conn, geo)
    
    # Interface b√©n√©vole connect√© avec tabs
    st.header("üéÖ Espace B√©n√©vole")
    team_id = st.session_state.auth.get("team", "√âquipe inconnue")
    st.markdown(f"**√âquipe:** {team_id}")
    
    # Tabs pour b√©n√©voles
    tabs = st.tabs([
        "üèòÔ∏è Mes rues",
        "üó∫Ô∏è Carte de terrain", 
        "üìù Journal d'activit√©"
    ])
    
    with tabs[0]:
        # Nouvelle vue "Mes rues" v4.1
        page_benevole_mes_rues(conn)
    
    with tabs[1]:
        # Carte traditionnelle (r√©utilise l'ancienne interface)
        page_benevole(conn, geo)
    
    with tabs[2]:
        # Journal d'activit√© de l'√©quipe
        st.markdown("### üìù Journal d'activit√© de votre √©quipe")
        try:
            # Afficher les activit√©s r√©centes de l'√©quipe
            cursor = conn.execute("""
                SELECT action, details, created_at
                FROM activity_log
                WHERE team_id = ?
                ORDER BY created_at DESC
                LIMIT 20
            """, (team_id,))
            
            activities = cursor.fetchall()
            if activities:
                for activity in activities:
                    action, details, created_at = activity
                    st.markdown(f"**{created_at}** - {action}: {details}")
            else:
                st.info("Aucune activit√© enregistr√©e pour votre √©quipe")
                
        except Exception as e:
            st.info("Journal d'activit√© temporairement indisponible")
            st.caption(f"Erreur: {e}")

def page_gestionnaire_v2(conn, geo):
    """Interface gestionnaire moderne (ancien superviseur)"""
    st.header("üëî Tableau de Bord Gestionnaire")
    
    # V√©rifier l'authentification
    if not st.session_state.auth or st.session_state.auth.get("role") != "supervisor":
        render_login_card("gestionnaire", conn)
        return
    
    # Dashboard moderne
    render_dashboard_gestionnaire(conn, geo)
    
    # Tabs
    tabs = st.tabs([
        "üìä Vue d'ensemble",
        "üë• √âquipes",
        "üó∫Ô∏è Assignation",
        "üì• Export",
        "üõ† Tech"
    ])
    
    with tabs[0]:
        # Carte g√©n√©rale
        st.markdown("### Carte g√©n√©rale")
        df_all = db.list_streets(conn)
        if not df_all.empty:
            m = create_map(df_all, geo)
            st_folium(m, height=800, width=None, returned_objects=[])
        
        # Activit√© r√©cente
        st.markdown("### Activit√© r√©cente")
        try:
            recent = db.recent_activity(conn, limit=10)
            if not recent.empty:
                st.dataframe(recent, width="stretch")
            else:
                st.info("Aucune activit√© r√©cente")
        except:
            st.info("Historique d'activit√© non disponible")
    
    with tabs[1]:
        # Gestion des √©quipes
        st.subheader("üë• Gestion des √©quipes", anchor=False)
        
        # === Formulaire de cr√©ation d'√©quipe (robuste) ===
        with st.expander("‚ûï Cr√©er une nouvelle √©quipe", expanded=False):
            with st.form("create_team_form", clear_on_submit=True):
                team_id_in = st.text_input(
                    "Identifiant d'√©quipe", 
                    key="new_team_id", 
                    placeholder="Ex: EQUIPE1",
                    help="Lettres et chiffres uniquement, max 20 caract√®res"
                )
                team_name_in = st.text_input(
                    "Nom d'√©quipe", 
                    key="new_team_name", 
                    placeholder="Ex: √âquipe Centre",
                    help="Nom descriptif de l'√©quipe"
                )
                
                # Toggle pour afficher/masquer les mots de passe
                show_pw = st.checkbox("Afficher les mots de passe", value=False)
                pw_type = "default" if show_pw else "password"
                
                pwd_in = st.text_input(
                    "Mot de passe", 
                    type=pw_type, 
                    key="new_team_pwd", 
                    placeholder="Minimum 4 caract√®res",
                    help="Tout caract√®re accept√©, min 4 / max 128"
                )
                pwd_conf = st.text_input(
                    "Confirmer le mot de passe", 
                    type=pw_type, 
                    key="new_team_pwd_conf", 
                    placeholder="Retapez le mot de passe",
                    help="Doit correspondre au mot de passe ci-dessus"
                )
                
                submitted = st.form_submit_button("‚úÖ Cr√©er l'√©quipe", width="stretch")

            if submitted:
                # Validation avec validators.py
                ok_id, team_id = validate_and_clean_input("team_id", team_id_in)
                ok_name, team_name = validate_and_clean_input("text", team_name_in)
                ok_pw, password = validate_and_clean_input("password", pwd_in)
                
                if not ok_id:
                    st.error("‚ùå Identifiant d'√©quipe invalide (lettres/chiffres, max 20)")
                elif not ok_name:
                    st.error("‚ùå Nom d'√©quipe invalide ou vide")
                elif not ok_pw:
                    st.error("‚ùå Mot de passe invalide (minimum 4 caract√®res)")
                elif pwd_in != pwd_conf:
                    st.error("‚ùå Les mots de passe ne correspondent pas")
                else:
                    # Tentative de cr√©ation avec db.create_team
                    try:
                        created = db.create_team(conn, team_id, team_name, password)
                        if created:
                            st.toast(f"‚úÖ √âquipe {team_id} cr√©√©e avec succ√®s", icon="‚úÖ")
                            st.rerun()
                        else:
                            st.error("‚ùå √âchec de cr√©ation (ID d√©j√† existant ?)")
                    except Exception as e:
                        st.error(f"‚ùå Erreur lors de la cr√©ation: {e}")
        
        # === Liste des √©quipes (sans doublon de titre) ===
        try:
            teams_df = db.get_all_teams(conn)
            if not teams_df.empty:
                st.dataframe(teams_df, width="stretch")
            else:
                st.info("Aucune √©quipe cr√©√©e")
        except Exception as e:
            st.info("Liste des √©quipes non disponible")
    
    with tabs[2]:
        # Assignation v4.1
        page_assignations_v41(conn)
    
    with tabs[3]:
        # Export am√©lior√© v4.1
        page_export_gestionnaire_v41(conn)

    with tabs[4]:
        st.markdown("### üõ† Op√©rations techniques (prot√©g√©es)")

        # -- PIN stock√© dans secrets (config.toml -> [secrets] TECH_PIN="xxxx")
        try:
            TECH_PIN = st.secrets.get("TECH_PIN", "")
        except:
            TECH_PIN = ""  # Pas de fichier secrets.toml

        if "tech_ok" not in st.session_state:
            st.session_state.tech_ok = False

        if not st.session_state.tech_ok:
            pin = st.text_input("Entrer le PIN technique", type="password")
            if st.button("D√©verrouiller"):
                if TECH_PIN and pin == TECH_PIN:
                    st.session_state.tech_ok = True
                    st.success("Acc√®s technique d√©verrouill√©.")
                    st.rerun()
                else:
                    st.error("PIN invalide.")
            st.stop()

        st.info("‚ö†Ô∏è Ces actions sont lourdes et n'affectent pas les statuts/notes. Elles r√©g√©n√®rent les caches OSM.")

        # --- Reconstruire le cache g√©om√©trique (lourd)
        with st.expander("üîÑ Reconstruire cache OSM (g√©om√©tries)", expanded=False):
            col1, col2 = st.columns([1,2])
            with col1:
                confirm = st.checkbox("Je comprends les implications")
            with col2:
                safety = st.text_input('√âcrire "REBUILD" pour confirmer')

            if st.button("Lancer la reconstruction"):
                if confirm and safety.strip().upper() == "REBUILD":
                    with st.spinner("Construction du cache‚Ä¶"):
                        build_geometry_cache()       # reconstruit le fichier osm_cache.json
                        st.cache_data.clear()        # purge cache Streamlit
                    st.success("‚úÖ Cache OSM mis √† jour (g√©om√©tries).")
                    st.rerun()
                else:
                    st.warning("Confirmation incompl√®te.")

        # --- Reconstruire/Importer le cache des adresses
        with st.expander("üìç Mettre √† jour les adresses (OSM)", expanded=False):
            col1, col2 = st.columns([1,2])
            with col1:
                confirmA = st.checkbox("Je confirme")
            with col2:
                safetyA = st.text_input('√âcrire "IMPORT" pour confirmer')

            if st.button("Lancer la mise √† jour des adresses"):
                if confirmA and safetyA.strip().upper() == "IMPORT":
                    with st.spinner("T√©l√©chargement des adresses OSM‚Ä¶"):
                        build_addresses_cache()
                        addr_cache = load_addresses_cache()
                        count = db.import_addresses_from_cache(conn, addr_cache)
                    st.success(f"‚úÖ {count} adresses import√©es depuis OSM.")
                    st.rerun()
                else:
                    st.warning("Confirmation incompl√®te.")

        # --- Gestion des backups
        with st.expander("üíæ Gestion des backups", expanded=False):
            backup_mgr = db.get_backup_manager(DB_PATH)
            
            col1, col2 = st.columns([2, 1])
            with col1:
                if st.button("üîÑ Cr√©er un backup manuel", width="stretch"):
                    backup_file = backup_mgr.create_backup("manual")
                    if backup_file:
                        st.success(f"Backup cr√©√© : {Path(backup_file).name}")
            
            with col2:
                if st.button("üìã Voir les backups", width="stretch"):
                    backups = backup_mgr.list_backups()
                    if backups:
                        for backup in backups[:5]:  # Montrer les 5 derniers
                            st.text(f"‚Ä¢ {backup['name']} ({backup['size']})")
                    else:
                        st.info("Aucun backup disponible")

def page_superviseur(conn, geo):
    """Interface superviseur"""
    st.header("üéØ Tableau de Bord Superviseur")
    
    # V√©rifier l'authentification
    if not st.session_state.auth or st.session_state.auth.get("role") != "supervisor":
        render_login_card("superviseur", conn)
        return
    
    # Dashboard moderne
    render_dashboard_gestionnaire(conn, geo)
    
    # Tabs
    tabs = st.tabs([
        "üìä Vue d'ensemble",
        "üë• √âquipes",
        "üó∫Ô∏è Assignation",
        "üì• Export",
        "üõ† Tech"
    ])
    
    with tabs[0]:
        # Carte g√©n√©rale
        st.markdown("### Carte g√©n√©rale")
        df_all = db.list_streets(conn)
        if not df_all.empty:
            m = create_map(df_all, geo)
            st_folium(m, height=800, width=None, returned_objects=[])
        
        # Activit√© r√©cente
        st.markdown("### Activit√© r√©cente")
        recent = db.recent_activity(conn, limit=10)
        if not recent.empty:
            st.dataframe(recent, width="stretch")
    
    with tabs[1]:
        # Gestion des √©quipes
        st.markdown("### Gestion des √©quipes")
        
        with st.expander("Cr√©er une √©quipe"):
            with st.form("new_team", clear_on_submit=True):
                new_id = st.text_input("Identifiant")
                new_name = st.text_input("√âquipe")
                new_pass = st.text_input("Mot de passe", type="password")
                
                if st.form_submit_button("Cr√©er"):
                    if all([new_id, new_name, new_pass]):
                        if db.create_team(conn, new_id, new_name, new_pass):
                            st.success(f"√âquipe {new_id} cr√©√©e")
                            st.rerun()
        
        # Liste des √©quipes
        teams_df = db.get_all_teams(conn)
        if not teams_df.empty:
            st.dataframe(teams_df, width="stretch")
    
    with tabs[2]:
        # Assignation
        st.markdown("### Assignation des rues")
        
        unassigned = db.get_unassigned_streets(conn)
        
        if not unassigned.empty:
            with st.form("assign"):
                team = st.selectbox("√âquipe", db.teams(conn))
                streets = st.multiselect("Rues", unassigned['name'].tolist())
                
                if st.form_submit_button("Assigner"):
                    if team and streets:
                        db.assign_streets_to_team(conn, streets, team)
                        st.success("Rues assign√©es!")
                        st.rerun()
        else:
            st.success("Toutes les rues sont assign√©es!")
        
        # Tableau des assignations
        df_all = db.list_streets(conn)
        if not df_all.empty:
            st.dataframe(
                df_all[['name', 'sector', 'team', 'status']],
                width="stretch"
            )
    
    with tabs[3]:
        # Export
        st.markdown("### Export des donn√©es")
        
        col1, col2 = st.columns(2)
        
        with col1:
            st.download_button(
                "üì• Export rues (CSV)",
                db.export_to_csv(conn),
                "rapport_rues.csv",
                "text/csv",
                width="stretch"
            )
        
        with col2:
            st.download_button(
                "üì• Export notes (CSV)",
                db.export_notes_csv(conn),
                "rapport_notes.csv",
                "text/csv",
                width="stretch"
            )

    with tabs[4]:
        st.markdown("### üõ† Op√©rations techniques (prot√©g√©es)")

        # -- PIN stock√© dans secrets (config.toml -> [secrets] TECH_PIN="xxxx")  
        try:
            TECH_PIN = st.secrets.get("TECH_PIN", "")
        except:
            TECH_PIN = ""  # Pas de fichier secrets.toml

        if "tech_ok" not in st.session_state:
            st.session_state.tech_ok = False

        if not st.session_state.tech_ok:
            pin = st.text_input("Entrer le PIN technique", type="password")
            if st.button("D√©verrouiller"):
                if TECH_PIN and pin == TECH_PIN:
                    st.session_state.tech_ok = True
                    st.success("Acc√®s technique d√©verrouill√©.")
                    st.rerun()
                else:
                    st.error("PIN invalide.")
            st.stop()

        st.info("‚ö†Ô∏è Ces actions sont lourdes et n'affectent pas les statuts/notes. Elles r√©g√©n√®rent les caches OSM.")

        # --- Reconstruire le cache g√©om√©trique (lourd)
        with st.expander("üîÑ Reconstruire cache OSM (g√©om√©tries)", expanded=False):
            col1, col2 = st.columns([1,2])
            with col1:
                confirm = st.checkbox("Je comprends les implications")
            with col2:
                safety = st.text_input('√âcrire "REBUILD" pour confirmer')

            if st.button("Lancer la reconstruction"):
                if confirm and safety.strip().upper() == "REBUILD":
                    with st.spinner("Construction du cache‚Ä¶"):
                        build_geometry_cache()       # reconstruit le fichier osm_cache.json
                        st.cache_data.clear()        # purge cache Streamlit
                    st.success("‚úÖ Cache OSM mis √† jour (g√©om√©tries).")
                    st.rerun()
                else:
                    st.warning("Confirmation incompl√®te.")

        # --- Reconstruire/Importer le cache des adresses
        with st.expander("üìç Mettre √† jour les adresses (OSM)", expanded=False):
            col1, col2 = st.columns([1,2])
            with col1:
                confirmA = st.checkbox("Je confirme")
            with col2:
                safetyA = st.text_input('√âcrire "IMPORT" pour confirmer')

            if st.button("Lancer la mise √† jour des adresses"):
                if confirmA and safetyA.strip().upper() == "IMPORT":
                    with st.spinner("T√©l√©chargement des adresses OSM‚Ä¶"):
                        build_addresses_cache()
                        addr_cache = load_addresses_cache()
                        count = db.import_addresses_from_cache(conn, addr_cache)
                    st.success(f"‚úÖ {count} adresses import√©es depuis OSM.")
                    st.rerun()
                else:
                    st.warning("Confirmation incompl√®te.")

# ============================================
# MAIN
# ============================================

# ================================================================================
# NOUVELLES FONCTIONS v4.1 - SUPERVISEUR ET B√âN√âVOLE
# ================================================================================

def page_assignations_v41(conn):
    """Panneau d'assignations v4.1 pour superviseurs"""
    
    try:
        # ===== Bloc Assignations (refactor propre) =====
        st.subheader("üó∫Ô∏è Assignations par secteur", anchor=False)
        
        # Compteur de rues non assign√©es (banni√®re info)
        unassigned_count = db.get_unassigned_streets_count(conn)
        if unassigned_count > 0:
            st.info(f"‚ö†Ô∏è {unassigned_count} rue(s) non assign√©e(s)")
        
        with st.container():
            c1, c2, c3 = st.columns([1, 1.2, 0.7], vertical_alignment="bottom")
            
            with c1:
                # R√©cup√©rer la liste des secteurs
                liste_secteurs = db.get_sectors_list(conn)
                secteur = st.selectbox(
                    "SECTEUR √Ä ASSIGNER",
                    options=[""] + (liste_secteurs if liste_secteurs else []),
                    index=0,
                    key="assign_sector",
                    help="Choisissez le secteur √† assigner",
                    label_visibility="visible",
                )
            
            with c2:
                # R√©cup√©rer la liste des √©quipes
                teams = db.get_teams_list(conn)
                liste_equipes = [f"{team[1]} ({team[0]})" for team in teams] if teams else []
                
                if liste_equipes:
                    team_display = st.selectbox(
                        "√âQUIPE", 
                        options=[""] + liste_equipes, 
                        index=0, 
                        key="assign_team"
                    )
                    # Extraire l'ID de l'√©quipe
                    team = ""
                    if team_display and team_display != "":
                        team = team_display.split("(")[-1].rstrip(")")
                else:
                    st.info("Aucune √©quipe disponible")
                    team = None
            
            with c3:
                disabled = not (secteur and team)
                if st.button("üéØ Assigner tout le secteur", width="stretch", disabled=disabled):
                    # Appel m√©tier : assigner toutes les rues non assign√©es du secteur √† l'√©quipe
                    if secteur and team:
                        try:
                            nb = db.bulk_assign_sector(conn, secteur, team)
                            if nb > 0:
                                st.toast(f"‚úÖ {nb} rue(s) assign√©e(s) √† l'√©quipe {team}", icon="‚úÖ")
                                st.rerun()
                            else:
                                st.toast("‚ÑπÔ∏è Aucune rue non assign√©e dans ce secteur", icon="‚ÑπÔ∏è")
                        except Exception as e:
                            st.error(f"Erreur lors de l'assignation: {e}")
        
        # ===== Tableau d'√©tat (uniforme, sans style sp√©cial) =====
        st.markdown("### üìã √âtat des assignations")
        
        df = db.list_streets(conn)
        if not df.empty:
            df_disp = df.assign(
                Statut=df["status"].map(STATUS_TO_LABEL).fillna("√Ä faire")
            ).rename(columns={
                "name": "Rue", 
                "sector": "Secteur", 
                "team": "√âquipe"
            })[["Rue", "Secteur", "√âquipe", "Statut"]]
            
            st.dataframe(df_disp, width="stretch")  # aucun Styler, aucun CSS cellule
        else:
            st.info("Aucune rue trouv√©e")
            
    except Exception as e:
        st.error(f"Erreur dans le panneau d'assignations: {e}")
        st.info("Fonctionnalit√© temporairement indisponible")

def page_export_gestionnaire_v41(conn):
    """Page d'export v4.1 avec nouvelles fonctionnalit√©s"""
    st.markdown("### üì• Export des donn√©es")
    
    col1, col2, col3 = st.columns(3)
    
    with col1:
        # Export CSV standard
        try:
            st.download_button(
                "üì• Export CSV Standard",
                db.export_to_csv(conn),
                "rapport_rues.csv",
                "text/csv",
                width="stretch"
            )
        except Exception as e:
            st.button("üì• CSV (Erreur)", disabled=True, width="stretch")
            st.caption(f"Erreur: {e}")
    
    with col2:
        # Export Excel professionnel
        try:
            from reports import ReportGenerator
            generator = ReportGenerator(conn)
            excel_data = generator.generate_excel()
            st.download_button(
                "üìä Export Excel Pro",
                excel_data,
                "guignolee_2025_rapport.xlsx",
                "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
                width="stretch"
            )
        except ImportError:
            st.button("üìä Excel (Installer xlsxwriter)", disabled=True, width="stretch")
        except Exception as e:
            st.button("üìä Excel (Erreur)", disabled=True, width="stretch")
            st.caption(f"Erreur: {e}")
    
    with col3:
        # Export PDF professionnel
        try:
            from reports import ReportGenerator
            generator = ReportGenerator(conn)
            pdf_data = generator.generate_pdf()
            st.download_button(
                "üìÑ Export PDF Pro",
                pdf_data,
                "guignolee_2025_rapport.pdf",
                "application/pdf",
                width="stretch"
            )
        except ImportError:
            st.button("üìÑ PDF (Installer reportlab)", disabled=True, width="stretch")
        except Exception as e:
            st.button("üìÑ PDF (Erreur)", disabled=True, width="stretch")
            st.caption(f"Erreur: {e}")
    
    # Export CSV assignations (nouveau v4.1)
    st.markdown("---")
    st.markdown("### üìã Export sp√©cialis√©s v4.1")
    
    col1, col2, col3 = st.columns(3)
    
    with col1:
        # Export CSV assignations
        try:
            assignations_data = db.get_assignations_export_data(conn)
            if not assignations_data.empty:
                csv_data = assignations_data.to_csv(index=False, encoding='utf-8')
                st.download_button(
                    "üìã Export CSV Assignations",
                    csv_data,
                    "assignations_secteurs.csv",
                    "text/csv",
                    width="stretch",
                    help="Colonnes: secteur, rue, √©quipe, statut"
                )
            else:
                st.button("üìã Assignations (Aucune donn√©e)", disabled=True, width="stretch")
        except Exception as e:
            st.button("üìã Assignations (Erreur)", disabled=True, width="stretch")
            st.caption(f"Erreur: {e}")
    
    with col2:
        # Export notes
        try:
            st.download_button(
                "üìù Export Notes",
                db.export_notes_csv(conn),
                "rapport_notes.csv",
                "text/csv",
                width="stretch"
            )
        except Exception as e:
            st.button("üìù Notes (Erreur)", disabled=True, width="stretch")
            st.caption(f"Erreur: {e}")

def page_benevole_mes_rues(conn):
    """Vue 'Mes rues' pour b√©n√©voles v4.1"""
    
    # R√©cup√©rer l'√©quipe du b√©n√©vole connect√©
    if not st.session_state.auth or st.session_state.auth.get("role") != "volunteer":
        st.warning("Acc√®s r√©serv√© aux b√©n√©voles connect√©s")
        return
    
    team_id = st.session_state.auth.get("team")
    if not team_id:
        st.error("√âquipe non identifi√©e")
        return
    
    st.markdown(f"### üèòÔ∏è Mes rues assign√©es - √âquipe {team_id}")
    
    try:
        # R√©cup√©rer les rues de l'√©quipe
        team_streets = db.get_team_streets(conn, team_id)
        
        if team_streets.empty:
            st.info("Aucune rue assign√©e √† votre √©quipe pour le moment.")
            return
        
        # Afficher les statistiques de l'√©quipe
        total_streets = len(team_streets)
        done_streets = len(team_streets[team_streets['status'] == 'terminee'])
        in_progress = len(team_streets[team_streets['status'] == 'en_cours'])
        
        col1, col2, col3, col4 = st.columns(4)
        with col1:
            st.metric("Total rues", total_streets)
        with col2:
            st.metric("Termin√©es", done_streets)
        with col3:
            st.metric("En cours", in_progress)
        with col4:
            progress = (done_streets / total_streets * 100) if total_streets > 0 else 0
            st.metric("Progression", f"{progress:.1f}%")
        
        st.markdown("---")
        
        # Affichage par rue avec actions
        for _, street in team_streets.iterrows():
            street_name = street['street_name']
            current_status = street['status']
            notes_count = street['notes_count']
            
            with st.expander(f"üèòÔ∏è {street_name} ({street['sector']}) - {current_status.replace('_', ' ').title()}", 
                           expanded=current_status == 'en_cours'):
                
                col1, col2, col3 = st.columns([2, 1, 1])
                
                with col1:
                    st.markdown(f"**Secteur:** {street['sector']}")
                    st.markdown(f"**Statut actuel:** {current_status.replace('_', ' ').title()}")
                    if notes_count > 0:
                        st.markdown(f"**Notes existantes:** {notes_count}")
                
                with col2:
                    # Bouton "En cours"
                    if st.button(
                        "üöÄ En cours", 
                        key=f"progress_{street_name}",
                        disabled=current_status == 'en_cours',
                        width="stretch"
                    ):
                        if db.update_street_status(conn, street_name, 'en_cours', team_id):
                            st.toast(f"‚úÖ {street_name} marqu√©e en cours", icon="üöÄ")
                            st.rerun()
                        else:
                            st.error("Erreur lors de la mise √† jour")
                
                with col3:
                    # Bouton "Termin√©e"
                    if st.button(
                        "‚úÖ Termin√©e", 
                        key=f"done_{street_name}",
                        disabled=current_status == 'terminee',
                        width="stretch"
                    ):
                        if db.update_street_status(conn, street_name, 'terminee', team_id):
                            st.toast(f"üéâ {street_name} termin√©e!", icon="üéâ")
                            st.rerun()
                        else:
                            st.error("Erreur lors de la mise √† jour")
                
                # Section notes
                st.markdown("**Gestion des notes:**")
                
                # Afficher les notes existantes
                existing_notes = db.get_street_notes_for_team(conn, street_name, team_id)
                if existing_notes:
                    st.markdown("*Notes existantes:*")
                    for note in existing_notes:
                        st.markdown(f"‚Ä¢ **#{note[0]}** : {note[1]} _{note[2]}_")
                
                # Ajouter une nouvelle note
                with st.form(f"note_form_{street_name}"):
                    col_addr, col_note = st.columns([1, 3])
                    with col_addr:
                        address_number = st.text_input(
                            "N¬∞ civique", 
                            key=f"addr_{street_name}",
                            placeholder="123A"
                        )
                    with col_note:
                        comment = st.text_area(
                            "Commentaire", 
                            key=f"comment_{street_name}",
                            placeholder="Ex: Absent, refus, don re√ßu...",
                            max_chars=500,
                            height=80
                        )
                    
                    if st.form_submit_button("üíæ Enregistrer note"):
                        if address_number and comment:
                            if db.add_street_note(conn, street_name, team_id, address_number, comment):
                                st.toast(f"üìù Note ajout√©e pour {street_name} #{address_number}", icon="üìù")
                                st.rerun()
                            else:
                                st.error("Erreur lors de l'enregistrement de la note")
                        else:
                            st.warning("Veuillez remplir le num√©ro et le commentaire")
                            
    except Exception as e:
        st.error(f"Erreur lors du chargement de vos rues: {e}")
        st.info("Fonctionnalit√© temporairement indisponible")

def main():
    """Point d'entr√©e principal - Version 2.0 Guignol√©e"""
    
    # CSS moderne
    inject_css()
    
    # Connexion DB
    conn = db.get_conn(DB_PATH)
    db.init_db(conn)
    st.session_state['conn'] = conn
    
    # Cache g√©om√©trique
    @st.cache_data(ttl=None)
    def get_geo(_sig):
        data = load_geometry_cache()
        return data if data else {}
    
    sig = int(CACHE_FILE.stat().st_mtime_ns) if CACHE_FILE.exists() else 0
    geo = get_geo(sig)
    
    # Header festif
    render_header()
    
    # Navigation modernis√©e dans la sidebar
    with st.sidebar:
        # CSS pour la sidebar sans position absolue
        st.markdown("""
        <style>
        .css-1d391kg { padding-top: 1rem !important; }
        .stSidebar > div:first-child { padding-top: 1rem !important; }
        </style>
        """, unsafe_allow_html=True)
        
        # Logo en haut de la sidebar (position normale)
        logo_path = ASSETS / "logo.png"
        if logo_path.exists():
            col1, col2, col3 = st.columns([1, 2, 1])
            with col2:
                st.image(str(logo_path), width=150)
            st.markdown("<div style='height: 20px;'></div>", unsafe_allow_html=True)
        else:
            # Placeholder centr√©
            st.markdown("""
            <div style="
                background: linear-gradient(135deg, #c41e3a, #165b33);
                border-radius: 15px;
                padding: 2rem;
                color: white;
                text-align: center;
                margin: 1rem 0;
                box-shadow: 0 4px 15px rgba(0,0,0,0.3);
            ">
                <div style="font-size: 2.5rem;">üéÅ</div>
                <div style="font-weight: bold; font-size: 1.2rem;">LOGO</div>
                <small>Espace r√©serv√©</small>
            </div>
            """, unsafe_allow_html=True)
            st.markdown("<div style='height: 20px;'></div>", unsafe_allow_html=True)
        
        # Navigation
        st.markdown("### üéÑ Navigation")
        
        # Boutons de navigation stylis√©s
        if st.button("üè† Accueil", width="stretch"):
            st.session_state.page = "accueil"
            st.rerun()
        
        if st.button("üéÖ B√©n√©vole", width="stretch"):
            st.session_state.page = "benevole"
            st.rerun()
            
        if st.button("üëî Gestionnaire", width="stretch"):
            st.session_state.page = "gestionnaire"  
            st.rerun()
        
        # D√©connexion si connect√©
        if st.session_state.auth:
            st.markdown("---")
            if st.button("üö™ D√©connexion", width="stretch"):
                st.session_state.auth = None
                st.rerun()
        
        # Compteur temps r√©el
        st.markdown("---")
        stats = db.extended_stats(conn)
        st.markdown(f"""
        <div style="text-align: center;">
            <h4>√âtat de la collecte</h4>
            <div style="font-size: 2rem; color: #FFD700;">
                {stats['done']}/{stats['total']}
            </div>
            <small>Rues compl√©t√©es</small>
        </div>
        """, unsafe_allow_html=True)
    
    # Routing pages
    page = st.session_state.get('page', 'accueil')
    
    if page == "accueil":
        page_accueil_v2(conn, geo)
    elif page == "benevole":
        page_benevole_v2(conn, geo)
    elif page == "gestionnaire":
        page_gestionnaire_v2(conn, geo)
    
    # Footer festif
    st.markdown("""
    <div style="
        text-align: center;
        padding: 2rem;
        margin-top: 3rem;
        border-top: 2px solid rgba(255,215,0,0.3);
        color: #8b92a4;
    ">
        <p>
            üéÑ Guignol√©e 2025 - Le Relais de Mascouche üéÑ<br>
            <small>Ensemble, redonnons espoir | üìû 450-474-4133</small>
        </p>
    </div>
    """, unsafe_allow_html=True)
    
    # Banni√®re en bas de page
    if (ASSETS / "banner.png").exists():
        st.image(str(ASSETS / "banner.png"), width="stretch")

if __name__ == "__main__":
    main()


```n
================================================================================
## FICHIER 2: guignomap/db.py (Gestion base de donn√©es)

```python

import sqlite3
import pandas as pd
import hashlib
import bcrypt
from backup import auto_backup_before_critical, BackupManager
from validators import validate_and_clean_input, InputValidator
from datetime import datetime
import json
from pathlib import Path
import os
import secrets
import string

# Sch√©ma am√©lior√© de la base de donn√©es
SCHEMA = """
-- Table des rues
CREATE TABLE IF NOT EXISTS streets (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT NOT NULL UNIQUE,
    sector TEXT,
    team TEXT,
    status TEXT NOT NULL DEFAULT 'a_faire' 
        CHECK (status IN ('a_faire', 'en_cours', 'terminee'))
);

-- Table des √©quipes
CREATE TABLE IF NOT EXISTS teams (
    id TEXT PRIMARY KEY,
    name TEXT NOT NULL,
    password_hash TEXT NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    active BOOLEAN DEFAULT 1
);

-- Table des notes/commentaires PAR ADRESSE
CREATE TABLE IF NOT EXISTS notes (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    street_name TEXT NOT NULL,
    team_id TEXT NOT NULL,
    address_number TEXT,
    comment TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (street_name) REFERENCES streets(name),
    FOREIGN KEY (team_id) REFERENCES teams(id)
);

-- Table d'activit√© (log)
CREATE TABLE IF NOT EXISTS activity_log (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    team_id TEXT,
    action TEXT NOT NULL,
    details TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Table des adresses OSM
CREATE TABLE IF NOT EXISTS addresses (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    street_name TEXT NOT NULL,
    house_number TEXT NOT NULL,
    latitude REAL,
    longitude REAL,
    osm_type TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (street_name) REFERENCES streets(name)
);

-- Index pour am√©liorer les performances
CREATE INDEX IF NOT EXISTS idx_streets_team ON streets(team);
CREATE INDEX IF NOT EXISTS idx_streets_status ON streets(status);
CREATE INDEX IF NOT EXISTS idx_notes_street ON notes(street_name);
CREATE INDEX IF NOT EXISTS idx_activity_created ON activity_log(created_at DESC);
CREATE INDEX IF NOT EXISTS idx_addresses_street ON addresses(street_name);
CREATE INDEX IF NOT EXISTS idx_addresses_number ON addresses(house_number);
"""

def get_conn(db_path):
    """Cr√©e une connexion √† la base de donn√©es"""
    conn = sqlite3.connect(db_path, check_same_thread=False)
    conn.row_factory = sqlite3.Row
    return conn

def init_db(conn):
    """Initialise la base de donn√©es avec le sch√©ma et les donn√©es initiales"""
    try:
        # Cr√©er les tables si elles n'existent pas
        conn.executescript(SCHEMA)
        conn.commit()
        
        # Cr√©er un compte admin par d√©faut s'il n'existe pas
        cursor = conn.execute("SELECT COUNT(*) FROM teams WHERE id = 'ADMIN'")
        if cursor.fetchone()[0] == 0:
            pwd = os.getenv("GM_ADMIN_PWD", "RELAIS2025")  # Par d√©faut RELAIS2025
            create_team(conn, 'ADMIN', 'Superviseur', pwd)
        
        # AUTO-IMPORT : Si aucune rue n'existe, importer automatiquement depuis OSM
        cursor = conn.execute("SELECT COUNT(*) FROM streets")
        if cursor.fetchone()[0] == 0:
            print("üîÑ Aucune rue trouv√©e. Import automatique depuis OpenStreetMap...")
            auto_import_streets(conn)
            
    except Exception as e:
        print(f"Erreur lors de l'initialisation de la DB: {e}")
        raise

@auto_backup_before_critical
def auto_import_streets(conn):
    """Import automatique des rues de Mascouche"""
    try:
        # Essayer d'abord avec OSM
        from osm import generate_streets_csv
        csv_data = generate_streets_csv("Mascouche")
        
        if csv_data:
            import io
            df = pd.read_csv(io.StringIO(csv_data.decode('utf-8')))
            
            if not df.empty:
                for _, row in df.iterrows():
                    conn.execute(
                        "INSERT OR IGNORE INTO streets(name, sector, team, status) VALUES (?, ?, ?, 'a_faire')",
                        (row.get("name", ""), row.get("sector", ""), row.get("team", ""))
                    )
                conn.commit()
                print(f"‚úÖ {len(df)} rues import√©es automatiquement")
                log_activity(conn, None, "AUTO_IMPORT", f"Import automatique de {len(df)} rues")
                return
    except Exception as e:
        print(f"‚ö†Ô∏è Erreur lors de l'import OSM: {e}")
    
    # Fallback : Donn√©es de test si OSM √©choue
    print("üì¶ Import de donn√©es de test...")
    test_streets = [
        ("Mont√©e Masson", "Centre", ""),
        ("Chemin Sainte-Marie", "Centre", ""),
        ("Boulevard de Mascouche", "Centre", ""),
        ("Rue Dupras", "Centre", ""),
        ("Rue Saint-Pierre", "Centre", ""),
        ("Rue de l'√âglise", "Centre", ""),
        ("Avenue des √ârables", "Nord", ""),
        ("Rue des Pins", "Nord", ""),
        ("Rue Gravel", "Sud", ""),
        ("Rue Forget", "Sud", ""),
    ]
    
    for name, sector, team in test_streets:
        conn.execute(
            "INSERT OR IGNORE INTO streets(name, sector, team, status) VALUES (?, ?, ?, 'a_faire')",
            (name, sector, team)
        )
    conn.commit()
    print(f"‚úÖ {len(test_streets)} rues de test import√©es")

# ---------- Fonctions pour les √©quipes ----------
def hash_password(password):
    """Hash un mot de passe avec bcrypt et salt automatique"""
    salt = bcrypt.gensalt()
    hashed = bcrypt.hashpw(password.encode('utf-8'), salt)
    return hashed.decode('utf-8')

def create_team(conn, team_id, name, password):
    """Cr√©e une nouvelle √©quipe avec validation"""
    try:
        # Valider les entr√©es
        valid_id, clean_id = validate_and_clean_input("team_id", team_id)
        valid_name, clean_name = validate_and_clean_input("text", name)
        valid_pwd, _ = validate_and_clean_input("password", password)
        
        if not valid_id or not valid_name or not valid_pwd:
            return False
        
        conn.execute(
            "INSERT INTO teams (id, name, password_hash) VALUES (?, ?, ?)",
            (clean_id, clean_name, hash_password(password))
        )
        conn.commit()
        log_activity(conn, clean_id, "TEAM_CREATED", f"√âquipe {clean_name} cr√©√©e")
        return True
    except sqlite3.IntegrityError:
        return False

def verify_team(conn, team_id, password):
    """V√©rifie les identifiants d'une √©quipe avec bcrypt"""
    cursor = conn.execute(
        "SELECT password_hash FROM teams WHERE id = ? AND active = 1",
        (team_id,)
    )
    row = cursor.fetchone()
    if row:
        try:
            # Support ancien SHA256 pour migration
            stored_hash = row[0]
            if stored_hash.startswith('$2b$') or stored_hash.startswith('$2a$'):
                # Hash bcrypt
                return bcrypt.checkpw(password.encode('utf-8'), stored_hash.encode('utf-8'))
            else:
                # Ancien SHA256, v√©rifier et migrer
                if stored_hash == hashlib.sha256(password.encode()).hexdigest():
                    # Migrer vers bcrypt
                    new_hash = hash_password(password)
                    conn.execute("UPDATE teams SET password_hash = ? WHERE id = ?", (new_hash, team_id))
                    conn.commit()
                    return True
                return False
        except Exception as e:
            print(f"Erreur v√©rification mot de passe: {e}")
            return False
    return False

def migrate_all_passwords_to_bcrypt(conn):
    """Migration manuelle des mots de passe SHA256 vers bcrypt"""
    print("‚ö†Ô∏è Migration des mots de passe requise")
    print("Entrez les mots de passe actuels pour migration:")
    
    cursor = conn.execute("SELECT id, name FROM teams WHERE active = 1")
    teams = cursor.fetchall()
    
    for team_id, team_name in teams:
        if team_id == 'ADMIN':
            pwd = input(f"Mot de passe actuel pour {team_name} (ADMIN): ")
            if pwd:
                new_hash = hash_password(pwd)
                conn.execute("UPDATE teams SET password_hash = ? WHERE id = ?", (new_hash, team_id))
        
    conn.commit()
    print("‚úÖ Migration termin√©e")

def get_all_teams(conn):
    """R√©cup√®re toutes les √©quipes avec leurs statistiques"""
    query = """
    SELECT 
        t.id,
        t.name,
        t.created_at,
        COUNT(DISTINCT s.name) as streets_count,
        SUM(CASE WHEN s.status = 'terminee' THEN 1 ELSE 0 END) as done_count,
        CASE 
            WHEN COUNT(s.name) > 0 
            THEN (SUM(CASE WHEN s.status = 'terminee' THEN 1.0 ELSE 0 END) / COUNT(s.name)) * 100
            ELSE 0 
        END as progress
    FROM teams t
    LEFT JOIN streets s ON t.id = s.team
    WHERE t.active = 1 AND t.id != 'ADMIN'
    GROUP BY t.id, t.name, t.created_at
    ORDER BY t.id
    """
    return pd.read_sql_query(query, conn)

@auto_backup_before_critical
def delete_team(conn, team_id):
    """D√©sactive une √©quipe"""
    conn.execute("UPDATE teams SET active = 0 WHERE id = ?", (team_id,))
    conn.execute("UPDATE streets SET team = NULL WHERE team = ?", (team_id,))
    conn.commit()
    log_activity(conn, None, "TEAM_DELETED", f"√âquipe {team_id} supprim√©e")

def teams(conn):
    """Liste des IDs d'√©quipes actives"""
    cursor = conn.execute(
        "SELECT id FROM teams WHERE active = 1 AND id != 'ADMIN' ORDER BY id"
    )
    return [row[0] for row in cursor.fetchall()]

# ---------- Fonctions pour les rues ----------
def list_streets(conn, team=None):
    """Liste les rues, optionnellement filtr√©es par √©quipe"""
    try:
        if team:
            query = """
                SELECT 
                    s.name, 
                    COALESCE(s.sector, '') as sector, 
                    COALESCE(s.team, '') as team, 
                    COALESCE(s.status, 'a_faire') as status,
                    COUNT(n.id) as notes,
                    COUNT(DISTINCT n.address_number) as addresses_with_notes
                FROM streets s
                LEFT JOIN notes n ON s.name = n.street_name
                WHERE s.team = ?
                GROUP BY s.name, s.sector, s.team, s.status
                ORDER BY 
                    CASE s.status 
                        WHEN 'a_faire' THEN 1 
                        WHEN 'en_cours' THEN 2 
                        WHEN 'terminee' THEN 3 
                    END, 
                    s.name
            """
            df = pd.read_sql_query(query, conn, params=(team,))
        else:
            query = """
                SELECT 
                    s.name, 
                    COALESCE(s.sector, '') as sector, 
                    COALESCE(s.team, '') as team, 
                    COALESCE(s.status, 'a_faire') as status,
                    COUNT(n.id) as notes,
                    COUNT(DISTINCT n.address_number) as addresses_with_notes
                FROM streets s
                LEFT JOIN notes n ON s.name = n.street_name
                GROUP BY s.name, s.sector, s.team, s.status
                ORDER BY 
                    s.team, 
                    CASE s.status 
                        WHEN 'a_faire' THEN 1 
                        WHEN 'en_cours' THEN 2 
                        WHEN 'terminee' THEN 3 
                    END, 
                    s.name
            """
            df = pd.read_sql_query(query, conn)
        
        # S'assurer que toutes les colonnes existent
        for col in ['name', 'sector', 'team', 'status', 'notes', 'addresses_with_notes']:
            if col not in df.columns:
                df[col] = '' if col in ['sector', 'team'] else ('a_faire' if col == 'status' else 0)
        
        return df
        
    except Exception as e:
        print(f"Erreur list_streets: {e}")
        # Retourner un DataFrame vide avec la structure attendue
        return pd.DataFrame(columns=['name', 'sector', 'team', 'status', 'notes', 'addresses_with_notes'])

def get_unassigned_streets(conn):
    """R√©cup√®re les rues non assign√©es"""
    query = """
        SELECT name, sector 
        FROM streets 
        WHERE team IS NULL OR team = ''
        ORDER BY sector, name
    """
    return pd.read_sql_query(query, conn)

def assign_streets_to_team(conn, street_names, team_id):
    """Assigne plusieurs rues √† une √©quipe en une transaction"""
    try:
        for street_name in street_names:
            conn.execute(
                "UPDATE streets SET team = ? WHERE name = ?",
                (team_id, street_name)
            )
        conn.commit()
        log_activity(conn, team_id, "STREETS_ASSIGNED", f"{len(street_names)} rues assign√©es")
        return True
    except Exception as e:
        conn.rollback()
        print(f"Erreur lors de l'assignation: {e}")
        return False

def set_status(conn, name, status):
    """Met √† jour le statut d'une rue avec validation"""
    valid_name, clean_name = validate_and_clean_input("street_name", name)
    clean_status = InputValidator.validate_status(status)
    
    if not valid_name:
        print("‚ùå Nom de rue invalide")
        return False
    
    conn.execute(
        "UPDATE streets SET status = ? WHERE name = ?",
        (clean_status, clean_name)
    )
    conn.commit()
    
    cursor = conn.execute("SELECT team FROM streets WHERE name = ?", (clean_name,))
    row = cursor.fetchone()
    if row:
        log_activity(conn, row[0], f"STATUS_{clean_status.upper()}", f"Rue {clean_name}")
    return True

# ---------- Fonctions pour les notes PAR ADRESSE ----------
def add_note_for_address(conn, street_name, team_id, address_number, comment):
    """Ajoute une note pour une adresse sp√©cifique avec validation"""
    # Valider toutes les entr√©es
    valid_street, clean_street = validate_and_clean_input("street_name", street_name)
    valid_team, clean_team = validate_and_clean_input("team_id", team_id)
    valid_addr, clean_addr = validate_and_clean_input("address", address_number)
    valid_note, clean_note = validate_and_clean_input("note", comment)
    
    if not all([valid_street, valid_team, valid_addr, valid_note]):
        print("‚ùå Donn√©es invalides pour la note")
        return False
    
    conn.execute(
        """INSERT INTO notes (street_name, team_id, address_number, comment) 
           VALUES (?, ?, ?, ?)""",
        (clean_street, clean_team, clean_addr, clean_note)
    )
    
    # Met automatiquement le statut √† "en_cours" si c'√©tait "a_faire"
    conn.execute(
        """UPDATE streets 
           SET status = CASE 
               WHEN status = 'a_faire' THEN 'en_cours' 
               ELSE status 
           END
           WHERE name = ?""",
        (clean_street,)
    )
    
    conn.commit()
    log_activity(conn, clean_team, "NOTE_ADDED", f"Note ajout√©e pour {clean_addr} {clean_street}")
    return True

def get_street_addresses_with_notes(conn, street_name):
    """R√©cup√®re toutes les adresses avec notes pour une rue"""
    query = """
        SELECT 
            n.address_number,
            n.comment,
            n.created_at,
            t.name as team_name
        FROM notes n
        JOIN teams t ON n.team_id = t.id
        WHERE n.street_name = ?
        ORDER BY 
            CAST(n.address_number AS INTEGER),
            n.created_at DESC
    """
    return pd.read_sql_query(query, conn, params=(street_name,))

def get_team_notes(conn, team_id):
    """R√©cup√®re toutes les notes d'une √©quipe"""
    query = """
        SELECT 
            street_name, 
            address_number, 
            comment, 
            created_at
        FROM notes
        WHERE team_id = ?
        ORDER BY created_at DESC
        LIMIT 50
    """
    return pd.read_sql_query(query, conn, params=(team_id,))

# ---------- Fonctions de statistiques ----------
def extended_stats(conn):
    """Statistiques √©tendues avec d√©tails par adresse"""
    cursor = conn.execute("""
        SELECT 
            COUNT(DISTINCT s.name) as total,
            SUM(CASE WHEN s.status = 'terminee' THEN 1 ELSE 0 END) as done,
            SUM(CASE WHEN s.status = 'en_cours' THEN 1 ELSE 0 END) as partial,
            SUM(CASE WHEN s.status = 'a_faire' THEN 1 ELSE 0 END) as todo,
            COUNT(DISTINCT n.id) as total_notes,
            COUNT(DISTINCT n.address_number || n.street_name) as addresses_with_notes
        FROM streets s
        LEFT JOIN notes n ON s.name = n.street_name
    """)
    row = cursor.fetchone()
    return {
        "total": row[0] or 0,
        "done": row[1] or 0,
        "partial": row[2] or 0,
        "todo": row[3] or 0,
        "total_notes": row[4] or 0,
        "addresses_with_notes": row[5] or 0
    }

def stats_by_team(conn):
    """Statistiques par √©quipe"""
    query = """
        SELECT 
            s.team,
            COUNT(DISTINCT s.name) as total,
            SUM(CASE WHEN s.status = 'terminee' THEN 1 ELSE 0 END) as done,
            SUM(CASE WHEN s.status = 'en_cours' THEN 1 ELSE 0 END) as partial,
            COUNT(DISTINCT n.id) as notes,
            ROUND(
                (SUM(CASE WHEN s.status = 'terminee' THEN 1.0 ELSE 0 END) / COUNT(*)) * 100, 
                1
            ) as progress
        FROM streets s
        LEFT JOIN notes n ON s.name = n.street_name AND n.team_id = s.team
        WHERE s.team IS NOT NULL AND s.team != ''
        GROUP BY s.team
        ORDER BY progress DESC
    """
    return pd.read_sql_query(query, conn)

# ---------- Fonctions d'activit√© ----------
def recent_activity(conn, limit=10):
    """R√©cup√®re l'activit√© r√©cente"""
    query = """
        SELECT 
            datetime(created_at, 'localtime') as timestamp,
            COALESCE(team_id, 'SYSTEM') as team,
            action,
            details
        FROM activity_log
        ORDER BY created_at DESC
        LIMIT ?
    """
    return pd.read_sql_query(query, conn, params=(limit,))

# ---------- Fonctions d'export ----------
def export_to_csv(conn):
    """Exporte toutes les donn√©es en CSV"""
    query = """
        SELECT 
            s.name as rue,
            s.sector as secteur,
            s.team as equipe,
            s.status as statut,
            COUNT(DISTINCT n.id) as nombre_notes,
            COUNT(DISTINCT n.address_number) as adresses_avec_notes
        FROM streets s
        LEFT JOIN notes n ON s.name = n.street_name
        GROUP BY s.name, s.sector, s.team, s.status
        ORDER BY s.team, s.name
    """
    df = pd.read_sql_query(query, conn)
    return df.to_csv(index=False).encode('utf-8')

def export_notes_csv(conn):
    """Exporte toutes les notes en CSV avec adresses"""
    query = """
        SELECT 
            n.street_name as rue,
            n.address_number as numero,
            n.team_id as equipe,
            n.comment as commentaire,
            n.created_at as date_creation
        FROM notes n
        ORDER BY n.street_name, CAST(n.address_number AS INTEGER), n.created_at DESC
    """
    df = pd.read_sql_query(query, conn)
    return df.to_csv(index=False).encode('utf-8')

# ========================================
# NOUVELLES FONCTIONS POUR LES ADRESSES
# ========================================

@auto_backup_before_critical
def import_addresses_from_cache(conn, cache):
    """
    Importe les adresses depuis le cache OSM vers la base de donn√©es
    """
    try:
        # Vider la table existante
        conn.execute("DELETE FROM addresses")
        
        imported_count = 0
        skipped_count = 0
        
        for street_name, addresses in cache.items():
            # V√©rifier que la rue existe dans la DB
            cursor = conn.execute("SELECT COUNT(*) FROM streets WHERE name = ?", (street_name,))
            if cursor.fetchone()[0] == 0:
                # Si la rue n'existe pas, la cr√©er
                conn.execute(
                    "INSERT OR IGNORE INTO streets(name, sector, team, status) VALUES (?, '', '', 'a_faire')",
                    (street_name,)
                )
                print(f"‚ûï Rue ajout√©e: {street_name}")
            
            for addr in addresses:
                try:
                    # Validation des donn√©es
                    number = str(addr.get("number", "")).strip()
                    lat = addr.get("lat")
                    lon = addr.get("lon")
                    osm_type = addr.get("type", "unknown")
                    
                    if not number or lat is None or lon is None:
                        skipped_count += 1
                        continue
                    
                    conn.execute(
                        """INSERT INTO addresses (street_name, house_number, latitude, longitude, osm_type) 
                           VALUES (?, ?, ?, ?, ?)""",
                        (street_name, number, float(lat), float(lon), osm_type)
                    )
                    imported_count += 1
                except Exception as e:
                    print(f"‚ö†Ô∏è Erreur import adresse {addr}: {e}")
                    skipped_count += 1
        
        conn.commit()
        log_activity(conn, None, "ADDRESSES_IMPORTED", f"{imported_count} adresses import√©es, {skipped_count} ignor√©es")
        print(f"‚úÖ {imported_count} adresses import√©es en base de donn√©es ({skipped_count} ignor√©es)")
        return imported_count
        
    except Exception as e:
        conn.rollback()
        print(f"‚ùå Erreur import adresses: {e}")
        return 0

def get_addresses_for_street(conn, street_name):
    """
    R√©cup√®re toutes les adresses d'une rue depuis la base de donn√©es
    """
    query = """
        SELECT 
            house_number,
            latitude,
            longitude,
            osm_type,
            created_at
        FROM addresses
        WHERE street_name = ?
        ORDER BY CAST(house_number AS INTEGER)
    """
    return pd.read_sql_query(query, conn, params=(street_name,))

def get_addresses_stats(conn):
    """
    R√©cup√®re les statistiques des adresses
    """
    cursor = conn.execute("""
        SELECT 
            COUNT(DISTINCT street_name) as streets_with_addresses,
            COUNT(*) as total_addresses,
            COUNT(DISTINCT CASE WHEN osm_type = 'node' THEN id END) as node_addresses,
            COUNT(DISTINCT CASE WHEN osm_type = 'way' THEN id END) as way_addresses
        FROM addresses
    """)
    row = cursor.fetchone()
    return {
        "streets_with_addresses": row[0] or 0,
        "total_addresses": row[1] or 0,
        "node_addresses": row[2] or 0,
        "way_addresses": row[3] or 0
    }

def get_backup_manager(db_path):
    """Retourne une instance du gestionnaire de backup"""
    return BackupManager(db_path)

# ================================================================================
# NOUVELLES FONCTIONS v4.1 - SUPERVISEUR ET B√âN√âVOLE
# ================================================================================

def get_unassigned_streets_count(conn):
    """Compte les rues non assign√©es √† une √©quipe"""
    try:
        cursor = conn.execute("""
            SELECT COUNT(*) FROM streets 
            WHERE team IS NULL OR team = ''
        """)
        return cursor.fetchone()[0] or 0
    except Exception as e:
        print(f"Erreur get_unassigned_streets_count: {e}")
        return 0

def get_sectors_list(conn):
    """R√©cup√®re la liste des secteurs disponibles"""
    try:
        cursor = conn.execute("""
            SELECT DISTINCT sector FROM streets 
            WHERE sector IS NOT NULL AND sector != ''
            ORDER BY sector
        """)
        return [row[0] for row in cursor.fetchall()]
    except Exception as e:
        print(f"Erreur get_sectors_list: {e}")
        return []

def get_teams_list(conn):
    """R√©cup√®re la liste des √©quipes actives"""
    try:
        cursor = conn.execute("""
            SELECT id, name FROM teams 
            WHERE active = 1 AND id != 'ADMIN'
            ORDER BY name
        """)
        return [(row[0], row[1]) for row in cursor.fetchall()]
    except Exception as e:
        print(f"Erreur get_teams_list: {e}")
        return []

@auto_backup_before_critical
def bulk_assign_sector(conn, sector, team_id):
    """Assigne toutes les rues d'un secteur √† une √©quipe"""
    try:
        # Valider les entr√©es
        valid_sector, clean_sector = validate_and_clean_input("sector", sector)
        valid_team, clean_team = validate_and_clean_input("team_id", team_id)
        
        if not valid_sector or not valid_team:
            raise ValueError("Secteur ou √©quipe invalide")
        
        # V√©rifier que l'√©quipe existe
        cursor = conn.execute("SELECT COUNT(*) FROM teams WHERE id = ?", (clean_team,))
        if cursor.fetchone()[0] == 0:
            raise ValueError(f"√âquipe {clean_team} inexistante")
        
        # Effectuer l'assignation
        cursor = conn.execute("""
            UPDATE streets 
            SET team = ? 
            WHERE sector = ? AND (team IS NULL OR team = '')
        """, (clean_team, clean_sector))
        
        affected_rows = cursor.rowcount
        conn.commit()
        
        # Log de l'activit√©
        log_activity(conn, clean_team, "bulk_assign", 
                    f"Assignation secteur {clean_sector}: {affected_rows} rues")
        
        return affected_rows
        
    except Exception as e:
        print(f"Erreur bulk_assign_sector: {e}")
        return 0

def get_team_streets(conn, team_id):
    """R√©cup√®re les rues assign√©es √† une √©quipe"""
    try:
        valid_team, clean_team = validate_and_clean_input("team_id", team_id)
        if not valid_team:
            return pd.DataFrame()
        
        query = """
            SELECT 
                s.name as street_name,
                s.sector,
                s.status,
                COUNT(n.id) as notes_count
            FROM streets s
            LEFT JOIN notes n ON s.name = n.street_name AND n.team_id = ?
            WHERE s.team = ?
            GROUP BY s.name, s.sector, s.status
            ORDER BY s.sector, s.name
        """
        return pd.read_sql_query(query, conn, params=(clean_team, clean_team))
        
    except Exception as e:
        print(f"Erreur get_team_streets: {e}")
        return pd.DataFrame()

@auto_backup_before_critical
def update_street_status(conn, street_name, new_status, team_id):
    """Met √† jour le statut d'une rue"""
    try:
        # Valider les entr√©es
        valid_street, clean_street = validate_and_clean_input("street_name", street_name)
        valid_status, clean_status = validate_and_clean_input("status", new_status)
        valid_team, clean_team = validate_and_clean_input("team_id", team_id)
        
        if not all([valid_street, valid_status, valid_team]):
            raise ValueError("Param√®tres invalides")
        
        # V√©rifier que la rue est assign√©e √† cette √©quipe
        cursor = conn.execute("""
            SELECT COUNT(*) FROM streets 
            WHERE name = ? AND team = ?
        """, (clean_street, clean_team))
        
        if cursor.fetchone()[0] == 0:
            raise ValueError(f"Rue {clean_street} non assign√©e √† l'√©quipe {clean_team}")
        
        # Mettre √† jour le statut
        conn.execute("""
            UPDATE streets 
            SET status = ? 
            WHERE name = ? AND team = ?
        """, (clean_status, clean_street, clean_team))
        
        conn.commit()
        
        # Log de l'activit√©
        log_activity(conn, clean_team, "status_update", 
                    f"Rue {clean_street}: {clean_status}")
        
        return True
        
    except Exception as e:
        print(f"Erreur update_street_status: {e}")
        return False

def get_assignations_export_data(conn):
    """R√©cup√®re les donn√©es d'assignation pour export CSV"""
    try:
        query = """
            SELECT 
                COALESCE(sector, 'Non d√©fini') as secteur,
                name as rue,
                COALESCE(team, 'Non assign√©e') as equipe,
                CASE status 
                    WHEN 'a_faire' THEN '√Ä faire'
                    WHEN 'en_cours' THEN 'En cours'
                    WHEN 'terminee' THEN 'Termin√©e'
                    ELSE status 
                END as statut
            FROM streets
            ORDER BY secteur, rue
        """
        return pd.read_sql_query(query, conn)
        
    except Exception as e:
        print(f"Erreur get_assignations_export_data: {e}")
        return pd.DataFrame()

def log_activity(conn, team_id, action, details):
    """Enregistre une activit√© dans le log"""
    try:
        valid_team, clean_team = validate_and_clean_input("team_id", team_id)
        valid_action, clean_action = validate_and_clean_input("text", action)
        valid_details, clean_details = validate_and_clean_input("note", details)
        
        if not all([valid_team, valid_action, valid_details]):
            print("Param√®tres de log invalides")
            return
        
        conn.execute("""
            INSERT INTO activity_log (team_id, action, details)
            VALUES (?, ?, ?)
        """, (clean_team, clean_action, clean_details))
        
        conn.commit()
        
        # Log aussi dans un fichier texte pour backup
        log_dir = Path(__file__).parent / "logs"
        log_dir.mkdir(exist_ok=True)
        
        log_file = log_dir / "activity.log"
        with open(log_file, "a", encoding="utf-8") as f:
            timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            f.write(f"{timestamp} | {clean_team} | {clean_action} | {clean_details}\n")
            
    except Exception as e:
        print(f"Erreur log_activity: {e}")

def get_street_notes_for_team(conn, street_name, team_id):
    """R√©cup√®re les notes d'une rue pour une √©quipe"""
    try:
        valid_street, clean_street = validate_and_clean_input("street_name", street_name)
        valid_team, clean_team = validate_and_clean_input("team_id", team_id)
        
        if not all([valid_street, valid_team]):
            return []
        
        cursor = conn.execute("""
            SELECT address_number, comment, created_at
            FROM notes
            WHERE street_name = ? AND team_id = ?
            ORDER BY created_at DESC
        """, (clean_street, clean_team))
        
        return cursor.fetchall()
        
    except Exception as e:
        print(f"Erreur get_street_notes_for_team: {e}")
        return []

@auto_backup_before_critical
def add_street_note(conn, street_name, team_id, address_number, comment):
    """Ajoute une note pour une adresse sp√©cifique"""
    try:
        # Valider les entr√©es
        valid_street, clean_street = validate_and_clean_input("street_name", street_name)
        valid_team, clean_team = validate_and_clean_input("team_id", team_id)
        valid_address, clean_address = validate_and_clean_input("address", address_number)
        valid_comment, clean_comment = validate_and_clean_input("note", comment)
        
        if not all([valid_street, valid_team, valid_address, valid_comment]):
            raise ValueError("Param√®tres invalides")
        
        # V√©rifier que la rue est assign√©e √† cette √©quipe
        cursor = conn.execute("""
            SELECT COUNT(*) FROM streets 
            WHERE name = ? AND team = ?
        """, (clean_street, clean_team))
        
        if cursor.fetchone()[0] == 0:
            raise ValueError(f"Rue {clean_street} non assign√©e √† l'√©quipe {clean_team}")
        
        # Ajouter la note
        conn.execute("""
            INSERT INTO notes (street_name, team_id, address_number, comment)
            VALUES (?, ?, ?, ?)
        """, (clean_street, clean_team, clean_address, clean_comment))
        
        conn.commit()
        
        # Log de l'activit√©
        log_activity(conn, clean_team, "note_added", 
                    f"Note ajout√©e - {clean_street} #{clean_address}")
        
        return True
        
    except Exception as e:
        print(f"Erreur add_street_note: {e}")
        return False

```n
================================================================================
## FICHIER 3: guignomap/validators.py (Validation des entr√©es)

```python

"""
Validateurs et sanitizers pour GuignoMap
Protection contre injections et validation des formats
"""

import re
import html
from typing import Optional, Tuple

class InputValidator:
    """Classe de validation et sanitization des entr√©es"""
    
    @staticmethod
    def sanitize_text(text: str, max_length: int = 255) -> str:
        """Nettoie et limite un texte"""
        if not text:
            return ""
        # Supprimer les caract√®res de contr√¥le
        text = "".join(char for char in text if ord(char) >= 32 or char == '\n')
        # √âchapper le HTML
        text = html.escape(text)
        # Limiter la longueur
        return text[:max_length].strip()
    
    @staticmethod
    def sanitize_street_name(name: str) -> str:
        """Valide et nettoie un nom de rue"""
        if not name:
            return ""
        # Garder seulement lettres, chiffres, espaces, tirets, apostrophes, accents
        name = re.sub(r'[^a-zA-Z√Ä-√ø0-9\s\-\'\.]', '', name)
        return name[:100].strip()
    
    @staticmethod
    def sanitize_team_id(team_id: str) -> str:
        """Valide un ID d'√©quipe"""
        if not team_id:
            return ""
        # Format: LETTRES + CHIFFRES seulement, max 20 caract√®res
        team_id = re.sub(r'[^A-Z0-9]', '', team_id.upper())
        return team_id[:20]
    
    @staticmethod
    def sanitize_address_number(number: str) -> str:
        """Valide un num√©ro civique"""
        if not number:
            return ""
        # Garder chiffres et lettres (ex: 123A)
        number = re.sub(r'[^0-9A-Za-z\-]', '', number)
        return number[:10]
    
    @staticmethod
    def validate_password(password: str) -> Tuple[bool, str]:
        """Valide la force d'un mot de passe - minimum 4 caract√®res"""
        if password is None:
            return False, "Mot de passe requis"
        if len(password) < 4:
            return False, "Minimum 4 caract√®res"
        if len(password) > 128:
            return False, "Maximum 128 caract√®res"
        return True, "OK"
    
    @staticmethod
    def validate_sector(sector: str) -> str:
        """Valide un secteur"""
        valid_sectors = ['Principal', 'Centre', 'Nord', 'Sud', 'Est', 'Ouest', 'R√©sidentiel', '']
        if sector not in valid_sectors:
            return ''
        return sector
    
    @staticmethod
    def validate_status(status: str) -> str:
        """Valide un statut de rue"""
        valid_statuses = ['a_faire', 'en_cours', 'terminee']
        if status not in valid_statuses:
            return 'a_faire'
        return status
    
    @staticmethod
    def sanitize_note(note: str) -> str:
        """Nettoie une note/commentaire"""
        if not note:
            return ""
        # Supprimer caract√®res dangereux mais garder ponctuation basique
        note = re.sub(r'[<>\"\'`;]', '', note)
        return note[:500].strip()
    
    @staticmethod
    def is_sql_safe(text: str) -> bool:
        """V√©rifie qu'un texte ne contient pas de patterns SQL dangereux"""
        if not text:
            return True
        dangerous_patterns = [
            r'\bDROP\b', r'\bDELETE\b', r'\bINSERT\b', r'\bUPDATE\b',
            r'\bEXEC\b', r'\bEXECUTE\b', r'--', r'/\*', r'\*/', r';'
        ]
        text_upper = text.upper()
        for pattern in dangerous_patterns:
            if re.search(pattern, text_upper):
                return False
        return True

def validate_and_clean_input(input_type: str, value: str) -> Tuple[bool, str]:
    """Fonction principale de validation"""
    validator = InputValidator()
    
    if input_type == "team_id":
        clean = validator.sanitize_team_id(value)
        return bool(clean), clean
    
    elif input_type == "street_name":
        clean = validator.sanitize_street_name(value)
        if not validator.is_sql_safe(clean):
            return False, ""
        return bool(clean), clean
    
    elif input_type == "address":
        clean = validator.sanitize_address_number(value)
        return bool(clean), clean
    
    elif input_type == "note":
        clean = validator.sanitize_note(value)
        if not validator.is_sql_safe(clean):
            return False, ""
        return bool(clean), clean
    
    elif input_type == "sector":
        clean = validator.validate_sector(value)
        return True, clean
    
    elif input_type == "status":
        clean = validator.validate_status(value)
        return True, clean
    
    elif input_type == "password":
        valid, msg = validator.validate_password(value)
        return valid, value if valid else ""
    
    else:
        clean = validator.sanitize_text(value)
        return bool(clean), clean

```n
================================================================================
## FICHIER 4: requirements.txt (D√©pendances Python)

```text

streamlit>=1.36.0
pandas>=2.2.0
folium==0.20.0
streamlit-folium>=0.21.0
overpy==0.7
bcrypt>=4.0.0
plotly>=5.18.0
xlsxwriter==3.2.8
reportlab==4.4.3

```n
================================================================================
## FICHIER 5: README.md (Documentation projet)

```markdown

# GuignoMap - Syst√®me de gestion pour la Guignol√©e 2025 üéÑ

Une application web moderne con√ßue sp√©cialement pour optimiser la collecte de dons lors de la Guignol√©e 2025 √† Mascouche.

## ‚ú® Nouvelles fonctionnalit√©s v4.1

### üëî Interface Superviseur/Gestionnaire
- **Assignations par secteur** : S√©lection secteur + √©quipe et assignation en bloc
- **Compteur rues non assign√©es** : Vue en temps r√©el des rues sans √©quipe
- **Export CSV assignations** : Colonnes secteur, rue, √©quipe, statut
- **Gestion d'erreur gracieuse** : Masquage des fonctionnalit√©s indisponibles
- **Notifications toast** : Confirmations visuelles des actions

### üéÖ Interface B√©n√©vole "Mes rues"
- **Vue filtr√©e par √©quipe** : Seulement les rues assign√©es √† l'√©quipe connect√©e
- **Boutons de statut** : "En cours" et "Termin√©e" avec mise √† jour imm√©diate
- **Gestion des notes** : Ajout/affichage des notes par adresse sp√©cifique
- **Statistiques d'√©quipe** : M√©triques de progression en temps r√©el
- **Journal d'activit√©** : Historique des actions de l'√©quipe

### üõ°Ô∏è S√©curit√© et robustesse v4.1
- **Validation stricte** : R√©utilisation des validators pour toutes les entr√©es
- **Backup automatique** : D√©corateur auto_backup_before_critical sur toutes les √©critures
- **Logging complet** : Journal d'activit√© en base de donn√©es ET fichier texte
- **Gestion d'erreur** : D√©gradation gracieuse sans plantage de l'application

### üìä Exports professionnels
- **Maintien des exports PDF/Excel** : Aucune modification des fonctionnalit√©s existantes
- **Nouveau CSV assignations** : Export sp√©cialis√© pour la gestion des secteurs
- **Interface unifi√©e** : Tous les exports accessibles depuis l'onglet Export

## ‚ú® Fonctionnalit√©s v4.0 (acquises)

### üîí S√©curit√© renforc√©e
- **Migration bcrypt** : Remplacement SHA256 par bcrypt avec salage automatique
- **Migration automatique** des anciens mots de passe
- **Validation d'entr√©es** : Protection contre injection SQL et XSS
- **Sanitisation compl√®te** de toutes les donn√©es utilisateur

### üíæ Syst√®me de backup automatique
- **Backup automatique** avant toutes op√©rations critiques
- **Format ZIP** avec horodatage
- **Rotation automatique** : conservation 7 jours
- **Interface de gestion** des backups avec t√©l√©chargement

## ‚ú® Fonctionnalit√©s v3.0 (acquises)

### üéÑ Interface festive
- **Page d'accueil moderne** avec compte √† rebours vers No√´l
- **En-t√™te festif** aux couleurs de la Guignol√©e 2025
- **Carte de No√´l th√©matique** avec ic√¥nes festives

### üì± Optimisations mobiles
- **Interface responsive** optimis√©e pour tous les appareils
- **Navigation tactile** adapt√©e aux smartphones
- **Contr√¥les de carte** optimis√©s pour mobile

### üèÜ Syst√®me de motivation
- **Badges d'√©quipe** : D√©butants, Actifs, Champions, L√©gendes
- **Notifications temps r√©el** pour les accomplissements
- **Tableaux de bord interactifs** avec graphiques Plotly

### üìä Centre d'export avanc√©
- **Export Excel professionnel** avec formatage automatique
- **G√©n√©ration de listes SMS** pour la communication d'√©quipe
- **Export PDF** (pr√©paration)
- **Rapports d√©taill√©s** par √©quipe et secteur

### üó∫Ô∏è Am√©liorations cartographiques
- **Choix de fonds de carte** : OpenStreetMap France, CARTO Voyager, Esri
- **Zoom optimis√©** centr√© sur Mascouche
- **Zone d'affichage agrandie** : 90% de l'√©cran sur PC
- **Gestion d'erreur robuste** : secrets.toml optionnel
- **Visibilit√© am√©lior√©e** des rues avec lignes plus √©paisses
- **R√©cup√©ration compl√®te** de toutes les rues via OSM

### üó∫Ô∏è L√©gende de la carte (persistante)
- **4 √©tats visuels** :
  - üü¢ **Vert** : Rues termin√©es (collecte finie)
  - üü° **Jaune** : Rues en cours (√©quipe active)
  - üî¥ **Rouge plein** : Rues assign√©es √† faire (√©quipe d√©sign√©e)
  - üî¥ **Rouge pointill√©** : Rues non assign√©es (aucune √©quipe)
- **Position fixe** : Bas-droite de la carte
- **Persistance garantie** : Reste visible au zoom/d√©zoom/d√©placement
- **Style moderne** : Fond blanc, bordure, ombre port√©e

### ‚öôÔ∏è Compatibilit√© et modernisation
- **Python 3.13.6** et versions r√©centes de Streamlit
- **Suppression de use_container_width** (d√©pr√©ci√©) ‚ûú `width="stretch"`
- **Migration pandas Styler** : `applymap()` ‚ûú `map()` avec helper de compatibilit√©
- **L√©gende persistante** via Folium Elements (remplace l'ancien HTML/CSS)
- **Chemins multi-plateformes** avec pathlib
- **Gestion des erreurs robuste** : l'application ne crash jamais
- **Code moderne** : Nettoyage des anciens hacks et workarounds

### üé® Affichage des statuts
- **Codes internes** : `a_faire`, `en_cours`, `terminee` (base de donn√©es)
- **Affichage UI/exports** : "√Ä faire", "En cours", "Termin√©e" (interface utilisateur)
- **Style visual** : Fond pastel + texte contrast√©, uniquement sur la colonne "Statut"
- **Couleurs harmonis√©es** : 
  - üü¢ **Termin√©e** : Fond vert p√¢le (#E6F5EA)
  - üü° **En cours** : Fond jaune p√¢le (#FFF3CC)  
  - üî¥ **√Ä faire** : Fond rose p√¢le (#FFE6EC)

### üîß Interface assignations
- **S√©lecteur secteur** : Label clair "SECTEUR √Ä ASSIGNER", aucun chevauchement
- **Tableau √©tat** : Colonnes Rue / Secteur / √âquipe / Statut avec libell√©s fran√ßais
- **Style uniforme** : Rendu standard avec th√®me sombre (fond neutre, texte blanc)
- **Corrections UI** :
  - Fix superposition texte au-dessus du s√©lecteur 'SECTEUR √Ä ASSIGNER' (suppression des sorties de debug/injections HTML), tableau des assignations sans stylisation sp√©ciale (rendu uniforme)
  - Layout propre avec container/colonnes, sans overlay ni stylisation
  - √âquipes : suppression du doublon de titre causant une superposition dans l'expander
  - Mot de passe √©quipes : minimum 4 caract√®res, aucune autre contrainte

### üë• Gestion moderne
- **Terminologie unifi√©e** : "gestionnaire" au lieu de "superviseur"
- **Navigation sidebar** moderne et intuitive
- **Interface b√©n√©vole restreinte** aux rues assign√©es seulement
- **Authentification simplifi√©e** avec cartes de connexion
- **Gestion des √©quipes am√©lior√©e** :
  - Ajout d'un champ Confirmer le mot de passe (cr√©ation d'√©quipe)
  - Politique : minimum 4 caract√®res, aucune autre contrainte
  - Option : case Afficher les mots de passe

## üöÄ Installation et utilisation

### Pr√©requis
- Python 3.8+
- Acc√®s internet pour OSM et les tuiles de carte

### Installation
```bash
git clone https://github.com/votre-repo/GuignoMap.git
cd GuignoMap
pip install -r requirements.txt
```

### Lancement (Windows)
```powershell
# Activer l'environnement virtuel
.\.venv\Scripts\Activate.ps1

# Lancer l'application
cd .\guignomap
streamlit run app.py
```

### Exports PDF/Excel
- **Boutons de t√©l√©chargement** : Disponibles dans l'onglet "üì• Export"
- **Emplacement recommand√©** : `.\guignomap\exports` pour sauvegarde locale
- **Formats disponibles** : Excel (.xlsx), PDF (.pdf), CSV assignations

### Ouvrir le dernier export (PowerShell)
```powershell
$d = Join-Path $PSScriptRoot 'guignomap'
Set-Location $d
if (-not (Test-Path "..\exports")) { New-Item -ItemType Directory "..\exports" | Out-Null }
$f = Get-ChildItem "..\exports" -File -ErrorAction SilentlyContinue | Sort-Object LastWriteTime | Select-Object -Last 1
if ($f) { ii $f.FullName } else { ii "..\exports" }
```

## üì¶ D√©pendances principales

- **streamlit** : Interface web moderne
- **folium** : Cartes interactives
- **pandas** : Manipulation des donn√©es
- **overpy** : API OpenStreetMap
- **plotly** : Graphiques interactifs
- **xlsxwriter** : Export Excel professionnel
- **reportlab** : G√©n√©ration PDF professionnelle
- **bcrypt** : Hachage s√©curis√© des mots de passe

### S√©curit√©/Robustesse
- **bcrypt** : Migration automatique des anciens hash SHA256 vers bcrypt avec salage
- **Backup automatique** : ZIP cr√©√© avant toute √©criture critique
- **Validation inputs** : Protection SQL injection et XSS via module validators
- **Logging complet** : Journal d'activit√© en base de donn√©es et fichier

## üîß Notes techniques

### Compatibilit√© pandas 2.4+
L'application utilise un helper `style_map_compat()` pour g√©rer la transition de `Styler.applymap()` vers `Styler.map()` :
```python
def style_map_compat(df: pd.DataFrame, fn: Callable[[Any], str], subset: Any = None):
    """Helper de compatibilit√© pandas - applymap() vs map()"""
    styler = df.style
    if hasattr(styler, "map"):
        return styler.map(fn, subset=subset)  # Pandas 2.4+
    return getattr(styler, "applymap")(fn, subset=subset)  # Pandas < 2.4
```

### Environment virtuel (.venv)
- **D√©veloppement** : Utiliser exclusivement `.\.venv\Scripts\python.exe`
- **Isolation** : Toutes les d√©pendances dans `.venv/` pour √©viter les conflits
- **Activation** : `.\.venv\Scripts\Activate.ps1` avant utilisation

## üéØ Guide d'utilisation v4.1

### üëî Pour les Superviseurs/Gestionnaires

#### Assignation par secteur (nouveau v4.1)
1. **Connexion gestionnaire** : Utilisez vos identifiants superviseur
2. **Onglet "üó∫Ô∏è Assignation"** : Acc√©dez au nouveau panneau d'assignation
3. **S√©lection secteur et √©quipe** : Choisissez le secteur √† assigner et l'√©quipe destinataire
4. **Assignation en bloc** : Cliquez "üéØ Assigner tout le secteur"
5. **V√©rification** : Le tableau des assignations s'actualise automatiquement

#### Export CSV assignations (nouveau v4.1)
1. **Onglet "üì• Export"** : Acc√©dez aux exports sp√©cialis√©s v4.1
2. **Export CSV Assignations** : T√©l√©chargez le fichier avec colonnes secteur, rue, √©quipe, statut
3. **Utilisation** : Parfait pour suivi externe ou import dans d'autres outils

### üéÖ Pour les B√©n√©voles

#### Interface "Mes rues" (nouveau v4.1)
1. **Connexion b√©n√©vole** : Connectez-vous avec votre nom d'√©quipe
2. **Onglet "üèòÔ∏è Mes rues"** : Vue filtr√©e de vos rues assign√©es uniquement
3. **Mise √† jour statuts** : Cliquez "üöÄ En cours" ou "‚úÖ Termin√©e" pour chaque rue
4. **Ajout de notes** : Remplissez num√©ro civique + commentaire et cliquez "üíæ Enregistrer note"
5. **Suivi progression** : Consultez vos m√©triques en temps r√©el

#### Gestion des notes par adresse (nouveau v4.1)
1. **S√©lection rue** : D√©veloppez l'accord√©on de la rue souhait√©e
2. **Notes existantes** : Consultez les notes d√©j√† saisies
3. **Nouvelle note** : Entrez le num√©ro civique (ex: 123A) et votre commentaire
4. **Types de notes** : Absent, refus, don re√ßu, situation particuli√®re...
5. **Validation** : La note est automatiquement horodat√©e et associ√©e √† votre √©quipe

## üéØ Fonctionnalit√©s principales

### Pour les b√©n√©voles
- üó∫Ô∏è **Carte interactive** avec leurs rues assign√©es uniquement
- ‚úÖ **Syst√®me de validation** rue par rue avec notes
- üèÜ **Badges de progression** et encouragements
-   **Interface mobile** optimis√©e

### Pour les gestionnaires
- üìä **Tableau de bord complet** avec KPIs temps r√©el
-  Ô∏è **Vue d'ensemble** de toutes les √©quipes
- üìà **Graphiques de progression** par Plotly
-   **Centre d'export** avec formats multiples
- üë• **Gestion des √©quipes** et assignation
  - Cr√©ation encapsul√©e dans un formulaire (Enter ou bouton)
  - Correction d'un chevauchement de texte au-dessus du formulaire
-   **Notifications** d'activit√©

### Donn√©es et exports
- üìù **Base de donn√©es SQLite** int√©gr√©e
- üìä **Export Excel** avec formatage professionnel
- üì± **Listes SMS** pour communication
- üìÑ **Rapports PDF** avec mise en page professionnelle
source .venv/bin/activate

## üóÉÔ∏è Structure du projet

```
GuignoMap/
‚îú‚îÄ‚îÄ guignomap/
‚îÇ   ‚îú‚îÄ‚îÄ app.py              # Application principale Streamlit
‚îÇ   ‚îú‚îÄ‚îÄ db.py               # Gestion base de donn√©es
‚îÇ   ‚îú‚îÄ‚îÄ osm.py              # Interface OpenStreetMap
‚îÇ   ‚îú‚îÄ‚îÄ guigno_map.db       # Base de donn√©es SQLite
‚îÇ   ‚îú‚îÄ‚îÄ osm_cache.json      # Cache des donn√©es OSM
‚îÇ   ‚îú‚îÄ‚îÄ streets_mascouche.csv # Donn√©es des rues
‚îÇ   ‚îî‚îÄ‚îÄ assets/
‚îÇ       ‚îú‚îÄ‚îÄ banner.png      # Banni√®re Guignol√©e
‚îÇ       ‚îú‚îÄ‚îÄ logo.png        # Logo officiel
‚îÇ       ‚îî‚îÄ‚îÄ styles.css      # Styles personnalis√©s
‚îú‚îÄ‚îÄ requirements.txt        # D√©pendances Python
‚îî‚îÄ‚îÄ README.md              # Documentation
```

## üéÑ Th√®me Guignol√©e 2025

L'application adopte une identit√© visuelle festive pour l'√©dition 2025 :
- **Couleurs** : Rouge festif (#dc3545), vert sapin, or
- **Typographie** : Poppins pour une lecture moderne
- **Ic√¥nes** : Th√®me de No√´l et solidarit√©
- **Animations** : Compte √† rebours dynamique vers No√´l

##   Statistiques temps r√©el

Le syst√®me suit automatiquement :
- Progression globale de la collecte
- Performance par √©quipe et b√©n√©vole
- Couverture g√©ographique
- Tendances et objectifs

## üîê S√©curit√© et acc√®s

- **Authentification** par nom d'√©quipe
- **Restriction d'acc√®s** : b√©n√©voles limit√©s √† leurs rues
- **Donn√©es locales** : pas de transmission externe
- **Sauvegarde automatique** des progressions

## ü§ù Contribution

GuignoMap est d√©velopp√© pour la Guignol√©e de Mascouche. Pour toute suggestion ou am√©lioration, contactez l'√©quipe organisatrice.

---

**Joyeuses F√™tes et bonne Guignol√©e 2025 ! üéÑüéÅ**
2. **Consultez votre liste** de rues assign√©es
3. **Commencez une rue** :
   - S√©lectionnez la rue dans la liste
   - Changez le statut de "√Ä faire" √† "En cours"
4. **Pendant la collecte** :
   - Ajoutez des notes pour les adresses sp√©ciales
   - Ex: "145 - Famille absente, denr√©es d√©pos√©es"
5. **Terminez la rue** :
   - Une fois la rue compl√®te, changez le statut √† "Termin√©e"
6. **Passez √† la rue suivante**

### üÜò Que faire si...

#### ‚ùì **Je ne vois pas mes rues**
- V√©rifiez que vous √™tes connect√© comme b√©n√©vole
- Demandez au superviseur si des rues vous ont √©t√© assign√©es

#### ‚ùì **Je ne peux pas me connecter**
- V√©rifiez votre code d'√©quipe et mot de passe
- Contactez le superviseur pour confirmation

#### ‚ùì **La carte ne s'affiche pas**
- Actualisez la page (F5)
- Le superviseur peut reconstruire les donn√©es dans l'onglet Tech

#### ‚ùì **Je veux voir toute la ville**
- Seuls les superviseurs voient toute la carte
- Les b√©n√©voles ne voient que leurs rues assign√©es

### üí° Conseils pratiques

#### Pour les **superviseurs** :
- Cr√©ez les √©quipes AVANT d'assigner des rues
- Assignez des secteurs logiques (ex: m√™me quartier)
- Consultez r√©guli√®rement l'onglet "Vue d'ensemble" pour le suivi
- Exportez les donn√©es √† la fin pour les rapports

#### Pour les **b√©n√©voles** :
- Changez le statut d√®s que vous commencez une rue
- Ajoutez des notes pour les situations particuli√®res
- N'oubliez pas de marquer "Termin√©e" quand c'est fini
- Utilisez l'auto-refresh pour voir les mises √† jour des autres √©quipes

### üé® Interface rapide
- **Menu gauche** : Navigation principale
- **Carte centrale** : Vue g√©ographique avec couleurs
- **L√©gende en bas √† droite** : Explication des couleurs et statistiques
- **Auto-refresh** : Active le rafra√Æchissement automatique toutes les 15 secondes

## üîê Connexion

### Superviseur
- **Portail** : üéØ Superviseur
- **Mot de passe** : `admin123`
- **Fonctions** : Gestion compl√®te + op√©rations techniques

### B√©n√©voles
- **Portail** : üë• B√©n√©vole
- **Identifiants** : Cr√©√©s par le superviseur

## üìÅ Structure du projet

```
GuignoMap/
‚îú‚îÄ‚îÄ guignomap/
‚îÇ   ‚îú‚îÄ‚îÄ app.py              # Application principale
‚îÇ   ‚îú‚îÄ‚îÄ db.py               # Gestion base de donn√©es robuste
‚îÇ   ‚îú‚îÄ‚îÄ osm.py              # Int√©gration OpenStreetMap + adresses
‚îÇ   ‚îú‚îÄ‚îÄ guigno_map.db       # Base SQLite
‚îÇ   ‚îú‚îÄ‚îÄ osm_cache.json      # Cache g√©om√©tries
‚îÇ   ‚îú‚îÄ‚îÄ osm_addresses.json  # Cache adresses OSM
‚îÇ   ‚îî‚îÄ‚îÄ assets/
‚îÇ       ‚îú‚îÄ‚îÄ styles.css      # Styles personnalis√©s
‚îÇ       ‚îú‚îÄ‚îÄ logo.png        # Logo du Relais
‚îÇ       ‚îî‚îÄ‚îÄ banner.png      # Banni√®re (optionnel)
‚îú‚îÄ‚îÄ .streamlit/
‚îÇ   ‚îî‚îÄ‚îÄ config.toml         # Configuration Streamlit
‚îú‚îÄ‚îÄ requirements.txt        # D√©pendances Python
‚îî‚îÄ‚îÄ README.md              # Documentation
```

## üõ†Ô∏è Technologies

- **Frontend** : Streamlit + CSS personnalis√©
- **Backend** : Python + SQLite avec gestion d'erreurs
- **Cartes** : Folium + OpenStreetMap + API Overpass
- **Donn√©es** : Pandas + Overpy avec validation robuste

## üìä Fonctionnalit√©s d√©taill√©es

### Pour les Superviseurs
- Vue d'ensemble avec carte compl√®te de Mascouche
- Gestion des √©quipes avec cr√©ation/suppression
- Assignation intelligente des rues
- Export des rapports (rues + notes)
- **Onglet Tech** prot√©g√© par PIN pour :
  - Reconstruction du cache g√©om√©trique OSM
  - Import/mise √† jour des adresses depuis OSM
  - Gestion d'erreurs avanc√©e avec fallback
- Visualisation compl√®te : autoroutes, rues principales, voies priv√©es
- Statistiques en temps r√©el avec compteurs dynamiques

### Pour les B√©n√©voles
- Interface d√©di√©e √† leur tourn√©e assign√©e
- Ajout de notes par adresse civique
- Mise √† jour du statut des rues (√† faire ‚Üí en cours ‚Üí termin√©e)
- Consultation des notes existantes
- Carte centr√©e sur leur zone de travail
- Ajout de notes par adresse
- Mise √† jour du statut des rues
- Suivi en temps r√©el
- Carte centr√©e automatiquement sur la zone de travail
- Interface fluide avec rechargement intelligent des donn√©es
- **Visibilit√© totale** des voies de collecte (y compris voies priv√©es)

## üé® Th√®me visuel

Interface moderne aux couleurs du **Relais de Mascouche** :
- Rouge bordeaux (#8B0000)
- Or (#FFD700)
- Design responsive
- Animations fluides

### L√©gende de la carte am√©lior√©e
- üü¢ **Vert** : Rues termin√©es
-   **Orange** : Rues en cours
- üî¥ **Rouge** : Rues √† faire
- **Lignes pleines** : Rues assign√©es √† une √©quipe
- **Lignes pointill√©es** : Rues non assign√©es
- **Compteurs dynamiques** : Total, assign√©es, non assign√©es
- **Marqueur centre-ville** : Point de r√©f√©rence Mascouche

## üöß D√©veloppement

### Base de donn√©es renforc√©e
- Tables : `streets`, `teams`, `notes`, `activity_log`, `addresses`
- Import automatique depuis OpenStreetMap avec validation
- Gestion d'erreurs et cr√©ation automatique des rues manquantes
- Donn√©es de test int√©gr√©es et fallback robuste

### Syst√®me OSM r√©volutionnaire v3.1
- **Couverture maximale** : TOUTES les voies nomm√©es + autoroutes (ref)
- **Requ√™te optimis√©e** : `highway+name OU highway+ref`
- **Cache multi-niveaux** : g√©om√©tries + adresses OSM
- **Fallback √©tendu** : 19 voies principales de Mascouche
- **Gestion d'erreurs** : validation, retry, r√©cup√©ration automatique
- **Import adresses** : num√©ros civiques avec tri intelligent
- **Performance** : cache Streamlit sensible aux modifications

### Couverture des voies compl√®te
- üõ£Ô∏è **Autoroutes** : A-25, A-640 (via ref)
- üèòÔ∏è **Voies principales** : Mont√©e Masson, Chemin Sainte-Marie
- üöó **Voies r√©sidentielles** : toutes les rues nomm√©es
- üè† **Voies d'acc√®s** : service, private roads
- üîö **Impasses et all√©es** : couverture totale
- ‚úÖ **Inclusions** : TOUT sauf limitation technique OSM

### Am√©liorations critiques v3.1
- **üêõ Fix create_map()** : Gestion robuste des colonnes DataFrame
- **üîß Fix build_addresses_cache()** : Validation types et tri intelligent  
- **üõ°Ô∏è Fix import_addresses_from_cache()** : Cr√©ation automatique des rues
- **‚ö° Fix list_streets()** : COALESCE pour √©viter les NULL
- **üéØ UI am√©lior√©e** : Limites g√©ographiques et zoom adaptatif
- **üìä Statistiques** : Compteurs en temps r√©el dans la l√©gende

### Architecture technique
- **Frontend** : Streamlit avec gestion d'erreur globale
- **G√©olocalisation** : API Overpass OSM avec requ√™te universelle
- **Donn√©es** : SQLite + cache JSON double (g√©o + adresses)
- **Couverture** : Syst√®me d'inclusion universelle (name + ref)
- **Robustesse** : Fallback √† tous les niveaux avec validation

## üìù Changelog v3.3

### üéÑ Th√®me Guignol√©e festif
- **Header moderne** : Design sp√©cial Guignol√©e 2025 avec d√©grad√© rouge/vert
- **Animations** : Flocons de neige CSS pour ambiance festive
- **Branding** : "üéÖ GUIGNOL√âE 2025 üéÅ" avec police Manrope
- **Stats temps r√©el** : Progression visible directement dans le header
- **Support logo** : D√©tection automatique du logo Guignol√©e

### üñºÔ∏è Sidebar avec logo int√©gr√©
- **Logo professionnel** : Espace d√©di√© 200px en haut de sidebar
- **Positionnement optimal** : Coll√© au bord sup√©rieur sans espace vide
- **Fallback √©l√©gant** : Placeholder festif avec d√©grad√© Guignol√©e si logo absent
- **Navigation moderne** : Boutons stylis√©s Accueil/B√©n√©vole/Gestionnaire
- **Branding complet** : Coh√©rence visuelle avec header festif

### üé® Effets de connexion festifs
- **Connexion b√©n√©vole** : Effet neige (`st.snow()`) pour ambiance hivernale
- **Connexion gestionnaire** : Effet neige unifi√© pour coh√©rence th√©matique
- **Messages personnalis√©s** : Accueil par √©quipe avec design festif

## üìù Changelog v3.2

### üó∫Ô∏è Am√©liorations cartographiques majeures
- **Fonds multiples** : OSM France (d√©taill√©), CARTO Voyager (moderne), Esri WorldStreetMap (professionnel)
- **S√©lecteur de couches** : Contr√¥le dynamique pour changer de fond √† la vol√©e
- **Zoom optimis√©** : zoom_start=13 pour meilleur cadrage de Mascouche
- **Performances** : prefer_canvas=True pour rendu fluide + contr√¥les complets
- **Visibilit√©** : weight 7/5 et opacity 0.9/0.7 pour meilleure lisibilit√©
- **Navigation** : zoom_control et scrollWheelZoom activ√©s

### üéØ Interface utilisateur
- **Terminologie** : "Code" ‚Üí "Identifiant", "Nom" ‚Üí "√âquipe" pour clart√©
- **UX** : Am√©lioration compr√©hension des champs par les utilisateurs

## üìù Changelog v3.1

### üîß Corrections critiques
- **create_map()** : Gestion robuste colonnes pandas + limites g√©ographiques
- **build_addresses_cache()** : Tri num√©rique intelligent + gestion d'erreurs
- **import_addresses_from_cache()** : Validation + cr√©ation automatique rues
- **list_streets()** : COALESCE pour colonnes NULL + structure garantie
- **Requ√™te OSM** : Inclusion autoroutes via ref + couverture maximale

### ‚ú® Nouvelles fonctionnalit√©s  
- **Carte centr√©e Mascouche** : Bounds g√©ographiques + zoom adaptatif
- **L√©gende avanc√©e** : Statistiques temps r√©el + compteurs dynamiques
- **Marqueur centre-ville** : Point de r√©f√©rence visuel
- **Fallback √©tendu** : 19 voies principales + autoroutes
- **Gestion d'erreurs** : Messages informatifs + r√©cup√©ration automatique

## üîß D√©pannage

### Probl√®mes de l√©gende
- **L√©gende invisible** : Appuyez sur F5 pour recharger compl√®tement la page
- **L√©gende qui clignote** : Normal lors du changement de fond de carte
- **Position incorrecte** : La l√©gende se repositionne automatiquement

### Probl√®mes de compatibilit√© Streamlit
- **Erreur use_container_width** : Version r√©cente de Streamlit - l'application s'adapte automatiquement
- **Affichage d√©grad√©** : Mise √† jour recommand√©e vers Streamlit 1.28+
- **Contr√¥les manquants** : V√©rifiez la version folium et streamlit-folium

### Probl√®mes de compatibilit√© pandas
- **Erreur "Cannot access attribute 'applymap'"** : Pandas 2.4+ retire applymap - l'application utilise un helper de compatibilit√©
- **Tables sans style** : V√©rifiez la version pandas, le helper `style_map_compat()` g√®re automatiquement les versions
- **Couleurs manquantes** : Probl√®me temporaire lors du changement de version pandas - red√©marrez l'application

### Performance
- **Carte lente** : R√©duisez le zoom ou changez de fond de carte
- **M√©moire √©lev√©e** : Rechargez l'application avec F5
- **Erreurs OSM** : V√©rifiez la connexion internet

### Donn√©es
- **Rues manquantes** : Utilisez "Recharger depuis OSM" dans l'onglet Admin
- **Backup corrupt** : Les backups sont v√©rifi√©s √† la cr√©ation
- **Donn√©es perdues** : Consultez le dossier backups/ pour r√©cup√©ration

## üìù Support

D√©velopp√© pour **Le Relais de Mascouche** - Collecte de denr√©es 2025

---
*Version 3.4 - Interface sidebar compl√®te avec logo int√©gr√© et effets festifs*


```n
================================================================================
## FIN DE L'EXPORT - R√âCAPITULATIF FINAL

Tous les fichiers source principaux de GuignoMap ont √©t√© export√©s :
- guignomap/app.py : Interface utilisateur et logique principale
- guignomap/db.py : Gestion de la base de donn√©es et des √©quipes
- guignomap/validators.py : Validation des entr√©es utilisateur
- requirements.txt : D√©pendances Python
- README.md : Documentation compl√®te du projet

Cet export refl√®te l'√©tat du code apr√®s toutes les am√©liorations r√©centes :
 Suppression de la superposition de texte dans l'onglet √âquipes
 Ajout de la confirmation du mot de passe
 Politique de mot de passe assouplie (min 4 caract√®res)
 Case √† cocher pour afficher/masquer les mots de passe
 Documentation mise √† jour
 Encodage UTF-8 correct (caract√®res fran√ßais pr√©serv√©s)

Date d'export : 15 septembre 2025 - Code pr√™t pour production

================================================================================
