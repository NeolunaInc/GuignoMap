===============================================================================
EXPORT GUIGNOMAP - AUDIT CONDENSÉ
Date: 2025-09-18 13:40:12
===============================================================================

STRUCTURE PYTHON (.py files only):
check_admin.py
guignomap\__init__.py
guignomap\app.py
guignomap\auth.py
guignomap\backup.py
guignomap\config_ville.py
guignomap\database.py
guignomap\db.py
guignomap\osm.py
guignomap\reports.py
guignomap\utils.py
guignomap\validators.py
legacy\config.py
legacy\scripts\fix_mojibake_db.py
legacy\scripts\generate_audit_optimise.py
legacy\scripts\migrate_password_hashes.py
legacy\scripts\reset_teams.py
legacy\scripts\sanity_db_pandas.py
legacy\storage\__init__.py
legacy\storage\cloud.py
legacy\storage\local.py
scripts\debug_excel.py
scripts\enrich_addresses_from_osm.py
scripts\export_repo_audit.py
scripts\export_repo_min.py
scripts\export_repo_snapshot.py
scripts\find_mojibake.py
scripts\fix_app_types.py
scripts\fix_mojibake_files.py
scripts\fix_specific.py
scripts\generate_tree_clean.py
scripts\import_from_excel.py
scripts\normalize_encoding.py
scripts\run_all_tests.py
scripts\sample_addresses.py
scripts\seed_address_demo.py
scripts\setup_nouvelle_ville.py
scripts\show_hash_stats.py
scripts\smoke_create_map.py
scripts\test_helpers.py
scripts\validate_production_ready.py
scripts\validate_structure.py
scripts\verify_addresses_exact.py
scripts\verify_import.py
scripts\verify_real_encoding.py
streamlit_app.py
tests\auth\test_passwords_smoke.py
tests\manual\test_db_simple.py
tests\test_critical_paths.py
tests\test_sqlite_performance.py
tools\quick_sanity.py

===============================================================================
FICHIERS CRITIQUES (extraits - 50 premières lignes max)
===============================================================================

--- FILE: streamlit_app.py ---
# coding: utf-8
import os, sys
os.environ.setdefault("PYTHONUTF8", "1")
try:
    sys.stdout.reconfigure(encoding="utf-8")
except Exception:
    pass

import pathlib, importlib, traceback
import streamlit as st

ROOT = pathlib.Path(__file__).resolve().parent
if str(ROOT) not in sys.path:
    sys.path.insert(0, str(ROOT))

try:
    app = importlib.import_module("guignomap.app")
    for fn_name in ("main", "run", "render"):
        fn = getattr(app, fn_name, None)
        if callable(fn):
            fn()
            break
    else:
        st.caption("GuignoMap chargé (mode import).")
except Exception:
    st.error("Erreur de démarrage :")
    st.code(traceback.format_exc())
    import platform, streamlit, sqlalchemy
    st.write({
        "python": platform.python_version(),
        "streamlit": streamlit.__version__,
        "sqlalchemy": sqlalchemy.__version__,
        "secrets_keys": list(getattr(st, "secrets", {}).keys()),
    })

--- FILE: requirements.txt ---
streamlit>=1.33,<1.40
pandas>=2.2.0
folium==0.20.0
streamlit-folium>=0.21.0
overpy==0.7
plotly>=5.18.0
xlsxwriter==3.2.8
reportlab==4.4.3

# Authentication - Argon2
passlib[argon2]==1.7.4

# Storage - S3/Cloud (optionnel)
boto3==1.34.*

--- FILE: guignomap/app.py ---
"""
Guigno-Map - Application de gestion de collecte de denrées
Le Relais de Mascouche
Version 3.0 - Production
"""

# pyright: reportCallIssue=false

import os, sys
os.environ.setdefault("PYTHONUTF8", "1")
try:
    sys.stdout.reconfigure(encoding="utf-8")
except Exception:
    pass

from pathlib import Path
import time
from datetime import datetime
import pandas as pd
import streamlit as st

# Configuration du path pour les imports
project_root = Path(__file__).parent.parent
sys.path.insert(0, str(project_root))

import guignomap.config_ville as config_ville

# Monkey-patch supprimé - utilisation de composants Streamlit natifs

# Configuration Streamlit (doit être la première commande Streamlit)
st.set_page_config(
    page_title=f"Guigno-Map | Relais de {config_ville.VILLE_NOM}",
    page_icon="🎁",
    layout="wide",
    initial_sidebar_state="expanded"
)

import folium
from streamlit_folium import st_folium

# Import des modules locaux
from guignomap import database as db
from guignomap.validators import validate_and_clean_input
from guignomap.osm import build_geometry_cache, load_geometry_cache, build_addresses_cache, load_addresses_cache, CACHE_FILE
from guignomap.utils import to_dataframe

# --- Utilitaire de compatibilité pandas Styler ---
from typing import Callable, Any

def style_map_compat(df: pd.DataFrame, fn: Callable[[Any], str], subset: Any = None):
... [fichier tronqué: 2494 lignes total]

--- FILE: guignomap/database.py ---
"""
GuignoMap - Database operations (SQLite Pure)
Unified database layer for GuignoMap
"""
import sqlite3
from pathlib import Path
import threading
from contextlib import contextmanager
from datetime import datetime
import pandas as pd
from typing import Optional, List, Dict, Any
import functools

from guignomap.auth import hash_password, verify_password
from guignomap.backup import auto_backup_before_critical, BackupManager
from guignomap.validators import validate_and_clean_input, InputValidator

# Flag d'initialisation globale
_DB_INITIALIZED = False
_DB_LOCK = threading.Lock()


# =============================================================================
# CACHE SYSTEM
# =============================================================================

def safe_cache(func):
    """Décorateur de cache compatible Streamlit/standalone"""
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        try:
            # Essayer d'utiliser st.cache_data si Streamlit est disponible
            import streamlit as st
            cached_func = st.cache_data(func)
            return cached_func(*args, **kwargs)
        except ImportError:
            # Fallback : cache simple en mémoire
            if not hasattr(wrapper, '_cache'):
                wrapper._cache = {}
            
            # Créer une clé de cache simple
            cache_key = str(args) + str(sorted(kwargs.items()))
            
            if cache_key in wrapper._cache:
                return wrapper._cache[cache_key]
            
            result = func(*args, **kwargs)
            wrapper._cache[cache_key] = result
            return result
    return wrapper
... [fichier tronqué: 835 lignes total]

--- FILE: scripts/import_from_excel.py ---
# scripts/import_from_excel.py
import pandas as pd
import sqlite3
import unicodedata
import re
from pathlib import Path

DB_PATH = Path("guignomap/guigno_map.db")
EXCEL_PATH = Path("imports/mascouche_adresses.xlsx")

def _is_null(x):
    """Vérifie si une valeur est nulle, NaN, 'nan' (insensible à la casse) ou chaîne vide"""
    if x is None:
        return True
    if pd.isna(x):
        return True
    
    # Convertir en string et strip
    str_x = str(x).strip()
    
    # Vérifier si c'est une chaîne vide ou "nan" (insensible à la casse)
    if str_x == "" or str_x.lower() == "nan":
        return True
    
    return False

def _build_street(nomrue, odoparti, odospeci):
    """Construit le nom de rue en privilégiant nomrue, sinon en joignant odoparti + odospeci"""
    # Si nomrue est fiable, l'utiliser directement
    if not _is_null(nomrue):
        return str(nomrue).strip()
    
    # Sinon, joindre proprement odoparti et odospeci en ignorant les valeurs nulles
    parts = []
    
    if not _is_null(odoparti):
        parts.append(str(odoparti).strip())
    
    if not _is_null(odospeci):
        parts.append(str(odospeci).strip())
    
    # Joindre avec un seul espace (pas d'espaces doubles)
    return " ".join(parts) if parts else ""

def _normalize_text(s):
    """Normalise un texte pour créer une clé d'adresse unique - NE JAMAIS retourner 'nan'"""
    if _is_null(s):
        return ""
    
    # Convertir en string et strip
... [fichier tronqué: 341 lignes total]

===============================================================================
RÉSUMÉ BASE DE DONNÉES
===============================================================================
